PACK:./clones/OWASP__split__json-sanitizer
commit f3512bab078af3f5c533dacc2d410add8c0c1124
Author: Fabian Henneke <FabianHenneke@users.noreply.github.com>
Date:   Mon Jun 8 02:53:51 2020 +0200

    Escape <!--, --> and <script (#20)
    
    In HTML script elements, `</script` is not the only substring that
    switches the HTML parser state even when contained in a JS string
    literal. This commit adds escaping for `<!--`, `-->` and `<script`,
    which appear to be all substrings that cause state transitions which
    are not reset by the `"` closing the string literal.

diff --git a/README.md b/README.md
index 27bf209..33f1124 100644
--- a/README.md
+++ b/README.md
@@ -68,8 +68,8 @@ The output is well-formed JSON as defined by
 [RFC 4627](http://www.ietf.org/rfc/rfc4627.txt).
 The output satisfies these additional properties:
 
- * The output will not contain the substring (case-insensitively) `"</script"` so can be embedded inside an HTML script element without further encoding.
- * The output will not contain the substring `"]]>"` so can be embedded inside an XML CDATA section without further encoding.
+ * The output will not contain the substrings (case-insensitively) `"<script"`, `"</script"` and `<!--` and can thus be embedded inside an HTML script element without further encoding.
+ * The output will not contain the substring `"]]>"` and can thus be embedded inside an XML CDATA section without further encoding.
  * The output is a valid Javascript expression, so can be parsed by Javascript's `eval` builtin (after being wrapped in parentheses) or by `JSON.parse`.  Specifically, the output will not contain any string literals with embedded JS newlines (U+2028 Paragraph separator or U+2029 Line separator).
  * The output contains only valid Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value) (no isolated [UTF-16 surrogates](http://www.unicode.org/glossary/#surrogate_pair)) that are [allowed in XML](http://www.w3.org/TR/xml/#charsets) unescaped.
 
diff --git a/src/main/java/com/google/json/JsonSanitizer.java b/src/main/java/com/google/json/JsonSanitizer.java
index 26fcf1d..e08fba2 100644
--- a/src/main/java/com/google/json/JsonSanitizer.java
+++ b/src/main/java/com/google/json/JsonSanitizer.java
@@ -541,16 +541,41 @@ public final class JsonSanitizer {
             }
           }
           break;
-        // Embedding.  Disallow </script and ]]> in string literals so that
-        // the output can be embedded in HTML script elements and in XML CDATA
-        // sections.
-        case '/':
-          // Don't over escape.  Many JSON bodies contain innocuous HTML
-          // that can be safely embedded.
-          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1)
-              && 's' == (jsonish.charAt(i + 1) | 32)
-              && 'c' == (jsonish.charAt(i + 2) | 32)) {
-            insert(i, '\\');
+        // Embedding. Disallow <script, </script, <!--, --> and ]]> in string
+        // literals so that the output can be embedded in HTML script elements
+        // and in XML CDATA sections without affecting the parser state.
+        // References:
+        // https://www.w3.org/TR/html53/semantics-scripting.html#restrictions-for-contents-of-script-elements
+        // https://www.w3.org/TR/html53/syntax.html#script-data-escaped-state
+        // https://www.w3.org/TR/html53/syntax.html#script-data-double-escaped-state
+        // https://www.w3.org/TR/xml/#sec-cdata-sect
+        case '<':
+          // Disallow <!--, which lets the HTML parser switch into the "script
+          // data escaped" state.
+          // Disallow <script, which followed by various characters lets the
+          // HTML parser switch into or out of the "script data double escaped"
+          // state.
+          // Disallow </script, which ends a script block.
+          if (i + 3 >= end)
+            break;
+          char c1 = jsonish.charAt(i + 1);
+          char c2 = jsonish.charAt(i + 2);
+          char c3 = jsonish.charAt(i + 3);
+          char lc1 = (char) (c1 | 32);
+          char lc2 = (char) (c2 | 32);
+          char lc3 = (char) (c3 | 32);
+          if ((c1 == '!' && c2 == '-' && c3 == '-') ||
+              (lc1 == 's' && lc2 == 'c' && lc3 == 'r') ||
+              (c1 == '/' && lc2 == 's' && lc3 == 'c')) {
+            replace(i, i + 1, "\\u003c"); // Escaped <
+          }
+          break;
+        case '>':
+          // Disallow -->, which lets the HTML parser switch out of the "script
+          // data escaped" or "script data double escaped" state.
+          if ((i - 2) >= start && '-' == jsonish.charAt(i - 2)
+              && '-' == jsonish.charAt(i - 1)) {
+            replace(i, i + 1, "\\u003e"); // Escaped >
           }
           break;
         case ']':
diff --git a/src/test/java/com/google/json/JsonSanitizerTest.java b/src/test/java/com/google/json/JsonSanitizerTest.java
index e50fd78..de22b28 100644
--- a/src/test/java/com/google/json/JsonSanitizerTest.java
+++ b/src/test/java/com/google/json/JsonSanitizerTest.java
@@ -56,14 +56,12 @@ public final class JsonSanitizerTest extends TestCase {
     assertSanitized("\"foo\"");
     assertSanitized("\"foo\"", "'foo'");
     assertSanitized(
-        "\"<script>foo()<\\/script>\"", "\"<script>foo()</script>\"");
-    assertSanitized(
-        "\"<script>foo()<\\/script>\"", "\"<script>foo()</script>\"");
-    assertSanitized("\"<\\/SCRIPT\\n>\"", "\"</SCRIPT\n>\"");
-    assertSanitized("\"<\\/ScRIpT\"", "\"</ScRIpT\"");
+        "\"\\u003cscript>foo()\\u003c/script>\"", "\"<script>foo()</script>\"");
+    assertSanitized("\"\\u003c/SCRIPT\\n>\"", "\"</SCRIPT\n>\"");
+    assertSanitized("\"\\u003c/ScRIpT\"", "\"</ScRIpT\"");
     // \u0130 is a Turkish dotted upper-case 'I' so the lower case version of
     // the tag name is "script".
-    assertSanitized("\"<\\/ScR\u0130pT\"", "\"</ScR\u0130pT\"");
+    assertSanitized("\"\\u003c/ScR\u0130pT\"", "\"</ScR\u0130pT\"");
     assertSanitized("\"<b>Hello</b>\"");
     assertSanitized("\"<s>Hello</s>\"");
     assertSanitized("\"<[[\\u005d]>\"", "'<[[]]>'");
@@ -211,4 +209,23 @@ public final class JsonSanitizerTest extends TestCase {
         "[ { \"description\": \"aa##############aa\" }, 1 ]",
         "[ { \"description\": \"aa##############aa\" }, 1 ]");
   }
+
+  @Test
+  public static final void testHtmlParserStateChanges() {
+    assertSanitized("\"\\u003cscript\"", "\"<script\"");
+    assertSanitized("\"\\u003cScript\"", "\"<Script\"");
+    // \u0130 is a Turkish dotted upper-case 'I' so the lower case version of
+    // the tag name is "script".
+    assertSanitized("\"\\u003cScR\u0130pT\"", "\"<ScR\u0130pT\"");
+    assertSanitized("\"\\u003cSCRIPT\\n>\"", "\"<SCRIPT\n>\"");
+    assertSanitized("\"script\"", "<script");
+
+    assertSanitized("\"\\u003c!--\"", "\"<!--\"");
+    assertSanitized("-0", "<!--");
+
+    assertSanitized("\"--\\u003e\"", "\"-->\"");
+    assertSanitized("-0", "-->");
+
+    assertSanitized("\"\\u003c!--\\u003cscript>\"", "\"<!--<script>\"");
+  }
 }

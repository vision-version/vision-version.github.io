package com.vaadin.data.provider;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import com.vaadin.data.ValueProvider;
import com.vaadin.data.provider.DataChangeEvent.DataRefreshEvent;
import com.vaadin.server.AbstractExtension;
import com.vaadin.server.KeyMapper;
import com.vaadin.server.SerializableConsumer;
import com.vaadin.shared.Range;
import com.vaadin.shared.Registration;
import com.vaadin.shared.data.DataCommunicatorClientRpc;
import com.vaadin.shared.data.DataCommunicatorConstants;
import com.vaadin.shared.data.DataRequestRpc;
import com.vaadin.shared.extension.datacommunicator.DataCommunicatorState;
import com.vaadin.ui.ComboBox;
import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;
public class DataCommunicator<T> extends AbstractExtension {
    private Registration dataProviderUpdateRegistration;
    protected class SimpleDataRequestRpc implements DataRequestRpc {
        public void requestRows(int firstRowIndex, int numberOfRows, int firstCachedRowIndex, int cacheSize) {
            onRequestRows(firstRowIndex, numberOfRows, firstCachedRowIndex, cacheSize);
        }
        
        public void dropRows(JsonArray keys) {
            onDropRows(keys);
        }
        
    }
    
    protected class ActiveDataHandler implements DataGenerator<T> {
        private final Set<String> activeData = new HashSet<>();
        private final Set<String> droppedData = new HashSet<>();
        public void addActiveData(Stream<T> dataObjects) {
            dataObjects.map(getKeyMapper()::key) .filter(key -> !activeData.contains(key)) .forEach(activeData::add);
        }
        
        public void cleanUp(Stream<T> dataObjects) {
            Collection<String> keys = dataObjects.map(getKeyMapper()::key) .collect(Collectors.toSet());
            droppedData.removeAll(keys);
            dropData(droppedData);
            droppedData.clear();
        }
        
        public void dropAllActiveData() {
            activeData.forEach(this::dropActiveData);
        }
        
        public void dropActiveData(String key) {
            if (activeData.contains(key)) {
                droppedData.add(key);
            }
            
        }
        
        protected Map<Object, T> getDroppedData() {
            Function<T, Object> getId = getDataProvider()::getId;
            return droppedData.stream().map(getKeyMapper()::get) .collect(Collectors.toMap(getId, i -> i));
        }
        
        public Map<Object, T> getActiveData() {
            Function<T, Object> getId = getDataProvider()::getId;
            return activeData.stream().map(getKeyMapper()::get) .collect(Collectors.toMap(getId, i -> i));
        }
        
        public void generateData(T data, JsonObject jsonObject) {
            getKeyMapper().refresh(data);
            jsonObject.put(DataCommunicatorConstants.KEY, getKeyMapper().key(data));
        }
        
        public void destroyData(T data) {
            activeData.remove(getKeyMapper().key(data));
            getKeyMapper().remove(data);
        }
        
        public void destroyAllData() {
            droppedData.clear();
            activeData.clear();
            updatedData.clear();
            getKeyMapper().removeAll();
        }
        
    }
    
    private final Collection<DataGenerator<T>> generators = new LinkedHashSet<>();
    private final ActiveDataHandler handler = new ActiveDataHandler();
    private DataProvider<T, ?> dataProvider = new CallbackDataProvider<>( q -> Stream.empty(), q -> 0);
    private final DataKeyMapper<T> keyMapper;
    protected boolean reset = true;
    private final Set<T> updatedData = new HashSet<>();
    private int minPushSize = 40;
    private Range pushRows = Range.withLength(0, minPushSize);
    private Object filter;
    private Comparator<T> inMemorySorting;
    private final List<QuerySortOrder> backEndSorting = new ArrayList<>();
    private final DataCommunicatorClientRpc rpc;
    public DataCommunicator() {
        addDataGenerator(handler);
        rpc = getRpcProxy(DataCommunicatorClientRpc.class);
        registerRpc(createRpc());
        keyMapper = createKeyMapper(dataProvider::getId);
    }
    
    public void attach() {
        super.attach();
        attachDataProviderListener();
    }
    
    public void detach() {
        super.detach();
        detachDataProviderListener();
    }
    
    protected void setPushRows(Range pushRows) {
        this.pushRows = pushRows;
    }
    
    protected Range getPushRows() {
        return pushRows;
    }
    
    protected Object getFilter() {
        return filter;
    }
    
    protected DataCommunicatorClientRpc getClientRpc() {
        return rpc;
    }
    
    protected void onRequestRows(int firstRowIndex, int numberOfRows, int firstCachedRowIndex, int cacheSize) {
        setPushRows(Range.withLength(firstRowIndex, numberOfRows));
        markAsDirty();
    }
    
    protected void onDropRows(JsonArray keys) {
        for (int i = 0; i < keys.length(); ++i) {
            handler.dropActiveData(keys.getString(i));
        }
        
    }
    
    public void beforeClientResponse(boolean initial) {
        super.beforeClientResponse(initial);
        if (initial && getPushRows().isEmpty()) {
            setPushRows(Range.withLength(0, getMinPushSize()));
        }
        
        sendDataToClient(initial);
    }
    
    protected void sendDataToClient(boolean initial) {
        if (getDataProvider() == null) {
            return;
        }
        
        if (initial || reset) {
            if (reset) {
                handler.dropAllActiveData();
            }
            
            rpc.reset(getDataProviderSize());
        }
        
        if (!updatedData.isEmpty()) {
            JsonArray dataArray = Json.createArray();
            int i = 0;
            for (T data : updatedData) {
                dataArray.set(i++, getDataObject(data));
            }
            
            rpc.updateData(dataArray);
        }
        
        Range requestedRows = getPushRows();
        boolean triggerReset = false;
        if (!requestedRows.isEmpty()) {
            int offset = requestedRows.getStart();
            int limit = requestedRows.length();
            List<T> rowsToPush = fetchItemsWithRange(offset, limit);
            if (!initial && !reset && rowsToPush.isEmpty()) {
                triggerReset = true;
            }
            
            pushData(offset, rowsToPush);
        }
        
        setPushRows(Range.withLength(0, 0));
        reset = triggerReset;
        updatedData.clear();
    }
    
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public List<T> fetchItemsWithRange(int offset, int limit) {
        return (List<T>) getDataProvider().fetch(new Query(offset, limit, backEndSorting, inMemorySorting, filter)) .collect(Collectors.toList());
    }
    
    public void addDataGenerator(DataGenerator<T> generator) {
        Objects.requireNonNull(generator, "generator cannot be null");
        generators.add(generator);
        reset();
    }
    
    public void removeDataGenerator(DataGenerator<T> generator) {
        Objects.requireNonNull(generator, "generator cannot be null");
        generators.remove(generator);
    }
    
    public DataKeyMapper<T> getKeyMapper() {
        return keyMapper;
    }
    
    protected void pushData(int firstIndex, List<T> data) {
        JsonArray dataArray = Json.createArray();
        int i = 0;
        for (T item : data) {
            dataArray.set(i++, getDataObject(item));
        }
        
        rpc.setData(firstIndex, dataArray);
        handler.addActiveData(data.stream());
        handler.cleanUp(data.stream());
    }
    
    protected JsonObject getDataObject(T data) {
        JsonObject dataObject = Json.createObject();
        for (DataGenerator<T> generator : generators) {
            generator.generateData(data, dataObject);
        }
        
        return dataObject;
    }
    
    protected ActiveDataHandler getActiveDataHandler() {
        return handler;
    }
    
    private void dropData(Collection<String> droppedKeys) {
        for (String key : droppedKeys) {
            assert key != null : "Bookkeepping failure. Dropping a null key";
            T data = getKeyMapper().get(key);
            assert data != null : "Bookkeepping failure. No data object to match key";
            for (DataGenerator<T> g : generators) {
                g.destroyData(data);
            }
            
        }
        
    }
    
    protected void dropAllData() {
        for (DataGenerator<T> g : generators) {
            g.destroyAllData();
        }
        
        handler.destroyAllData();
    }
    
    public void reset() {
        if (!reset) {
            if (getParent() instanceof ComboBox) {
                beforeClientResponse(true);
            }
            
            getClientRpc().reset(getDataProviderSize());
        }
        
    }
    
    public void refresh(T data) {
        Objects.requireNonNull(data, "DataCommunicator can not refresh null object");
        Object id = getDataProvider().getId(data);
        Map<Object, T> activeData = getActiveDataHandler().getActiveData();
        if (activeData.containsKey(id)) {
            if (updatedData.isEmpty()) {
                markAsDirty();
            }
            
            updatedData.add(activeData.get(id));
        }
        
    }
    
    protected Set<T> getUpdatedData() {
        return updatedData;
    }
    
    public void setInMemorySorting(Comparator<T> comparator, boolean immediateReset) {
        inMemorySorting = comparator;
        if (immediateReset) {
            reset();
        }
        
    }
    
    public void setInMemorySorting(Comparator<T> comparator) {
        setInMemorySorting(comparator, true);
    }
    
    public Comparator<T> getInMemorySorting() {
        return inMemorySorting;
    }
    
    public void setBackEndSorting(List<QuerySortOrder> sortOrder, boolean immediateReset) {
        backEndSorting.clear();
        backEndSorting.addAll(sortOrder);
        if (immediateReset) {
            reset();
        }
        
    }
    
    public void setBackEndSorting(List<QuerySortOrder> sortOrder) {
        setBackEndSorting(sortOrder, true);
    }
    
    public List<QuerySortOrder> getBackEndSorting() {
        return Collections.unmodifiableList(backEndSorting);
    }
    
    protected DataKeyMapper<T> createKeyMapper( ValueProvider<T, Object> identifierGetter) {
        return new KeyMapper<T>(identifierGetter);
    }
    
    protected DataRequestRpc createRpc() {
        return new SimpleDataRequestRpc();
    }
    
    public DataProvider<T, ?> getDataProvider() {
        return dataProvider;
    }
    
    public <F> SerializableConsumer<F> setDataProvider( DataProvider<T, F> dataProvider, F initialFilter) {
        Objects.requireNonNull(dataProvider, "data provider cannot be null");
        filter = initialFilter;
        setDataProvider(dataProvider);
        setPushRows(Range.between(0, getMinPushSize()));
        if (isAttached()) {
            attachDataProviderListener();
        }
        
        reset = true;
        markAsDirty();
        return filter -> {
            if (this.dataProvider != dataProvider) {
                throw new IllegalStateException( "Filter slot is no longer valid after data provider has been changed");
            }
            
            if (!Objects.equals(this.filter, filter)) {
                setFilter(filter);
                reset();
                markAsDirty();
            }
            
        };
    }
    
    protected <F> void setFilter(F filter) {
        this.filter = filter;
    }
    
    public void setMinPushSize(int size) {
        if (size < 0) {
            throw new IllegalArgumentException("Value cannot be negative");
        }
        
        minPushSize = size;
    }
    
    public int getMinPushSize() {
        return minPushSize;
    }
    
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public int getDataProviderSize() {
        return getDataProvider().size(new Query(getFilter()));
    }
    
    protected DataCommunicatorState getState(boolean markAsDirty) {
        return (DataCommunicatorState) super.getState(markAsDirty);
    }
    
    protected DataCommunicatorState getState() {
        return (DataCommunicatorState) super.getState();
    }
    
    private void attachDataProviderListener() {
        dataProviderUpdateRegistration = getDataProvider() .addDataProviderListener(event -> {
                    if (event instanceof DataRefreshEvent) {
                        T item = ((DataRefreshEvent<T>) event).getItem();
                        getKeyMapper().refresh(item);
                        generators.forEach(g -> g.refreshData(item));
                        getUI().access(() -> refresh(item));
                    }
                     else {
                        reset = true;
                        getUI().access(() -> markAsDirty());
                    }
                    
                }
                
);
    }
    
    private void detachDataProviderListener() {
        if (dataProviderUpdateRegistration != null) {
            dataProviderUpdateRegistration.remove();
            dataProviderUpdateRegistration = null;
        }
        
    }
    
    protected void setDataProvider(DataProvider<T, ?> dataProvider) {
        detachDataProviderListener();
        dropAllData();
        this.dataProvider = dataProvider;
        getKeyMapper().setIdentifierGetter(dataProvider::getId);
    }
    
}



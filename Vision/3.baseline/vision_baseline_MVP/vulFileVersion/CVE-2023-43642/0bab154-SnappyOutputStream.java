package org.xerial.snappy;
import org.xerial.snappy.buffer.BufferAllocatorFactory;
import org.xerial.snappy.buffer.BufferAllocator;
import org.xerial.snappy.buffer.CachedBufferAllocator;
import java.io.IOException;
import java.io.OutputStream;
public class SnappyOutputStream extends OutputStream {
    static final int MIN_BLOCK_SIZE = 1 * 1024;
    static final int DEFAULT_BLOCK_SIZE = 32 * 1024; 
    protected final OutputStream out;
    private final int blockSize;
    private final BufferAllocator inputBufferAllocator;
    private final BufferAllocator outputBufferAllocator;
    protected byte[] inputBuffer;
    protected byte[] outputBuffer;
    private int inputCursor = 0;
    private int outputCursor = 0;
    private boolean headerWritten;
    private boolean closed;
    public SnappyOutputStream(OutputStream out) {
        this(out, DEFAULT_BLOCK_SIZE);
    }
    
    public SnappyOutputStream(OutputStream out, int blockSize) {
        this(out, blockSize, CachedBufferAllocator.getBufferAllocatorFactory());
    }
    
    public SnappyOutputStream(OutputStream out, int blockSize, BufferAllocatorFactory bufferAllocatorFactory) {
        this.out = out;
        this.blockSize = Math.max(MIN_BLOCK_SIZE, blockSize);
        int inputSize = blockSize;
        int outputSize = SnappyCodec.HEADER_SIZE + 4 + Snappy.maxCompressedLength(blockSize);
        this.inputBufferAllocator = bufferAllocatorFactory.getBufferAllocator(inputSize);
        this.outputBufferAllocator = bufferAllocatorFactory.getBufferAllocator(outputSize);
        inputBuffer = inputBufferAllocator.allocate(inputSize);
        outputBuffer = outputBufferAllocator.allocate(outputSize);
    }
    
    public void write(byte[] b, int byteOffset, int byteLength) throws IOException {
        if (closed) {
            throw new IOException("Stream is closed");
        }
        
        int cursor = 0;
        while (cursor < byteLength) {
            int readLen = Math.min(byteLength - cursor, blockSize - inputCursor);
            if (readLen > 0) {
                System.arraycopy(b, byteOffset + cursor, inputBuffer, inputCursor, readLen);
                inputCursor += readLen;
            }
            
            if (inputCursor < blockSize) {
                return;
            }
            
            compressInput();
            cursor += readLen;
        }
        
    }
    
    public void write(long[] d, int off, int len) throws IOException {
        rawWrite(d, off * 8, len * 8);
    }
    
    public void write(double[] f, int off, int len) throws IOException {
        rawWrite(f, off * 8, len * 8);
    }
    
    public void write(float[] f, int off, int len) throws IOException {
        rawWrite(f, off * 4, len * 4);
    }
    
    public void write(int[] f, int off, int len) throws IOException {
        rawWrite(f, off * 4, len * 4);
    }
    
    public void write(short[] f, int off, int len) throws IOException {
        rawWrite(f, off * 2, len * 2);
    }
    
    public void write(long[] d) throws IOException {
        write(d, 0, d.length);
    }
    
    public void write(double[] f) throws IOException {
        write(f, 0, f.length);
    }
    
    public void write(float[] f) throws IOException {
        write(f, 0, f.length);
    }
    
    public void write(int[] f) throws IOException {
        write(f, 0, f.length);
    }
    
    public void write(short[] f) throws IOException {
        write(f, 0, f.length);
    }
    
    private boolean hasSufficientOutputBufferFor(int inputSize) {
        int maxCompressedSize = Snappy.maxCompressedLength(inputSize);
        return maxCompressedSize < outputBuffer.length - outputCursor - 4;
    }
    
    public void rawWrite(Object array, int byteOffset, int byteLength) throws IOException {
        if (closed) {
            throw new IOException("Stream is closed");
        }
        
        int cursor = 0;
        while (cursor < byteLength) {
            int readLen = Math.min(byteLength - cursor, blockSize - inputCursor);
            if (readLen > 0) {
                Snappy.arrayCopy(array, byteOffset + cursor, readLen, inputBuffer, inputCursor);
                inputCursor += readLen;
            }
            
            if (inputCursor < blockSize) {
                return;
            }
            
            compressInput();
            cursor += readLen;
        }
        
    }
    
    public void write(int b) throws IOException {
        if (closed) {
            throw new IOException("Stream is closed");
        }
        
        if (inputCursor >= inputBuffer.length) {
            compressInput();
        }
        
        inputBuffer[inputCursor++] = (byte) b;
    }
    
    public void flush() throws IOException {
        if (closed) {
            throw new IOException("Stream is closed");
        }
        
        compressInput();
        dumpOutput();
        out.flush();
    }
    
    static void writeInt(byte[] dst, int offset, int v) {
        dst[offset] = (byte) ((v >> 24) & 0xFF);
        dst[offset + 1] = (byte) ((v >> 16) & 0xFF);
        dst[offset + 2] = (byte) ((v >> 8) & 0xFF);
        dst[offset + 3] = (byte) ((v >> 0) & 0xFF);
    }
    
    static int readInt(byte[] buffer, int pos) {
        int b1 = (buffer[pos] & 0xFF) << 24;
        int b2 = (buffer[pos + 1] & 0xFF) << 16;
        int b3 = (buffer[pos + 2] & 0xFF) << 8;
        int b4 = buffer[pos + 3] & 0xFF;
        return b1 | b2 | b3 | b4;
    }
    
    protected void dumpOutput() throws IOException {
        if (outputCursor > 0) {
            out.write(outputBuffer, 0, outputCursor);
            outputCursor = 0;
        }
        
    }
    
    protected void compressInput() throws IOException {
        if (!headerWritten) {
            outputCursor = writeHeader();
            headerWritten = true;
        }
        
        if (inputCursor <= 0) {
            return; 
        }
        
        if (!hasSufficientOutputBufferFor(inputCursor)) {
            dumpOutput();
        }
        
        writeBlockPreemble();
        int compressedSize = Snappy.compress(inputBuffer, 0, inputCursor, outputBuffer, outputCursor + 4);
        writeInt(outputBuffer, outputCursor, compressedSize);
        outputCursor += 4 + compressedSize;
        inputCursor = 0;
    }
    
    protected int writeHeader(){
        return SnappyCodec.currentHeader.writeHeader(outputBuffer, 0);
    }
    
    protected void writeBlockPreemble() {
    }
    
    protected void writeCurrentDataSize(){
        writeInt(outputBuffer, outputCursor, inputCursor);
        outputCursor += 4;
    }
    
    public void close() throws IOException {
        if (closed) {
            return;
        }
        
        try {
            flush();
            out.close();
        }
        
        finally {
            closed = true;
            inputBufferAllocator.release(inputBuffer);
            outputBufferAllocator.release(outputBuffer);
            inputBuffer = null;
            outputBuffer = null;
        }
        
    }
    
}



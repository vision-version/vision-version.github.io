package org.apache.sling.api.request.builder.impl;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.sling.api.request.RequestProgressTracker;
public class RequestProgressTrackerImpl implements RequestProgressTracker {
    private static final String REQUEST_PROCESSING_TIMER = "Request Processing";
    private static final String LOG_PREFIX = "LOG ";
    private static final String COMMENT_PREFIX = "COMMENT ";
    private static final String TIMER_END_FORMAT = "{<elapsed microseconds>,<timer name>} <optional message>";
    private static final int PADDING_WIDTH = 7;
    private final long processingStart;
    private long processingEnd;
    private final List<TrackingEntry> entries = new ArrayList<TrackingEntry>();
    private final Map<String, Long> namedTimerEntries = new HashMap<String, Long>();
    private final FastMessageFormat messageFormat = new FastMessageFormat();
    public RequestProgressTrackerImpl() {
        this.processingStart = startTimerInternal(REQUEST_PROCESSING_TIMER);
        this.processingEnd = -1;
        this.entries.add(new TrackingEntry(COMMENT_PREFIX + "timer_end format is " + TIMER_END_FORMAT));
    }
    
    public Iterator<String> getMessages() {
        return new Iterator<String>() {             private final Iterator<TrackingEntry> entryIter = entries.iterator();
            public boolean hasNext() {
                return entryIter.hasNext();
            }
            
            public String next() {
                final TrackingEntry entry = entryIter.next();
                final long offset = entry.getTimeStamp() - getTimeStamp();
                return formatMessage(offset, entry.getMessage());
            }
            
            public void remove() {
                throw new UnsupportedOperationException("remove");
            }
            
        };
    }
    
    private String formatMessage(final long offset, final String message) {
        final StringBuilder sb = new StringBuilder(PADDING_WIDTH + 1 +  message.length() + 1);
        final String offsetStr = Long.toString(offset / 1000);
        for (int i = PADDING_WIDTH - offsetStr.length(); i > 0; i--) {
            sb.append(' ');
        }
        
        sb.append(offsetStr).append(' ').append(message).append('\n');
        return sb.toString();
    }
    
    public void dump(final PrintWriter writer) {
        logTimer(REQUEST_PROCESSING_TIMER, "Dumping SlingRequestProgressTracker Entries");
        final StringBuilder sb = new StringBuilder();
        final Iterator<String> messages = getMessages();
        while (messages.hasNext()) {
            sb.append(messages.next());
        }
        
        writer.print(sb.toString());
    }
    
    public void log(final String message) {
        entries.add(new TrackingEntry(LOG_PREFIX + message));
    }
    
    public void log(final String format, final Object... args) {
        String message = messageFormat.format(format, args);
        entries.add(new TrackingEntry(LOG_PREFIX + message));
    }
    
    public void startTimer(final String name) {
        startTimerInternal(name);
    }
    
    private long startTimerInternal(final String name) {
        long timer = System.nanoTime();
        namedTimerEntries.put(name, timer);
        entries.add(new TrackingEntry(timer, "TIMER_START{" + name + "}"));
        return timer;
    }
    
    public void logTimer(final String name) {
        if (namedTimerEntries.containsKey(name)) {
            logTimerInternal(name, null, namedTimerEntries.get(name));
        }
        
    }
    
    public void logTimer(final String name, final String format, final Object... args) {
        if (namedTimerEntries.containsKey(name)) {
            logTimerInternal(name, messageFormat.format(format, args), namedTimerEntries.get(name));
        }
        
    }
    
    private void logTimerInternal(final String name, final String msg, final long startTime) {
        final StringBuilder sb = new StringBuilder();
        sb.append("TIMER_END{");
        sb.append((System.nanoTime() - startTime) / 1000);
        sb.append(',');
        sb.append(name);
        sb.append('}');
        if(msg != null) {
            sb.append(' ');
            sb.append(msg);
        }
        
        entries.add(new TrackingEntry(sb.toString()));
    }
    
    public void done() {
        if(processingEnd != -1) return;
        logTimer(REQUEST_PROCESSING_TIMER, REQUEST_PROCESSING_TIMER);
        processingEnd = System.nanoTime();
    }
    
    private long getTimeStamp() {
        return processingStart;
    }
    
    public long getDuration() {
        if (processingEnd != -1) {
            return processingEnd - processingStart;
        }
        
        return System.nanoTime() - processingStart;
    }
    
    private static class TrackingEntry {
        private final long timeStamp;
        private final String message;
        TrackingEntry(final String message) {
            this(System.nanoTime(), message);
        }
        
        TrackingEntry(final long timeStamp, final String message) {
            this.timeStamp = timeStamp;
            this.message = message;
        }
        
        long getTimeStamp() {
            return timeStamp;
        }
        
        String getMessage() {
            return message;
        }
        
    }
    
}



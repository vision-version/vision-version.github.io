package com.google.json;
public final class JsonSanitizer {
  public static final int DEFAULT_NESTING_DEPTH = 64;
  public static final int MAXIMUM_NESTING_DEPTH = 4096;
  public static String sanitize(String jsonish) {
    return sanitize(jsonish, DEFAULT_NESTING_DEPTH);
  }
  
  public static String sanitize(String jsonish, int maximumNestingDepth) {
    JsonSanitizer s = new JsonSanitizer(jsonish, maximumNestingDepth);
    s.sanitize();
    return s.toString();
  }
  
  private enum State {
    START_ARRAY, BEFORE_ELEMENT, AFTER_ELEMENT, START_MAP, BEFORE_KEY, AFTER_KEY, BEFORE_VALUE, AFTER_VALUE, ;
  }
  
  private final int maximumNestingDepth;
  private final String jsonish;
  private int bracketDepth;
  private boolean[] isMap;
  private StringBuilder sanitizedJson;
  private int cleaned;
  private static final boolean SUPER_VERBOSE_AND_SLOW_LOGGING = false;
  JsonSanitizer(String jsonish) {
    this(jsonish, DEFAULT_NESTING_DEPTH);
  }
  
  JsonSanitizer(String jsonish, int maximumNestingDepth) {
    this.maximumNestingDepth = Math.min(Math.max(1, maximumNestingDepth),MAXIMUM_NESTING_DEPTH);
    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {
      System.err.println("\n" + jsonish + "\n========");
    }
    
    this.jsonish = jsonish != null ? jsonish : "null";
  }
  
  int getMaximumNestingDepth() {
    return this.maximumNestingDepth;
  }
  
  void sanitize() {
    bracketDepth = cleaned = 0;
    sanitizedJson = null;
    State state = State.START_ARRAY;
    int n = jsonish.length();
    token_loop: for (int i = 0; i < n; ++i) {
      try {
        char ch = jsonish.charAt(i);
        if (SUPER_VERBOSE_AND_SLOW_LOGGING) {
          String sanitizedJsonStr = (sanitizedJson == null ? "" : sanitizedJson) + jsonish.substring(cleaned, i);
          System.err.println("i=" + i + ", ch=" + ch + ", state=" + state + ", sanitized=" + sanitizedJsonStr);
        }
        
        switch (ch) {
          case '\t': case '\n': case '\r': case ' ':
            break;
          case '"': case '\'':
            state = requireValueState(i, state, true);
            int strEnd = endOfQuotedString(jsonish, i);
            sanitizeString(i, strEnd);
            i = strEnd - 1;
            break;
          case '(': case ')':
            elide(i, i + 1);
            break;
          case '{': case '[':
            state = requireValueState(i, state, false);
            if (isMap == null) {
              isMap = new boolean[maximumNestingDepth];
            }
            
            boolean map = ch == '{';
            isMap[bracketDepth] = map; ++bracketDepth;
            state = map ? State.START_MAP : State.START_ARRAY;
            break;
          case '}': case ']':
            if (bracketDepth == 0) {
              elide(i, jsonish.length());
              break token_loop;
            }
            
            switch (state) {
              case BEFORE_VALUE:
                insert(i, "null");
                break;
              case BEFORE_ELEMENT: case BEFORE_KEY:
                elideTrailingComma(i);
                break;
              case AFTER_KEY:
                insert(i, ":null");
                break;
              case START_MAP: case START_ARRAY:
              case AFTER_ELEMENT: case AFTER_VALUE: break;
            }
             --bracketDepth;
            char closeBracket = isMap[bracketDepth] ? '}' : ']';
            if (ch != closeBracket) {
              replace(i, i + 1, closeBracket);
            }
            
            state = bracketDepth == 0 || !isMap[bracketDepth - 1] ? State.AFTER_ELEMENT : State.AFTER_VALUE;
            break;
          case ',':
            if (bracketDepth == 0) {
 throw UNBRACKETED_COMMA; 
}

            switch (state) {
              case AFTER_ELEMENT:
                state = State.BEFORE_ELEMENT;
                break;
              case AFTER_VALUE:
                state = State.BEFORE_KEY;
                break;
              case START_ARRAY: case BEFORE_ELEMENT:
                insert(i, "null");
                state = State.BEFORE_ELEMENT;
                break;
              case START_MAP: case BEFORE_KEY:
              case AFTER_KEY:
                elide(i, i + 1);
                break;
              case BEFORE_VALUE:
                insert(i, "null");
                state = State.BEFORE_KEY;
                break;
            }
            
            break;
          case ':':
            if (state == State.AFTER_KEY) {
              state = State.BEFORE_VALUE;
            }
             else {
              elide(i, i + 1);
            }
            
            break;
          case '/':
            int end = i + 1;
            if (i + 1 < n) {
              switch (jsonish.charAt(i + 1)) {
                case '/':
                  end = n;  
                  for (int j = i + 2; j < n; ++j) {
                    char cch = jsonish.charAt(j);
                    if (cch == '\n' || cch == '\r' || cch == '\u2028' || cch == '\u2029') {
                      end = j + 1;
                      break;
                    }
                    
                  }
                  
                  break;
                case '*':
                  end = n;
                  if (i + 3 < n) {
                    for (int j = i + 2; (j = jsonish.indexOf('/', j + 1)) >= 0;) {
                      if (jsonish.charAt(j - 1) == '*') {
                        end = j + 1;
                        break;
                      }
                      
                    }
                    
                  }
                  
                  break;
              }
              
            }
            
            elide(i, end);
            i = end - 1;
            break;
          default: int runEnd;
            for (runEnd = i; runEnd < n; ++runEnd) {
              char tch = jsonish.charAt(runEnd);
              if (('a' <= tch && tch <= 'z') || ('0' <= tch && tch <= '9') || tch == '+' || tch == '-' || tch == '.' || ('A' <= tch && tch <= 'Z') || tch == '_' || tch == '$') {
                continue;
              }
              
              break;
            }
            
            if (runEnd == i) {
              elide(i, i + 1);
              break;
            }
            
            state = requireValueState(i, state, true);
            boolean isNumber = ('0' <= ch && ch <= '9') || ch == '.' || ch == '+' || ch == '-';
            boolean isKeyword = !isNumber && isKeyword(i, runEnd);
            if (!(isNumber || isKeyword)) {
              for (; runEnd < n; ++runEnd) {
                if (isJsonSpecialChar(runEnd)) {
                  break;
                }
                
              }
              
              if (runEnd < n && jsonish.charAt(runEnd) == '"') { ++runEnd;
              }
              
            }
            
            if (state == State.AFTER_KEY) {
              insert(i, '"');
              if (isNumber) {
                canonicalizeNumber(i, runEnd);
                insert(runEnd, '"');
              }
               else {
                sanitizeString(i, runEnd);
              }
              
            }
             else {
              if (isNumber) {
                normalizeNumber(i, runEnd);
              }
               else if (!isKeyword) {
                insert(i, '"');
                sanitizeString(i, runEnd);
              }
              
            }
            
            i = runEnd - 1;
        }
        
      }
       catch (@SuppressWarnings("unused") UnbracketedComma e) {
        elide(i, jsonish.length());
        break;
      }
      
    }
    
    if (state == State.START_ARRAY && bracketDepth == 0) {
      insert(n, "null");
      state = State.AFTER_ELEMENT;
    }
    
    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {
      System.err.println( "state=" + state + ", sanitizedJson=" + sanitizedJson + ", cleaned=" + cleaned + ", bracketDepth=" + bracketDepth);
    }
    
    if ((sanitizedJson != null && sanitizedJson.length() != 0) || cleaned != 0 || bracketDepth != 0) {
      if (sanitizedJson == null) {
        sanitizedJson = new StringBuilder(n + bracketDepth);
      }
      
      sanitizedJson.append(jsonish, cleaned, n);
      cleaned = n;
      switch (state) {
        case BEFORE_ELEMENT: case BEFORE_KEY:
          elideTrailingComma(n);
          break;
        case AFTER_KEY:
          sanitizedJson.append(":null");
          break;
        case BEFORE_VALUE:
          sanitizedJson.append("null");
          break;
        default: break;
      }
      
      while (bracketDepth != 0) {
        sanitizedJson.append(isMap[--bracketDepth] ? '}' : ']');
      }
      
    }
    
  }
  
  private void sanitizeString(int start, int end) {
    boolean closed = false;
    for (int i = start; i < end; ++i) {
      char ch = jsonish.charAt(i);
      switch (ch) {
        case '\n': replace(i, i + 1, "\\n"); break;
        case '\r': replace(i, i + 1, "\\r"); break;
        case '\u2028': replace(i, i + 1, "\\u2028"); break;
        case '\u2029': replace(i, i + 1, "\\u2029"); break;
        case '"': case '\'':
          if (i == start) {
            if (ch == '\'') {
 replace(i, i + 1, '"'); 
}

          }
           else {
            if (i + 1 == end) {
              char startDelim = jsonish.charAt(start);
              if (startDelim != '\'') {
                startDelim = '"';
              }
              
              closed = startDelim == ch;
            }
            
            if (closed) {
              if (ch == '\'') {
 replace(i, i + 1, '"'); 
}

            }
             else if (ch == '"') {
              insert(i, '\\');
            }
            
          }
          
          break;
        case '/':
          if (i > start && i + 2 < end && '<' == jsonish.charAt(i - 1) && 's' == (jsonish.charAt(i + 1) | 32) && 'c' == (jsonish.charAt(i + 2) | 32)) {
            insert(i, '\\');
          }
          
          break;
        case ']':
          if (i + 2 < end && ']' == jsonish.charAt(i + 1) && '>' == jsonish.charAt(i + 2)) {
            replace(i, i + 1, "\\u005d");
          }
          
          break;
        case '\\':
          if (i + 1 == end) {
            elide(i, i + 1);
            break;
          }
          
          char sch = jsonish.charAt(i + 1);
          switch (sch) {
            case 'b': case 'f': case 'n': case 'r': case 't': case '\\':
            case '/': case '"': ++i;
              break;
            case 'v':  
              replace(i, i + 2, "\\u0008"); ++i;
              break;
            case 'x':
              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {
                replace(i, i + 2, "\\u00");  
                i += 3;
                break;
              }
              
              elide(i, i + 1);
              break;
            case 'u':
              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3) && isHexAt(i + 4) && isHexAt(i + 5)) {
                i += 5;
                break;
              }
              
              elide(i, i + 1);
              break;
            case '0': case '1': case '2': case '3':
            case '4': case '5': case '6': case '7':
              int octalEnd = i + 1;
              if (octalEnd + 1 < end && isOctAt(octalEnd + 1)) { ++octalEnd;
                if (ch <= '3' && octalEnd + 1 < end && isOctAt(octalEnd + 1)) { ++octalEnd;
                }
                
                int value = 0;
                for (int j = i; j < octalEnd; ++j) {
                  value = (value << 3) | (jsonish.charAt(j) - '0');
                }
                
                replace(i + 1, octalEnd, "u00");
                appendHex(value, 2);
              }
              
              i = octalEnd - 1;
              break;
            default: elide(i, i + 1);
              break;
          }
          
          break;
        default: if (ch < 0x20) {
            if (ch == 9 || ch == 0xa || ch == 0xd) {
 continue; 
}

          }
           else if (ch < 0xd800) {  
            continue;
          }
           else if (ch < 0xe000) {  
            if (Character.isHighSurrogate(ch) && i+1 < end && Character.isLowSurrogate(jsonish.charAt(i+1))) { ++i;  
              continue;
            }
            
          }
           else if (ch <= 0xfffd) {  
            continue;
          }
          
          replace(i, i + 1, "\\u");
          for (int j = 4; --j >= 0;) {
            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);
          }
          
          break;
      }
      
    }
    
    if (!closed) {
 insert(end, '"'); 
}

  }
  
  private State requireValueState(int pos, State state, boolean canBeKey) throws UnbracketedComma {
    switch (state) {
      case START_MAP: case BEFORE_KEY:
        if (canBeKey) {
          return State.AFTER_KEY;
        }
         else {
          insert(pos, "\"\":");
          return State.AFTER_VALUE;
        }
        
      case AFTER_KEY:
        insert(pos, ':');
        return State.AFTER_VALUE;
      case BEFORE_VALUE:
        return State.AFTER_VALUE;
      case AFTER_VALUE:
        if (canBeKey) {
          insert(pos, ',');
          return State.AFTER_KEY;
        }
         else {
          insert(pos, ",\"\":");
          return State.AFTER_VALUE;
        }
        
      case START_ARRAY: case BEFORE_ELEMENT:
        return State.AFTER_ELEMENT;
      case AFTER_ELEMENT:
        if (bracketDepth == 0) {
 throw UNBRACKETED_COMMA; 
}

        insert(pos, ',');
        return State.AFTER_ELEMENT;
    }
    
    throw new AssertionError();
  }
  
  private void insert(int pos, char ch) {
    replace(pos, pos, ch);
  }
  
  private void insert(int pos, String s) {
    replace(pos, pos, s);
  }
  
  private void elide(int start, int end) {
    if (sanitizedJson == null) {
      sanitizedJson = new StringBuilder(jsonish.length() + 16);
    }
    
    sanitizedJson.append(jsonish, cleaned, start);
    cleaned = end;
  }
  
  private void replace(int start, int end, char ch) {
    elide(start, end);
    sanitizedJson.append(ch);
  }
  
  private void replace(int start, int end, String s) {
    elide(start, end);
    sanitizedJson.append(s);
  }
  
  private static int endOfQuotedString(String s, int start) {
    char quote = s.charAt(start);
    for (int i = start; (i = s.indexOf(quote, i + 1)) >= 0;) {
      int slashRunStart = i;
      while (slashRunStart > start && s.charAt(slashRunStart - 1) == '\\') { --slashRunStart;
      }
      
      if (((i - slashRunStart) & 1) == 0) {
        return i + 1;
      }
      
    }
    
    return s.length();
  }
  
  private void elideTrailingComma(int closeBracketPos) {
    for (int i = closeBracketPos; --i >= cleaned;) {
      switch (jsonish.charAt(i)) {
        case '\t': case '\n': case '\r': case ' ':
          continue;
        case ',':
          elide(i, i+1);
          return;
        default: throw new AssertionError("" + jsonish.charAt(i));
      }
      
    }
    
    assert sanitizedJson != null;
    for (int i = sanitizedJson.length(); --i >= 0;) {
      switch (sanitizedJson.charAt(i)) {
        case '\t': case '\n': case '\r': case ' ':
          continue;
        case ',':
          sanitizedJson.setLength(i);
          return;
        default: throw new AssertionError("" + sanitizedJson.charAt(i));
      }
      
    }
    
    throw new AssertionError( "Trailing comma not found in " + jsonish + " or " + sanitizedJson);
  }
  
  private void normalizeNumber(int start, int end) {
    int pos = start;
    if (pos < end) {
      switch (jsonish.charAt(pos)) {
        case '+':
          elide(pos, pos + 1); ++pos;
          break;
        case '-': ++pos;
          break;
        default: break;
      }
      
    }
    
    int intEnd = endOfDigitRun(pos, end);
    if (pos == intEnd) {  
      insert(pos, '0');
    }
     else if ('0' == jsonish.charAt(pos)) {
      boolean reencoded = false;
      long value = 0;
      if (intEnd - pos == 1 && intEnd < end && 'x' == (jsonish.charAt(intEnd) | 32)) {  
        for (intEnd = intEnd + 1; intEnd < end; ++intEnd) {
          char ch = jsonish.charAt(intEnd);
          int digVal;
          if ('0' <= ch && ch <= '9') {
            digVal = ch - '0';
          }
           else {
            ch |= 32;
            if ('a' <= ch && ch <= 'f') {
              digVal = ch - ('a' - 10);
            }
             else {
              break;
            }
            
          }
          
          value = (value << 4) | digVal;
        }
        
        reencoded = true;
      }
       else if (intEnd - pos > 1) {  
        for (int i = pos; i < intEnd; ++i) {
          int digVal = jsonish.charAt(i) - '0';
          if (digVal < 0) {
            break;
          }
          
          value = (value << 3) | digVal;
        }
        
        reencoded = true;
      }
      
      if (reencoded) {
        elide(pos, intEnd);
        if (value < 0) {
          int lastIndex = sanitizedJson.length() - 1;
          if (lastIndex >= 0) {
            char last = sanitizedJson.charAt(lastIndex);
            if (last == '-' || last == '+') {
              elide(lastIndex, lastIndex + 1);
              if (last == '-') {
                value = -value;
              }
              
            }
            
          }
          
        }
        
        sanitizedJson.append(value);
      }
      
    }
    
    pos = intEnd;
    if (pos < end && jsonish.charAt(pos) == '.') { ++pos;
      int fractionEnd = endOfDigitRun(pos, end);
      if (fractionEnd == pos) {
        insert(pos, '0');
      }
      
      pos = fractionEnd;
    }
    
    if (pos < end && 'e' == (jsonish.charAt(pos) | 32)) { ++pos;
      if (pos < end) {
        switch (jsonish.charAt(pos)) {
          case '+': case '-': ++pos; break;
          default: break;
        }
        
      }
      
      int expEnd = endOfDigitRun(pos, end);
      if (expEnd == pos) {
        insert(pos, '0');
      }
      
      pos = expEnd;
    }
    
    if (pos != end) {
      elide(pos, end);
    }
    
  }
  
  private boolean canonicalizeNumber(int start, int end) {
    elide(start, start);
    int sanStart = sanitizedJson.length();
    normalizeNumber(start, end);
    elide(end, end);
    int sanEnd = sanitizedJson.length();
    return canonicalizeNumber(sanitizedJson, sanStart, sanEnd);
  }
  
  private static boolean canonicalizeNumber( StringBuilder sanitizedJson, int sanStart, int sanEnd) {
    int intStart, intEnd, fractionStart, fractionEnd, expStart, expEnd;
    intStart = sanStart + (sanitizedJson.charAt(sanStart) == '-' ? 1 : 0);
    for (intEnd = intStart; intEnd < sanEnd; ++intEnd) {
      char ch = sanitizedJson.charAt(intEnd);
      if (!('0' <= ch && ch <= '9')) {
 break; 
}

    }
    
    if (intEnd == sanEnd || '.' != sanitizedJson.charAt(intEnd)) {
      fractionStart = fractionEnd = intEnd;
    }
     else {
      fractionStart = intEnd + 1;
      for (fractionEnd = fractionStart; fractionEnd < sanEnd; ++fractionEnd) {
        char ch = sanitizedJson.charAt(fractionEnd);
        if (!('0' <= ch && ch <= '9')) {
 break; 
}

      }
      
    }
    
    if (fractionEnd == sanEnd) {
      expStart = expEnd = sanEnd;
    }
     else {
      assert 'e' == (sanitizedJson.charAt(fractionEnd) | 32);
      expStart = fractionEnd + 1;
      if (sanitizedJson.charAt(expStart) == '+') {
 ++expStart; 
}

      expEnd = sanEnd;
    }
    
    assert intStart      <= intEnd && intEnd        <= fractionStart && fractionStart <= fractionEnd && fractionEnd   <= expStart && expStart      <= expEnd;
    int exp;
    if (expEnd == expStart) {
      exp = 0;
    }
     else {
      try {
        exp = Integer.parseInt(sanitizedJson.substring(expStart, expEnd), 10);
      }
       catch (@SuppressWarnings("unused") NumberFormatException ex) {
        return false;
      }
      
    }
    
    int n = exp;  
    boolean sawDecimal = false;
    boolean zero = true;
    int digitOutPos = intStart;
    for (int i = intStart, nZeroesPending = 0; i < fractionEnd; ++i) {
      char ch = sanitizedJson.charAt(i);
      if (ch == '.') {
        sawDecimal = true;
        if (zero) {
 nZeroesPending = 0; 
}

        continue;
      }
      
      char digit = ch;
      if ((!zero || digit != '0') && !sawDecimal) {
 ++n; 
}

      if (digit == '0') { ++nZeroesPending;
      }
       else {
        if (zero) {  
          if (sawDecimal) {
            n -= nZeroesPending;
          }
          
          nZeroesPending = 0;
        }
        
        zero = false;
        while (nZeroesPending != 0 || digit != 0) {
          char vdigit;
          if (nZeroesPending == 0) {
            vdigit = digit;
            digit = (char) 0;
          }
           else {
            vdigit = '0'; --nZeroesPending;
          }
          
          sanitizedJson.setCharAt(digitOutPos++, vdigit);
        }
        
      }
      
    }
    
    sanitizedJson.setLength(digitOutPos);
    int k = digitOutPos - intStart;
    if (zero) {  
      sanitizedJson.setLength(sanStart);  
      sanitizedJson.append('0');
      return true;
    }
    
    if (k <= n && n <= 21) {
      for (int i = k; i < n; ++i) {
        sanitizedJson.append('0');
      }
      
    }
     else if (0 < n && n <= 21) {
      sanitizedJson.insert(intStart + n, '.');
    }
     else if (-6 < n && n <= 0) {
      sanitizedJson.insert(intStart, "0.000000".substring(0, 2 - n));
    }
     else {
      if (k == 1) {
      }
       else {
        sanitizedJson.insert(intStart + 1, '.');
      }
      
      int nLess1 = n-1;
      sanitizedJson.append('e').append(nLess1 < 0 ? '-' : '+') .append(Math.abs(nLess1));
    }
    
    return true;
  }
  
  private boolean isKeyword(int start, int end) {
    int n = end - start;
    if (n == 5) {
      return "false".regionMatches(0, jsonish, start, n);
    }
     else if (n == 4) {
      return "null".regionMatches(0, jsonish, start, n) || "true".regionMatches(0, jsonish, start, n);
    }
    
    return false;
  }
  
  private boolean isOctAt(int i) {
    char ch = jsonish.charAt(i);
    return '0' <= ch && ch <= '7';
  }
  
  private boolean isHexAt(int i) {
    char ch = jsonish.charAt(i);
    if ('0' <= ch && ch <= '9') {
 return true; 
}

    ch |= 32;
    return 'a' <= ch && ch <= 'f';
  }
  
  private boolean isJsonSpecialChar(int i) {
    char ch = jsonish.charAt(i);
    if (ch <= ' ') {
 return true; 
}

    switch (ch) {
      case '"':
      case ',': case ':':
      case '[': case ']':
      case '{': case '}':
        return true;
      default: return false;
    }
    
  }
  
  private void appendHex(int n, int nDigits) {
    for (int i = 0, x = n; i < nDigits; ++i, x >>>= 4) {
      int dig = x & 0xf;
      sanitizedJson.append(dig + (dig < 10 ? '0' : (char) ('a' - 10)));
    }
    
  }
  
  private static final class UnbracketedComma extends Exception {
    private static final long serialVersionUID = 783239978717247850L;
  }
  
  private int endOfDigitRun(int start, int limit) {
    for (int end = start; end < limit; ++end) {
      char ch = jsonish.charAt(end);
      if (!('0' <= ch && ch <= '9')) {
 return end; 
}

    }
    
    return limit;
  }
  
  private static final UnbracketedComma UNBRACKETED_COMMA = new UnbracketedComma();
  static {
    UNBRACKETED_COMMA.setStackTrace(new StackTraceElement[0]);
  }
  
  CharSequence toCharSequence() {
    return sanitizedJson != null ? sanitizedJson : jsonish;
  }
  
  public String toString() {
    return sanitizedJson != null ? sanitizedJson.toString() : jsonish;
  }
  
  private static final char[] HEX_DIGITS = new char[] {     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', };
}



package com.linecorp.armeria.internal.common;
import static io.netty.util.internal.StringUtil.decodeHexNibble;
import static java.util.Objects.requireNonNull;
import java.util.BitSet;
import java.util.Objects;
import java.util.Set;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.annotations.VisibleForTesting;
import com.linecorp.armeria.common.Flags;
import com.linecorp.armeria.common.annotation.Nullable;
import com.linecorp.armeria.common.metric.MeterIdPrefix;
import com.linecorp.armeria.internal.common.metric.CaffeineMetricSupport;
import io.micrometer.core.instrument.MeterRegistry;
import it.unimi.dsi.fastutil.Arrays;
import it.unimi.dsi.fastutil.bytes.ByteArrays;
public final class PathAndQuery {
    private static final PathAndQuery ROOT_PATH_QUERY = new PathAndQuery("/", null);
    private static final BitSet ALLOWED_PATH_CHARS = new BitSet();
    private static final BitSet ALLOWED_QUERY_CHARS = new BitSet();
    private static final int PERCENT_ENCODING_MARKER = 0xFF;
    private static final byte[] RAW_CHAR_TO_MARKER = new byte[256];
    private static final String[] MARKER_TO_PERCENT_ENCODED_CHAR = new String[256];
    static {
        final String allowedPathChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=";
        for (int i = 0; i < allowedPathChars.length(); i++) {
            ALLOWED_PATH_CHARS.set(allowedPathChars.charAt(i));
        }
        
        final String allowedQueryChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*,;=";
        for (int i = 0; i < allowedQueryChars.length(); i++) {
            ALLOWED_QUERY_CHARS.set(allowedQueryChars.charAt(i));
        }
        
        for (final ReservedChar reservedChar : ReservedChar.values()) {
            RAW_CHAR_TO_MARKER[reservedChar.rawChar] = reservedChar.marker;
            MARKER_TO_PERCENT_ENCODED_CHAR[reservedChar.marker] = reservedChar.percentEncodedChar;
        }
        
    }
    
    private static final Bytes EMPTY_QUERY = new Bytes(0);
    private static final Bytes ROOT_PATH = new Bytes(new byte[] { '/' });
    private static final Cache<String, PathAndQuery> CACHE = Flags.parsedPathCacheSpec() != null ? buildCache(Flags.parsedPathCacheSpec()) : null;
    private static Cache<String, PathAndQuery> buildCache(String spec) {
        return Caffeine.from(spec).build();
    }
    
    public static void registerMetrics(MeterRegistry registry, MeterIdPrefix idPrefix) {
        if (CACHE != null) {
            CaffeineMetricSupport.setup(registry, idPrefix, CACHE);
        }
        
    }
    
    public static void clearCachedPaths() {
        requireNonNull(CACHE, "CACHE");
        CACHE.asMap().clear();
    }
    
    public static Set<String> cachedPaths() {
        requireNonNull(CACHE, "CACHE");
        return CACHE.asMap().keySet();
    }
    
    public static PathAndQuery parse(@Nullable String rawPath) {
        if (CACHE != null && rawPath != null) {
            final PathAndQuery parsed = CACHE.getIfPresent(rawPath);
            if (parsed != null) {
                return parsed;
            }
            
        }
        
        return splitPathAndQuery(rawPath);
    }
    
    public void storeInCache(@Nullable String rawPath) {
        if (CACHE != null && !cached && rawPath != null) {
            cached = true;
            CACHE.put(rawPath, this);
        }
        
    }
    
    private final String path;
    private final String query;
    private boolean cached;
    private PathAndQuery(String path, @Nullable String query) {
        this.path = path;
        this.query = query;
    }
    
    public String path() {
        return path;
    }
    
    public String query() {
        return query;
    }
    
    public boolean equals(@Nullable Object o) {
        if (this == o) {
            return true;
        }
        
        if (!(o instanceof PathAndQuery)) {
            return false;
        }
        
        final PathAndQuery that = (PathAndQuery) o;
        return Objects.equals(path, that.path) && Objects.equals(query, that.query);
    }
    
    public int hashCode() {
        return Objects.hash(path, query);
    }
    
    public String toString() {
        if (query == null) {
            return path;
        }
        
        return path + "?" + query;
    }
    
    private static PathAndQuery splitPathAndQuery(@Nullable final String pathAndQuery) {
        final Bytes path;
        final Bytes query;
        if (pathAndQuery == null) {
            return ROOT_PATH_QUERY;
        }
        
        final int queryPos = pathAndQuery.indexOf('?');
        if (queryPos >= 0) {
            if ((path = decodePercentsAndEncodeToUtf8( pathAndQuery, 0, queryPos, true)) == null) {
                return null;
            }
            
            if ((query = decodePercentsAndEncodeToUtf8( pathAndQuery, queryPos + 1, pathAndQuery.length(), false)) == null) {
                return null;
            }
            
        }
         else {
            if ((path = decodePercentsAndEncodeToUtf8( pathAndQuery, 0, pathAndQuery.length(), true)) == null) {
                return null;
            }
            
            query = null;
        }
        
        if (path.data[0] != '/') {
            return null;
        }
        
        if (pathContainsDoubleDots(path)) {
            return null;
        }
        
        return new PathAndQuery(encodeToPercents(path, true), query != null ? encodeToPercents(query, false) : null);
    }
    
    private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int end, boolean isPath) {
        final int length = end - start;
        if (length == 0) {
            return isPath ? ROOT_PATH : EMPTY_QUERY;
        }
        
        final Bytes buf = new Bytes(Math.max(length * 3 / 2, 4));
        boolean wasSlash = false;
        for (final CodePointIterator i = new CodePointIterator(value, start, end); i.hasNextCodePoint();) {             final int pos = i.position();
            final int cp = i.nextCodePoint();
            if (cp == '%') {
                final int hexEnd = pos + 3;
                if (hexEnd > end) {
                    return null;
                }
                
                final int digit1 = decodeHexNibble(value.charAt(pos + 1));
                final int digit2 = decodeHexNibble(value.charAt(pos + 2));
                if (digit1 < 0 || digit2 < 0) {
                    return null;
                }
                
                final int decoded = (digit1 << 4) | digit2;
                if (isPath) {
                    if (decoded == '/') {
                        final byte marker = RAW_CHAR_TO_MARKER['/'];
                        buf.ensure(2);
                        buf.add((byte) PERCENT_ENCODING_MARKER);
                        buf.add(marker);
                        wasSlash = false;
                    }
                     else {
                        if (appendOneByte(buf, decoded, wasSlash, isPath)) {
                            wasSlash = false;
                        }
                         else {
                            return null;
                        }
                        
                    }
                    
                }
                 else {
                    final byte marker = RAW_CHAR_TO_MARKER[decoded];
                    if (marker != 0) {
                        buf.ensure(2);
                        buf.add((byte) PERCENT_ENCODING_MARKER);
                        buf.add(marker);
                        wasSlash = false;
                    }
                     else if (appendOneByte(buf, decoded, wasSlash, isPath)) {
                        wasSlash = decoded == '/';
                    }
                     else {
                        return null;
                    }
                    
                }
                
                i.position(hexEnd);
                continue;
            }
            
            if (cp == '+' && !isPath) {
                buf.ensure(1);
                buf.add((byte) ' ');
                wasSlash = false;
                continue;
            }
            
            if (cp <= 0x7F) {
                if (!appendOneByte(buf, cp, wasSlash, isPath)) {
                    return null;
                }
                
                wasSlash = cp == '/';
                continue;
            }
            
            if (cp <= 0x7ff) {
                buf.ensure(2);
                buf.add((byte) ((cp >>> 6) | 0b110_00000));
                buf.add((byte) (cp & 0b111111 | 0b10_000000));
            }
             else if (cp <= 0xffff) {
                buf.ensure(3);
                buf.add((byte) ((cp >>> 12) | 0b1110_0000));
                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.add((byte) ((cp & 0b111111) | 0b10_000000));
            }
             else if (cp <= 0x1fffff) {
                buf.ensure(4);
                buf.add((byte) ((cp >>> 18) | 0b11110_000));
                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.add((byte) ((cp & 0b111111) | 0b10_000000));
            }
             else if (cp <= 0x3ffffff) {
                buf.ensure(5);
                buf.add((byte) ((cp >>> 24) | 0b111110_00));
                buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));
                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.add((byte) ((cp & 0b111111) | 0b10_000000));
            }
             else {
                buf.ensure(6);
                buf.add((byte) ((cp >>> 30) | 0b1111110_0));
                buf.add((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));
                buf.add((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));
                buf.add((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
                buf.add((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.add((byte) ((cp & 0b111111) | 0b10_000000));
            }
            
            wasSlash = false;
        }
        
        return buf;
    }
    
    private static boolean appendOneByte(Bytes buf, int cp, boolean wasSlash, boolean isPath) {
        if (cp == 0x7F) {
            return false;
        }
        
        if (cp >>> 5 == 0) {
            if (isPath) {
                return false;
            }
             else if (cp != 0x0A && cp != 0x0D && cp != 0x09) {
                return false;
            }
            
        }
        
        if (cp == '/' && isPath) {
            if (!wasSlash) {
                buf.ensure(1);
                buf.add((byte) '/');
            }
             else {
            }
            
        }
         else {
            buf.ensure(1);
            buf.add((byte) cp);
        }
        
        return true;
    }
    
    private static boolean pathContainsDoubleDots(Bytes path) {
        final int length = path.length;
        byte b0 = 0;
        byte b1 = 0;
        byte b2 = '/';
        for (int i = 1; i < length; i++) {
            final byte b3 = path.data[i];
            if (b3 == '/' && b2 == '.' && b1 == '.' && b0 == '/') {
                return true;
            }
            
            b0 = b1;
            b1 = b2;
            b2 = b3;
        }
        
        return b0 == '/' && b1 == '.' && b2 == '.';
    }
    
    private static String encodeToPercents(Bytes value, boolean isPath) {
        final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;
        final int length = value.length;
        boolean needsEncoding = false;
        for (int i = 0; i < length; i++) {
            if (!allowedChars.get(value.data[i] & 0xFF)) {
                needsEncoding = true;
                break;
            }
            
        }
        
        if (!needsEncoding) {
            return new String(value.data, 0, 0, length);
        }
        
        final StringBuilder buf = new StringBuilder(length);
        for (int i = 0; i < length; i++) {
            final int b = value.data[i] & 0xFF;
            if (b == PERCENT_ENCODING_MARKER && (i + 1) < length) {
                final int marker = value.data[i + 1] & 0xFF;
                final String percentEncodedChar = MARKER_TO_PERCENT_ENCODED_CHAR[marker];
                if (percentEncodedChar != null) {
                    buf.append(percentEncodedChar);
                    i++;
                    continue;
                }
                
            }
            
            if (allowedChars.get(b)) {
                buf.append((char) b);
            }
             else if (b == ' ') {
                if (isPath) {
                    buf.append("%20");
                }
                 else {
                    buf.append('+');
                }
                
            }
             else {
                buf.append('%');
                appendHexNibble(buf, b >>> 4);
                appendHexNibble(buf, b & 0xF);
            }
            
        }
        
        return buf.toString();
    }
    
    private static void appendHexNibble(StringBuilder buf, int nibble) {
        if (nibble < 10) {
            buf.append((char) ('0' + nibble));
        }
         else {
            buf.append((char) ('A' + nibble - 10));
        }
        
    }
    
    private static final class Bytes {
        byte[] data;
        int length;
        Bytes(int initialCapacity) {
            data = new byte[initialCapacity];
        }
        
        Bytes(byte[] data) {
            this.data = data;
            length = data.length;
        }
        
        void add(byte b) {
            data[length++] = b;
        }
        
        void ensure(int numBytes) {
            int newCapacity = length + numBytes;
            if (newCapacity <= data.length) {
                return;
            }
            
            newCapacity = (int) Math.max(Math.min((long) data.length + (data.length >> 1), Arrays.MAX_ARRAY_SIZE), newCapacity);
            data = ByteArrays.forceCapacity(data, newCapacity, length);
        }
        
    }
    
    private static final class CodePointIterator {
        private final CharSequence str;
        private final int end;
        private int pos;
        CodePointIterator(CharSequence str, int start, int end) {
            this.str = str;
            this.end = end;
            pos = start;
        }
        
        int position() {
            return pos;
        }
        
        void position(int pos) {
            this.pos = pos;
        }
        
        boolean hasNextCodePoint() {
            return pos < end;
        }
        
        int nextCodePoint() {
            assert pos < end;
            final char c1 = str.charAt(pos++);
            if (Character.isHighSurrogate(c1) && pos < end) {
                final char c2 = str.charAt(pos);
                if (Character.isLowSurrogate(c2)) {
                    pos++;
                    return Character.toCodePoint(c1, c2);
                }
                
            }
            
            return c1;
        }
        
    }
    
    private enum ReservedChar {
        GEN_DELIM_01(':', "%3A", (byte) 0x01), GEN_DELIM_02('/', "%2F", (byte) 0x02), GEN_DELIM_03('?', "%3F", (byte) 0x03), GEN_DELIM_04('#', "%23", (byte) 0x04), GEN_DELIM_05('[', "%5B", (byte) 0x05), GEN_DELIM_06(']', "%5D", (byte) 0x06), GEN_DELIM_07('@', "%40", (byte) 0x07), SUB_DELIM_01('!', "%21", (byte) 0x11), SUB_DELIM_02('$', "%24", (byte) 0x12), SUB_DELIM_03('&', "%26", (byte) 0x13), SUB_DELIM_04('\'', "%27", (byte) 0x14), SUB_DELIM_05('(', "%28", (byte) 0x15), SUB_DELIM_06(')', "%29", (byte) 0x16), SUB_DELIM_07('*', "%2A", (byte) 0x17), SUB_DELIM_08('+', "%2B", (byte) 0x18), SUB_DELIM_09(',', "%2C", (byte) 0x19), SUB_DELIM_10(';', "%3B", (byte) 0x1A), SUB_DELIM_11('=', "%3D", (byte) 0x1B);
        private final int rawChar;
        private final String percentEncodedChar;
        private final byte marker;
        ReservedChar(int rawChar, String percentEncodedChar, byte marker) {
            this.rawChar = rawChar;
            this.percentEncodedChar = percentEncodedChar;
            this.marker = marker;
        }
        
    }
    
}



package org.xerial.snappy;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.Properties;
public class Snappy {
    static {
        init();
    }
    
    private static SnappyApi impl;
    public static void cleanUp() {
        SnappyLoader.cleanUpExtractedNativeLib();
        SnappyLoader.setSnappyApi(null);
    }
    
    static void init() {
        try {
            impl = SnappyLoader.loadSnappyApi();
        }
        
        catch (Exception e) {
            throw new ExceptionInInitializerError(e);
        }
        
    }
    
    public static void arrayCopy(Object src, int offset, int byteLength, Object dest, int dest_offset) throws IOException {
        impl.arrayCopy(src, offset, byteLength, dest, dest_offset);
    }
    
    public static byte[] compress(byte[] input) throws IOException {
        return rawCompress(input, input.length);
    }
    
    public static int compress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset) throws IOException {
        return rawCompress(input, inputOffset, inputLength, output, outputOffset);
    }
    
    public static int compress(ByteBuffer uncompressed, ByteBuffer compressed) throws IOException {
        if (!uncompressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer");
        }
        
        if (!compressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "destination is not a direct buffer");
        }
        
        int uPos = uncompressed.position();
        int uLen = uncompressed.remaining();
        int cPos = compressed.position();
        int compressedSize = impl.rawCompress(uncompressed, uPos, uLen, compressed, cPos);
        ((Buffer) compressed).limit(cPos + compressedSize);
        return compressedSize;
    }
    
    public static byte[] compress(char[] input) throws IOException {
        return rawCompress(input, input.length * 2); 
    }
    
    public static byte[] compress(double[] input) throws IOException {
        return rawCompress(input, input.length * 8); 
    }
    
    public static byte[] compress(float[] input) throws IOException {
        return rawCompress(input, input.length * 4); 
    }
    
    public static byte[] compress(int[] input) throws IOException {
        return rawCompress(input, input.length * 4); 
    }
    
    public static byte[] compress(long[] input) throws IOException {
        return rawCompress(input, input.length * 8); 
    }
    
    public static byte[] compress(short[] input) throws IOException {
        return rawCompress(input, input.length * 2); 
    }
    
    public static byte[] compress(String s) throws IOException {
        try {
            return compress(s, "UTF-8");
        }
        
        catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("UTF-8 encoder is not found");
        }
        
    }
    
    public static byte[] compress(String s, String encoding) throws UnsupportedEncodingException, IOException {
        byte[] data = s.getBytes(encoding);
        return compress(data);
    }
    
    public static byte[] compress(String s, Charset encoding) throws IOException {
        byte[] data = s.getBytes(encoding);
        return compress(data);
    }
    
    public static String getNativeLibraryVersion() {
        URL versionFile = SnappyLoader.class.getResource("/org/xerial/snappy/VERSION");
        String version = "unknown";
        try {
            if (versionFile != null) {
                InputStream in = null;
                try {
                    Properties versionData = new Properties();
                    in = versionFile.openStream();
                    versionData.load(in);
                    version = versionData.getProperty("version", version);
                    if (version.equals("unknown")) {
                        version = versionData.getProperty("SNAPPY_VERSION", version);
                    }
                    
                    version = version.trim().replaceAll("[^0-9\\.]", "");
                }
                
                finally {
                    if(in != null) {
                        in.close();
                    }
                    
                }
                
            }
            
        }
        
        catch (IOException e) {
            e.printStackTrace();
        }
        
        return version;
    }
    
    public static boolean isValidCompressedBuffer(byte[] input, int offset, int length) throws IOException {
        if (input == null) {
            throw new NullPointerException("input is null");
        }
        
        return impl.isValidCompressedBuffer(input, offset, length);
    }
    
    public static boolean isValidCompressedBuffer(byte[] input) throws IOException {
        return isValidCompressedBuffer(input, 0, input.length);
    }
    
    public static boolean isValidCompressedBuffer(ByteBuffer compressed) throws IOException {
        return impl.isValidCompressedBuffer(compressed, compressed.position(), compressed.remaining());
    }
    
    public static boolean isValidCompressedBuffer(long inputAddr, long offset, long length) throws IOException {
        return impl.isValidCompressedBuffer(inputAddr, offset, length);
    }
    
    public static int maxCompressedLength(int byteSize) {
        return impl.maxCompressedLength(byteSize);
    }
    
    public static long rawCompress(long inputAddr, long inputSize, long destAddr) throws IOException {
        return impl.rawCompress(inputAddr, inputSize, destAddr);
    }
    
    public static long rawUncompress(long inputAddr, long inputSize, long destAddr) throws IOException {
        return impl.rawUncompress(inputAddr, inputSize, destAddr);
    }
    
    public static byte[] rawCompress(Object data, int byteSize) throws IOException {
        byte[] buf = new byte[Snappy.maxCompressedLength(byteSize)];
        int compressedByteSize = impl.rawCompress(data, 0, byteSize, buf, 0);
        byte[] result = new byte[compressedByteSize];
        System.arraycopy(buf, 0, result, 0, compressedByteSize);
        return result;
    }
    
    public static int rawCompress(Object input, int inputOffset, int inputLength, byte[] output, int outputOffset) throws IOException {
        if (input == null || output == null) {
            throw new NullPointerException("input or output is null");
        }
        
        int compressedSize = impl .rawCompress(input, inputOffset, inputLength, output, outputOffset);
        return compressedSize;
    }
    
    public static int rawUncompress(byte[] input, int inputOffset, int inputLength, Object output, int outputOffset) throws IOException {
        if (input == null || output == null) {
            throw new NullPointerException("input or output is null");
        }
        
        return impl.rawUncompress(input, inputOffset, inputLength, output, outputOffset);
    }
    
    public static byte[] uncompress(byte[] input) throws IOException {
        byte[] result = new byte[Snappy.uncompressedLength(input)];
        Snappy.uncompress(input, 0, input.length, result, 0);
        return result;
    }
    
    public static int uncompress(byte[] input, int inputOffset, int inputLength, byte[] output, int outputOffset) throws IOException {
        return rawUncompress(input, inputOffset, inputLength, output, outputOffset);
    }
    
    public static int uncompress(ByteBuffer compressed, ByteBuffer uncompressed) throws IOException {
        if (!compressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer");
        }
        
        if (!uncompressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "destination is not a direct buffer");
        }
        
        int cPos = compressed.position();
        int cLen = compressed.remaining();
        int uPos = uncompressed.position();
        int decompressedSize = impl.rawUncompress(compressed, cPos, cLen, uncompressed, uPos);
        uncompressed.limit(uPos + decompressedSize);
        return decompressedSize;
    }
    
    public static char[] uncompressCharArray(byte[] input) throws IOException {
        return uncompressCharArray(input, 0, input.length);
    }
    
    public static char[] uncompressCharArray(byte[] input, int offset, int length) throws IOException {
        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);
        char[] result = new char[uncompressedLength / 2];
        impl.rawUncompress(input, offset, length, result, 0);
        return result;
    }
    
    public static double[] uncompressDoubleArray(byte[] input) throws IOException {
        return uncompressDoubleArray(input, 0, input.length);
    }
    
    public static double[] uncompressDoubleArray(byte[] input, int offset, int length) throws IOException {
        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);
        double[] result = new double[uncompressedLength / 8];
        impl.rawUncompress(input, offset, length, result, 0);
        return result;
    }
    
    public static int uncompressedLength(byte[] input) throws IOException {
        return impl.uncompressedLength(input, 0, input.length);
    }
    
    public static int uncompressedLength(byte[] input, int offset, int length) throws IOException {
        if (input == null) {
            throw new NullPointerException("input is null");
        }
        
        return impl.uncompressedLength(input, offset, length);
    }
    
    public static int uncompressedLength(ByteBuffer compressed) throws IOException {
        if (!compressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, "input is not a direct buffer");
        }
        
        return impl.uncompressedLength(compressed, compressed.position(), compressed.remaining());
    }
    
    public static long uncompressedLength(long inputAddr, long len) throws IOException {
        return impl.uncompressedLength(inputAddr, len);
    }
    
    public static float[] uncompressFloatArray(byte[] input) throws IOException {
        return uncompressFloatArray(input, 0, input.length);
    }
    
    public static float[] uncompressFloatArray(byte[] input, int offset, int length) throws IOException {
        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);
        float[] result = new float[uncompressedLength / 4];
        impl.rawUncompress(input, offset, length, result, 0);
        return result;
    }
    
    public static int[] uncompressIntArray(byte[] input) throws IOException {
        return uncompressIntArray(input, 0, input.length);
    }
    
    public static int[] uncompressIntArray(byte[] input, int offset, int length) throws IOException {
        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);
        int[] result = new int[uncompressedLength / 4];
        impl.rawUncompress(input, offset, length, result, 0);
        return result;
    }
    
    public static long[] uncompressLongArray(byte[] input) throws IOException {
        return uncompressLongArray(input, 0, input.length);
    }
    
    public static long[] uncompressLongArray(byte[] input, int offset, int length) throws IOException {
        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);
        long[] result = new long[uncompressedLength / 8];
        impl.rawUncompress(input, offset, length, result, 0);
        return result;
    }
    
    public static short[] uncompressShortArray(byte[] input) throws IOException {
        return uncompressShortArray(input, 0, input.length);
    }
    
    public static short[] uncompressShortArray(byte[] input, int offset, int length) throws IOException {
        int uncompressedLength = Snappy.uncompressedLength(input, offset, length);
        short[] result = new short[uncompressedLength / 2];
        impl.rawUncompress(input, offset, length, result, 0);
        return result;
    }
    
    public static String uncompressString(byte[] input) throws IOException {
        try {
            return uncompressString(input, "UTF-8");
        }
        
        catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("UTF-8 decoder is not found");
        }
        
    }
    
    public static String uncompressString(byte[] input, int offset, int length) throws IOException {
        try {
            return uncompressString(input, offset, length, "UTF-8");
        }
        
        catch (UnsupportedEncodingException e) {
            throw new IllegalStateException("UTF-8 decoder is not found");
        }
        
    }
    
    public static String uncompressString(byte[] input, int offset, int length, String encoding) throws IOException, UnsupportedEncodingException {
        byte[] uncompressed = new byte[uncompressedLength(input, offset, length)];
        uncompress(input, offset, length, uncompressed, 0);
        return new String(uncompressed, encoding);
    }
    
    public static String uncompressString(byte[] input, int offset, int length, Charset encoding) throws IOException, UnsupportedEncodingException {
        byte[] uncompressed = new byte[uncompressedLength(input, offset, length)];
        uncompress(input, offset, length, uncompressed, 0);
        return new String(uncompressed, encoding);
    }
    
    public static String uncompressString(byte[] input, String encoding) throws IOException, UnsupportedEncodingException {
        byte[] uncompressed = uncompress(input);
        return new String(uncompressed, encoding);
    }
    
    public static String uncompressString(byte[] input, Charset encoding) throws IOException, UnsupportedEncodingException {
        byte[] uncompressed = uncompress(input);
        return new String(uncompressed, encoding);
    }
    
}



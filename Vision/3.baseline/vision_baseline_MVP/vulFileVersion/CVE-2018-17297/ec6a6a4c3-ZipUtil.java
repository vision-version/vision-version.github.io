package cn.hutool.core.util;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.Enumeration;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;
import java.util.zip.Inflater;
import java.util.zip.InflaterOutputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;
import cn.hutool.core.exceptions.UtilException;
import cn.hutool.core.io.FastByteArrayOutputStream;
import cn.hutool.core.io.FileUtil;
import cn.hutool.core.io.IoUtil;
public class ZipUtil {
	 private static final Charset DEFAULT_CHARSET = CharsetUtil.defaultCharset();
	 public static File zip(String srcPath) throws UtilException {
		return zip(srcPath, DEFAULT_CHARSET);
	}
	
	 public static File zip(String srcPath, Charset charset) throws UtilException {
		return zip(FileUtil.file(srcPath), charset);
	}
	
	 public static File zip(File srcFile) throws UtilException {
		return zip(srcFile, DEFAULT_CHARSET);
	}
	
	 public static File zip(File srcFile, Charset charset) throws UtilException {
		File zipFile = FileUtil.file(srcFile.getParentFile(), FileUtil.mainName(srcFile) + ".zip");
		zip(zipFile, charset, false, srcFile);
		return zipFile;
	}
	
	 public static File zip(String srcPath, String zipPath) throws UtilException {
		return zip(srcPath, zipPath, false);
	}
	
	 public static File zip(String srcPath, String zipPath, boolean withSrcDir) throws UtilException {
		return zip(srcPath, zipPath, DEFAULT_CHARSET, withSrcDir);
	}
	
	 public static File zip(String srcPath, String zipPath, Charset charset, boolean withSrcDir) throws UtilException {
		File srcFile = FileUtil.file(srcPath);
		File zipFile = FileUtil.file(zipPath);
		zip(zipFile, charset, withSrcDir, srcFile);
		return zipFile;
	}
	
	 public static File zip(File zipFile, boolean withSrcDir, File... srcFiles) throws UtilException {
		return zip(zipFile, DEFAULT_CHARSET, withSrcDir, srcFiles);
	}
	
	 public static File zip(File zipFile, Charset charset, boolean withSrcDir, File... srcFiles) throws UtilException {
		validateFiles(zipFile, srcFiles);
		try (ZipOutputStream out = getZipOutputStream(zipFile, charset)) {
			String srcRootDir;
			for (File srcFile : srcFiles) {
				 srcRootDir = srcFile.getCanonicalPath();
				if (srcFile.isFile() || withSrcDir) {
					srcRootDir = srcFile.getParent();
				}
				
				 zip(srcFile, srcRootDir, out);
				out.flush();
			}
			
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		
		return zipFile;
	}
	
	 public static File zip(File zipFile, String path, String data) throws UtilException {
		return zip(zipFile, path, data, DEFAULT_CHARSET);
	}
	
	 public static File zip(File zipFile, String path, String data, Charset charset) throws UtilException {
		return zip(zipFile, path, IoUtil.toStream(data, charset), charset);
	}
	
	 public static File zip(File zipFile, String path, InputStream in) throws UtilException {
		return zip(zipFile, path, in, DEFAULT_CHARSET);
	}
	
	 public static File zip(File zipFile, String path, InputStream in, Charset charset) throws UtilException {
		return zip(zipFile, new String[] { path }, new InputStream[] { in }, charset);
	}
	
	 public static File zip(File zipFile, String[] paths, InputStream[] ins) throws UtilException {
		return zip(zipFile, paths, ins, DEFAULT_CHARSET);
	}
	
	 public static File zip(File zipFile, String[] paths, InputStream[] ins, Charset charset) throws UtilException {
		if (ArrayUtil.isEmpty(paths) || ArrayUtil.isEmpty(ins)) {
			throw new IllegalArgumentException("Paths or ins is empty !");
		}
		
		if (paths.length != ins.length) {
			throw new IllegalArgumentException("Paths length is not equals to ins length !");
		}
		
		ZipOutputStream out = null;
		try {
			out = getZipOutputStream(zipFile, charset);
			for (int i = 0; i < paths.length; i++) {
				addFile(ins[i], paths[i], out);
			}
			
		}
		 finally {
			IoUtil.close(out);
		}
		
		return zipFile;
	}
	
	 public static File unzip(String zipFilePath) throws UtilException {
		return unzip(zipFilePath, DEFAULT_CHARSET);
	}
	
	 public static File unzip(String zipFilePath, Charset charset) throws UtilException {
		return unzip(FileUtil.file(zipFilePath), charset);
	}
	
	 public static File unzip(File zipFile) throws UtilException {
		return unzip(zipFile, DEFAULT_CHARSET);
	}
	
	 public static File unzip(File zipFile, Charset charset) throws UtilException {
		return unzip(zipFile, FileUtil.file(zipFile.getParentFile(), FileUtil.mainName(zipFile)), charset);
	}
	
	 public static File unzip(String zipFilePath, String outFileDir) throws UtilException {
		return unzip(zipFilePath, outFileDir, DEFAULT_CHARSET);
	}
	
	 public static File unzip(String zipFilePath, String outFileDir, Charset charset) throws UtilException {
		return unzip(FileUtil.file(zipFilePath), FileUtil.mkdir(outFileDir), charset);
	}
	
	 public static File unzip(File zipFile, File outFile) throws UtilException {
		return unzip(zipFile, outFile, DEFAULT_CHARSET);
	}
	
	public static File unzip(File zipFile, File outFile, Charset charset) throws UtilException {
		charset = (null == charset) ? DEFAULT_CHARSET : charset;
		ZipFile zipFileObj = null;
		try {
			zipFileObj = new ZipFile(zipFile, charset);
			final Enumeration<ZipEntry> em = (Enumeration<ZipEntry>) zipFileObj.entries();
			ZipEntry zipEntry = null;
			File outItemFile = null;
			while (em.hasMoreElements()) {
				zipEntry = em.nextElement();
				outItemFile = new File(outFile, zipEntry.getName());
				if (zipEntry.isDirectory()) {
					outItemFile.mkdirs();
				}
				 else {
					FileUtil.touch(outItemFile);
					copy(zipFileObj, zipEntry, outItemFile);
				}
				
			}
			
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			IoUtil.close(zipFileObj);
		}
		
		return outFile;
	}
	
	 public static byte[] unzipFileBytes(String zipFilePath, String name) {
		return unzipFileBytes(zipFilePath, DEFAULT_CHARSET, name);
	}
	
	 public static byte[] unzipFileBytes(String zipFilePath, Charset charset, String name) {
		return unzipFileBytes(FileUtil.file(zipFilePath), charset, name);
	}
	
	 public static byte[] unzipFileBytes(File zipFile, String name) {
		return unzipFileBytes(zipFile, DEFAULT_CHARSET, name);
	}
	
	public static byte[] unzipFileBytes(File zipFile, Charset charset, String name) {
		ZipFile zipFileObj = null;
		try {
			zipFileObj = new ZipFile(zipFile, charset);
			final Enumeration<ZipEntry> em = (Enumeration<ZipEntry>) zipFileObj.entries();
			ZipEntry zipEntry = null;
			while (em.hasMoreElements()) {
				zipEntry = em.nextElement();
				if (zipEntry.isDirectory()) {
					continue;
				}
				 else if(name.equals(zipEntry.getName())){
					return IoUtil.readBytes(zipFileObj.getInputStream(zipEntry));
				}
				
			}
			
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			IoUtil.close(zipFileObj);
		}
		
		return null;
	}
	
	 public static byte[] gzip(String content, String charset) throws UtilException {
		return gzip(StrUtil.bytes(content, charset));
	}
	
	 public static byte[] gzip(byte[] val) throws UtilException {
		FastByteArrayOutputStream bos = new FastByteArrayOutputStream(val.length);
		GZIPOutputStream gos = null;
		try {
			gos = new GZIPOutputStream(bos);
			gos.write(val, 0, val.length);
			gos.finish();
			gos.flush();
			val = bos.toByteArray();
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			IoUtil.close(gos);
		}
		
		return val;
	}
	
	 public static byte[] gzip(File file) throws UtilException {
		ByteArrayOutputStream bos = new ByteArrayOutputStream((int) file.length());
		GZIPOutputStream gos = null;
		BufferedInputStream in;
		try {
			gos = new GZIPOutputStream(bos);
			in = FileUtil.getInputStream(file);
			IoUtil.copy(in, gos);
			return bos.toByteArray();
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			IoUtil.close(gos);
		}
		
	}
	
	 public static String unGzip(byte[] buf, String charset) throws UtilException {
		return StrUtil.str(unGzip(buf), charset);
	}
	
	 public static byte[] unGzip(byte[] buf) throws UtilException {
		GZIPInputStream gzi = null;
		ByteArrayOutputStream bos = null;
		try {
			gzi = new GZIPInputStream(new ByteArrayInputStream(buf));
			bos = new ByteArrayOutputStream(buf.length);
			IoUtil.copy(gzi, bos);
			buf = bos.toByteArray();
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			IoUtil.close(gzi);
		}
		
		return buf;
	}
	
	 public static byte[] zlib(String content, String charset, int level) {
		return zlib(StrUtil.bytes(content, charset), level);
	}
	
	 public static byte[] zlib(File file, int level) {
		final ByteArrayOutputStream out = new ByteArrayOutputStream();
		BufferedInputStream in = null;
		try{
			in = FileUtil.getInputStream(file);
			deflater(in, out, level);
		}
		 finally {
			IoUtil.close(in);
		}
		
		return out.toByteArray();
	}
	
	 public static byte[] zlib(byte[] buf, int level) {
		final ByteArrayInputStream in = new ByteArrayInputStream(buf);
		final ByteArrayOutputStream out = new ByteArrayOutputStream(buf.length);
		deflater(in, out, level);
		return out.toByteArray();
	}
	
	 public static String unZlib(byte[] buf, String charset) {
		return StrUtil.str(unZlib(buf), charset);
	}
	
	 public static byte[] unZlib(byte[] buf) {
		final ByteArrayInputStream in = new ByteArrayInputStream(buf);
		final ByteArrayOutputStream out = new ByteArrayOutputStream(buf.length);
		inflater(in, out);
		return out.toByteArray();
	}
	
	 private static ZipOutputStream getZipOutputStream(File zipFile, Charset charset) {
		return getZipOutputStream(FileUtil.getOutputStream(zipFile), charset);
	}
	
	 private static ZipOutputStream getZipOutputStream(OutputStream out, Charset charset) {
		charset = (null == charset) ? DEFAULT_CHARSET : charset;
		return new ZipOutputStream(out, charset);
	}
	
	 private static void zip(File file, String srcRootDir, ZipOutputStream out) throws UtilException {
		if (file == null) {
			return;
		}
		
		final String subPath = FileUtil.subPath(srcRootDir, file); 
		if (file.isDirectory()) {
			final File[] files = file.listFiles();
			if (ArrayUtil.isEmpty(files) && StrUtil.isNotEmpty(subPath)) {
				 addDir(subPath, out);
			}
			
			 for (File childFile : files) {
				zip(childFile, srcRootDir, out);
			}
			
		}
		 else {
			addFile(file, subPath, out);
		}
		
	}
	
	 private static void addFile(File file, String path, ZipOutputStream out) throws UtilException {
		BufferedInputStream in = null;
		try {
			in = FileUtil.getInputStream(file);
			addFile(in, path, out);
		}
		 finally {
			IoUtil.close(in);
		}
		
	}
	
	 private static void addFile(InputStream in, String path, ZipOutputStream out) throws UtilException {
		if (null == in) {
			return;
		}
		
		try {
			out.putNextEntry(new ZipEntry(path));
			IoUtil.copy(in, out);
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			closeEntry(out);
		}
		
	}
	
	 private static void addDir(String path, ZipOutputStream out) throws UtilException {
		path = StrUtil.addSuffixIfNot(path, StrUtil.SLASH);
		try {
			out.putNextEntry(new ZipEntry(path));
		}
		 catch (IOException e) {
			throw new UtilException(e);
		}
		 finally {
			closeEntry(out);
		}
		
	}
	
	 private static void validateFiles(File zipFile, File... srcFiles) throws UtilException {
		for (File srcFile : srcFiles) {
			if (false == srcFile.exists()) {
				throw new UtilException(StrUtil.format("File [{}] not exist!", srcFile.getAbsolutePath()));
			}
			
			try {
				 if (srcFile.isDirectory() && zipFile.getParent().contains(srcFile.getCanonicalPath())) {
					throw new UtilException("[zipPath] must not be the child directory of [srcPath]!");
				}
				
				if (false == zipFile.exists()) {
					FileUtil.touch(zipFile);
				}
				
			}
			 catch (IOException e) {
				throw new UtilException(e);
			}
			
		}
		
	}
	
	 private static void closeEntry(ZipOutputStream out) {
		try {
			out.closeEntry();
		}
		 catch (IOException e) {
			 }
			 
	}
	
	 private static void copy(ZipFile zipFile, ZipEntry zipEntry, File outItemFile) throws IOException {
		InputStream in = null;
		OutputStream out = null;
		try {
			in = zipFile.getInputStream(zipEntry);
			out = FileUtil.getOutputStream(outItemFile);
			IoUtil.copy(in, out);
		}
		 finally {
			IoUtil.close(out);
			IoUtil.close(in);
		}
		
	}
	
	 private static void inflater(InputStream in, OutputStream out) {
		final InflaterOutputStream ios = (out instanceof InflaterOutputStream) ? (InflaterOutputStream) out : new InflaterOutputStream(out, new Inflater(true));
		IoUtil.copy(in, ios);
	}
	
	 private static void deflater(InputStream in, OutputStream out, int level) {
		final DeflaterOutputStream ios = (out instanceof DeflaterOutputStream) ? (DeflaterOutputStream) out : new DeflaterOutputStream(out, new Deflater(level, true));
		IoUtil.copy(in, ios);
	}
	
	 }
	 

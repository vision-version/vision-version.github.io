commit 60d459cedcf079c6106ae7da2ac562bc32dcabe1
Merge: b64c77360 6ce32ffd1
Author: Tatu Saloranta <tatu.saloranta@iki.fi>
Date:   Thu Apr 13 16:03:24 2017 -0700

    Fix #1599 for 2.8.9
    
    Merge branch '2.7' into 2.8

diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
index ad37dd170..afe24aa1f 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
@@@ -38,7 -39,7 +38,36 @@@ public class BeanDeserializerFactor
      private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };
  
      private final static Class<?>[] NO_VIEWS = new Class<?>[0];
--    
++
++    /**
++     * Set of well-known "nasty classes", deserialization of which is considered dangerous
++     * and should (and is) prevented by default.
++     *
++     * @since 2.8.9
++     */
++    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;
++    static {
++        Set<String> s = new HashSet<>();
++        // Courtesy of [https://github.com/kantega/notsoserial]:
++        // (and wrt [databind#1599]
++        s.add("org.apache.commons.collections.functors.InvokerTransformer");
++        s.add("org.apache.commons.collections.functors.InstantiateTransformer");
++        s.add("org.apache.commons.collections4.functors.InvokerTransformer");
++        s.add("org.apache.commons.collections4.functors.InstantiateTransformer");
++        s.add("org.codehaus.groovy.runtime.ConvertedClosure");
++        s.add("org.codehaus.groovy.runtime.MethodClosure");
++        s.add("org.springframework.beans.factory.ObjectFactory");
++        s.add("com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl");
++        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);
++    }
++
++    /**
++     * Set of class names of types that are never to be deserialized.
++     *
++     * @since 2.8.9
++     */
++    protected Set<String> _cfgIllegalClassNames = DEFAULT_NO_DESER_CLASS_NAMES;
++
      /*
      /**********************************************************
      /* Life-cycle
@@@ -839,20 -831,30 +870,37 @@@ beanDesc.getBeanClass().getName(), name
          if (status != null) {
              return status.booleanValue();
          }
 -        BeanDescription desc = config.introspectClassAnnotations(type);
 -        status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());
 -        // We default to 'false', i.e. not ignorable
 -        return (status == null) ? false : status.booleanValue(); 
 +        // 21-Apr-2016, tatu: For 2.8, can specify config overrides
 +        ConfigOverride override = config.findConfigOverride(type);
 +        if (override != null) {
 +            status = override.getIsIgnoredType();
 +        }
 +        if (status == null) {
 +            BeanDescription desc = config.introspectClassAnnotations(type);
 +            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());
 +            // We default to 'false', i.e. not ignorable
 +            if (status == null) {
 +                status = Boolean.FALSE;
 +            }
 +        }
 +        ignoredTypes.put(type, status);
 +        return status.booleanValue();
      }
+ 
+     /**
+      * @since 2.8.9
+      */
+     protected void checkIllegalTypes(DeserializationContext ctxt, JavaType type,
+             BeanDescription beanDesc)
+         throws JsonMappingException
+     {
+         // There are certain nasty classes that could cause problems, mostly
+         // via default typing -- catch them here.
 -        Class<?> raw = type.getRawClass();
 -        String name = raw.getSimpleName();
 -
 -        if ("TemplatesImpl".equals(name)) { // [databind#1599] 
 -            if (raw.getName().startsWith("com.sun.org.apache.xalan")) {
 -                throw JsonMappingException.from(ctxt,
 -                        String.format("Illegal type (%s) to deserialize: prevented for security reasons",
 -                                name));
 -            }
++        String full = type.getRawClass().getName();
++
++        if (_cfgIllegalClassNames.contains(full)) {
++            ctxt.reportBadTypeDefinition(beanDesc,
++                    "Illegal type (%s) to deserialize: prevented for security reasons", full);
+         }
+     }
  }

package com.google.json;
import java.math.BigInteger;
public final class JsonSanitizer {
  public static final int DEFAULT_NESTING_DEPTH = 64;
  public static final int MAXIMUM_NESTING_DEPTH = 4096;
  public static String sanitize(String jsonish) {
    return sanitize(jsonish, DEFAULT_NESTING_DEPTH);
  }
  
  public static String sanitize(String jsonish, int maximumNestingDepth) {
    JsonSanitizer s = new JsonSanitizer(jsonish, maximumNestingDepth);
    s.sanitize();
    return s.toString();
  }
  
  private enum State {
    START_ARRAY, BEFORE_ELEMENT, AFTER_ELEMENT, START_MAP, BEFORE_KEY, AFTER_KEY, BEFORE_VALUE, AFTER_VALUE, ;
  }
  
  private final int maximumNestingDepth;
  private final String jsonish;
  private int bracketDepth;
  private boolean[] isMap;
  private StringBuilder sanitizedJson;
  private int cleaned;
  private static final boolean SUPER_VERBOSE_AND_SLOW_LOGGING = false;
  JsonSanitizer(String jsonish) {
    this(jsonish, DEFAULT_NESTING_DEPTH);
  }
  
  JsonSanitizer(String jsonish, int maximumNestingDepth) {
    this.maximumNestingDepth = Math.min(Math.max(1, maximumNestingDepth),MAXIMUM_NESTING_DEPTH);
    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {
      System.err.println("\n" + jsonish + "\n========");
    }
    
    this.jsonish = jsonish != null ? jsonish : "null";
  }
  
  int getMaximumNestingDepth() {
    return this.maximumNestingDepth;
  }
  
  void sanitize() {
    bracketDepth = cleaned = 0;
    sanitizedJson = null;
    State state = State.START_ARRAY;
    int n = jsonish.length();
    token_loop: for (int i = 0; i < n; ++i) {
      try {
        char ch = jsonish.charAt(i);
        if (SUPER_VERBOSE_AND_SLOW_LOGGING) {
          String sanitizedJsonStr = (sanitizedJson == null ? "" : sanitizedJson) + jsonish.substring(cleaned, i);
          System.err.println("i=" + i + ", ch=" + ch + ", state=" + state + ", sanitized=" + sanitizedJsonStr);
        }
        
        switch (ch) {
          case '\t': case '\n': case '\r': case ' ':
            break;
          case '"': case '\'':
            state = requireValueState(i, state, true);
            int strEnd = endOfQuotedString(jsonish, i);
            sanitizeString(i, strEnd);
            i = strEnd - 1;
            break;
          case '(': case ')':
            elide(i, i + 1);
            break;
          case '{': case '[':
            state = requireValueState(i, state, false);
            if (isMap == null) {
              isMap = new boolean[maximumNestingDepth];
            }
            
            boolean map = ch == '{';
            isMap[bracketDepth] = map; ++bracketDepth;
            state = map ? State.START_MAP : State.START_ARRAY;
            break;
          case '}': case ']':
            if (bracketDepth == 0) {
              elide(i, jsonish.length());
              break token_loop;
            }
            
            switch (state) {
              case BEFORE_VALUE:
                insert(i, "null");
                break;
              case BEFORE_ELEMENT: case BEFORE_KEY:
                elideTrailingComma(i);
                break;
              case AFTER_KEY:
                insert(i, ":null");
                break;
              case START_MAP: case START_ARRAY:
              case AFTER_ELEMENT: case AFTER_VALUE: break;
            }
             --bracketDepth;
            char closeBracket = isMap[bracketDepth] ? '}' : ']';
            if (ch != closeBracket) {
              replace(i, i + 1, closeBracket);
            }
            
            state = bracketDepth == 0 || !isMap[bracketDepth - 1] ? State.AFTER_ELEMENT : State.AFTER_VALUE;
            break;
          case ',':
            if (bracketDepth == 0) { throw UNBRACKETED_COMMA; }
            switch (state) {
              case AFTER_ELEMENT:
                state = State.BEFORE_ELEMENT;
                break;
              case AFTER_VALUE:
                state = State.BEFORE_KEY;
                break;
              case START_ARRAY: case BEFORE_ELEMENT:
                insert(i, "null");
                state = State.BEFORE_ELEMENT;
                break;
              case START_MAP: case BEFORE_KEY:
              case AFTER_KEY:
                elide(i, i + 1);
                break;
              case BEFORE_VALUE:
                insert(i, "null");
                state = State.BEFORE_KEY;
                break;
            }
            
            break;
          case ':':
            if (state == State.AFTER_KEY) {
              state = State.BEFORE_VALUE;
            }
             else {
              elide(i, i + 1);
            }
            
            break;
          case '/':
            int end = i + 1;
            if (i + 1 < n) {
              switch (jsonish.charAt(i + 1)) {
                case '/':
                  end = n;  
                  for (int j = i + 2; j < n; ++j) {
                    char cch = jsonish.charAt(j);
                    if (cch == '\n' || cch == '\r' || cch == '\u2028' || cch == '\u2029') {
                      end = j + 1;
                      break;
                    }
                    
                  }
                  
                  break;
                case '*':
                  end = n;
                  if (i + 3 < n) {
                    for (int j = i + 2; (j = jsonish.indexOf('/', j + 1)) >= 0;) {
                      if (jsonish.charAt(j - 1) == '*') {
                        end = j + 1;
                        break;
                      }
                      
                    }
                    
                  }
                  
                  break;
              }
              
            }
            
            elide(i, end);
            i = end - 1;
            break;
          default: int runEnd;
            for (runEnd = i; runEnd < n; ++runEnd) {
              char tch = jsonish.charAt(runEnd);
              if (('a' <= tch && tch <= 'z') || ('0' <= tch && tch <= '9') || tch == '+' || tch == '-' || tch == '.' || ('A' <= tch && tch <= 'Z') || tch == '_' || tch == '$') {
                continue;
              }
              
              break;
            }
            
            if (runEnd == i) {
              elide(i, i + 1);
              break;
            }
            
            state = requireValueState(i, state, true);
            boolean isNumber = ('0' <= ch && ch <= '9') || ch == '.' || ch == '+' || ch == '-';
            boolean isKeyword = !isNumber && isKeyword(i, runEnd);
            if (!(isNumber || isKeyword)) {
              for (; runEnd < n; ++runEnd) {
                if (isJsonSpecialChar(runEnd)) {
                  break;
                }
                
              }
              
              if (runEnd < n && jsonish.charAt(runEnd) == '"') { ++runEnd;
              }
              
            }
            
            if (state == State.AFTER_KEY) {
              insert(i, '"');
              if (isNumber) {
                canonicalizeNumber(i, runEnd);
                insert(runEnd, '"');
              }
               else {
                sanitizeString(i, runEnd);
              }
              
            }
             else {
              if (isNumber) {
                normalizeNumber(i, runEnd);
              }
               else if (!isKeyword) {
                insert(i, '"');
                sanitizeString(i, runEnd);
              }
              
            }
            
            i = runEnd - 1;
        }
        
      }
       catch (@SuppressWarnings("unused") UnbracketedComma e) {
        elide(i, jsonish.length());
        break;
      }
      
    }
    
    if (state == State.START_ARRAY && bracketDepth == 0) {
      insert(n, "null");
      state = State.AFTER_ELEMENT;
    }
    
    if (SUPER_VERBOSE_AND_SLOW_LOGGING) {
      System.err.println( "state=" + state + ", sanitizedJson=" + sanitizedJson + ", cleaned=" + cleaned + ", bracketDepth=" + bracketDepth);
    }
    
    if ((sanitizedJson != null && sanitizedJson.length() != 0) || cleaned != 0 || bracketDepth != 0) {
      if (sanitizedJson == null) {
        sanitizedJson = new StringBuilder(n + bracketDepth);
      }
      
      sanitizedJson.append(jsonish, cleaned, n);
      cleaned = n;
      switch (state) {
        case BEFORE_ELEMENT: case BEFORE_KEY:
          elideTrailingComma(n);
          break;
        case AFTER_KEY:
          sanitizedJson.append(":null");
          break;
        case BEFORE_VALUE:
          sanitizedJson.append("null");
          break;
        default: break;
      }
      
      while (bracketDepth != 0) {
        sanitizedJson.append(isMap[--bracketDepth] ? '}' : ']');
      }
      
    }
    
  }
  
  private void sanitizeString(int start, int end) {
    boolean closed = false;
    for (int i = start; i < end; ++i) {
      char ch = jsonish.charAt(i);
      switch (ch) {
        case '\t': replace(i, i + 1, "\\t"); break;
        case '\n': replace(i, i + 1, "\\n"); break;
        case '\r': replace(i, i + 1, "\\r"); break;
        case '\u2028': replace(i, i + 1, "\\u2028"); break;
        case '\u2029': replace(i, i + 1, "\\u2029"); break;
        case '"': case '\'':
          if (i == start) {
            if (ch == '\'') { replace(i, i + 1, '"'); }
          }
           else {
            if (i + 1 == end) {
              char startDelim = jsonish.charAt(start);
              if (startDelim != '\'') {
                startDelim = '"';
              }
              
              closed = startDelim == ch;
            }
            
            if (closed) {
              if (ch == '\'') { replace(i, i + 1, '"'); }
            }
             else if (ch == '"') {
              insert(i, '\\');
            }
            
          }
          
          break;
        case '<': {
          if (i + 3 >= end) {
            break;
          }
          
          int la = i + 1;
          int c1AndDelta = unescapedChar(jsonish, la);
          char c1 = (char) c1AndDelta;
          la += c1AndDelta >>> 16;
          long c2AndDelta = unescapedChar(jsonish, la);
          char c2 = (char) c2AndDelta;
          la += c2AndDelta >>> 16;
          long c3AndEnd = unescapedChar(jsonish, la);
          char c3 = (char) c3AndEnd;
          char lc1 = (char) (c1 | 32);
          char lc2 = (char) (c2 | 32);
          char lc3 = (char) (c3 | 32);
          if ( (c1 == '!' && c2 == '-' && c3 == '-') || (lc1 == 's' && lc2 == 'c' && lc3 == 'r') || (c1 == '/' && lc2 == 's' && lc3 == 'c') ) {
            replace(i, i + 1, "\\u003c"); 
          }
          
          break;
        }
        
        case '>':
          if ((i - 2) >= start) {
            int lb = i - 1;
            int cm1AndDelta = unescapedCharRev(jsonish, lb);
            char cm1 = (char) cm1AndDelta;
            lb -= cm1AndDelta >>> 16;
            int cm2AndDelta = unescapedCharRev(jsonish, lb);
            char cm2 = (char) cm2AndDelta;
            if ('-' == cm2 && '-' == cm1) {
              replace(i, i + 1, "\\u003e"); 
            }
            
          }
          
          break;
        case ']':
          if (i + 2 < end) {
            int la = i + 1;
            long c1AndDelta = unescapedChar(jsonish, la);
            char c1 = (char) c1AndDelta;
            la += c1AndDelta >>> 16;
            long c2AndEnd = unescapedChar(jsonish, la);
            char c2 = (char) c2AndEnd;
            if (']' == c1 && '>' == c2) {
              replace(i, i + 1, "\\u005d");
            }
            
          }
          
          break;
        case '\\':
          if (i + 1 == end) {
            elide(i, i + 1);
            break;
          }
          
          char sch = jsonish.charAt(i + 1);
          switch (sch) {
            case 'b': case 'f': case 'n': case 'r': case 't': case '\\':
            case '/': case '"': ++i;
              break;
            case 'v':  
              replace(i, i + 2, "\\u0008"); ++i;
              break;
            case 'x':
              if (i + 4 < end && isHexAt(i+2) && isHexAt(i+3)) {
                replace(i, i + 2, "\\u00");  
                i += 3;
                break;
              }
              
              elide(i, i + 1);
              break;
            case 'u':
              if (i + 6 < end && isHexAt(i + 2) && isHexAt(i + 3) && isHexAt(i + 4) && isHexAt(i + 5)) {
                i += 5;
                break;
              }
              
              elide(i, i + 1);
              break;
            case '0': case '1': case '2': case '3':
            case '4': case '5': case '6': case '7': {
              int octalStart = i + 1;
              int octalEnd = octalStart; ++octalEnd;
              if (octalEnd < end && isOctAt(octalEnd)) { ++octalEnd;
                if (sch <= '3' && octalEnd < end && isOctAt(octalEnd)) { ++octalEnd;
                }
                
              }
              
              int value = 0;
              for (int j = octalStart; j < octalEnd; ++j) {
                char digit = jsonish.charAt(j);
                value = (value << 3) | (digit - '0');
              }
              
              replace(octalStart, octalEnd, "u00");
              appendHex(value, 2);
              i = octalEnd - 1;
              break;
            }
            
            default: elide(i, i + 1);
              break;
          }
          
          break;
        default: if (ch < 0x20) {
          }
           else if (ch < 0xd800) {  
            continue;
          }
           else if (ch < 0xe000) {  
            if (Character.isHighSurrogate(ch) && i+1 < end && Character.isLowSurrogate(jsonish.charAt(i+1))) { ++i;  
              continue;
            }
            
          }
           else if (ch <= 0xfffd) {  
            continue;
          }
          
          replace(i, i + 1, "\\u");
          for (int j = 4; --j >= 0;) {
            sanitizedJson.append(HEX_DIGITS[(ch >>> (j << 2)) & 0xf]);
          }
          
          break;
      }
      
    }
    
    if (!closed) { insert(end, '"'); }
  }
  
  private State requireValueState(int pos, State state, boolean canBeKey) throws UnbracketedComma {
    switch (state) {
      case START_MAP: case BEFORE_KEY:
        if (canBeKey) {
          return State.AFTER_KEY;
        }
         else {
          insert(pos, "\"\":");
          return State.AFTER_VALUE;
        }
        
      case AFTER_KEY:
        insert(pos, ':');
        return State.AFTER_VALUE;
      case BEFORE_VALUE:
        return State.AFTER_VALUE;
      case AFTER_VALUE:
        if (canBeKey) {
          insert(pos, ',');
          return State.AFTER_KEY;
        }
         else {
          insert(pos, ",\"\":");
          return State.AFTER_VALUE;
        }
        
      case START_ARRAY: case BEFORE_ELEMENT:
        return State.AFTER_ELEMENT;
      case AFTER_ELEMENT:
        if (bracketDepth == 0) { throw UNBRACKETED_COMMA; }
        insert(pos, ',');
        return State.AFTER_ELEMENT;
    }
    
    throw new AssertionError();
  }
  
  private void insert(int pos, char ch) {
    replace(pos, pos, ch);
  }
  
  private void insert(int pos, String s) {
    replace(pos, pos, s);
  }
  
  private void elide(int start, int end) {
    if (sanitizedJson == null) {
      sanitizedJson = new StringBuilder(jsonish.length() + 16);
    }
    
    sanitizedJson.append(jsonish, cleaned, start);
    cleaned = end;
  }
  
  private void replace(int start, int end, char ch) {
    elide(start, end);
    sanitizedJson.append(ch);
  }
  
  private void replace(int start, int end, String s) {
    elide(start, end);
    sanitizedJson.append(s);
  }
  
  private static int endOfQuotedString(String s, int start) {
    char quote = s.charAt(start);
    for (int i = start; (i = s.indexOf(quote, i + 1)) >= 0;) {
      int slashRunStart = i;
      while (slashRunStart > start && s.charAt(slashRunStart - 1) == '\\') { --slashRunStart;
      }
      
      if (((i - slashRunStart) & 1) == 0) {
        return i + 1;
      }
      
    }
    
    return s.length();
  }
  
  private void elideTrailingComma(int closeBracketPos) {
    for (int i = closeBracketPos; --i >= cleaned;) {
      switch (jsonish.charAt(i)) {
        case '\t': case '\n': case '\r': case ' ':
          continue;
        case ',':
          elide(i, i+1);
          return;
        default: throw new AssertionError("" + jsonish.charAt(i));
      }
      
    }
    
    assert sanitizedJson != null;
    for (int i = sanitizedJson.length(); --i >= 0;) {
      switch (sanitizedJson.charAt(i)) {
        case '\t': case '\n': case '\r': case ' ':
          continue;
        case ',':
          sanitizedJson.setLength(i);
          return;
        default: throw new AssertionError("" + sanitizedJson.charAt(i));
      }
      
    }
    
    throw new AssertionError( "Trailing comma not found in " + jsonish + " or " + sanitizedJson);
  }
  
  private void normalizeNumber(int start, int end) {
    int pos = start;
    if (pos < end) {
      switch (jsonish.charAt(pos)) {
        case '+':
          elide(pos, pos + 1); ++pos;
          break;
        case '-': ++pos;
          break;
        default: break;
      }
      
    }
    
    int intEnd = endOfDigitRun(pos, end);
    if (pos == intEnd) {  
      insert(pos, '0');
    }
     else if ('0' == jsonish.charAt(pos)) {
      boolean reencoded = false;
      int maxDigVal = 0; 
      int probableBase = 10; 
      int firstDigitIndex = -1;
      if (intEnd - pos == 1 && intEnd < end && 'x' == (jsonish.charAt(intEnd) | 32)) {  
        probableBase = 16;
        firstDigitIndex = intEnd + 1;
        for (intEnd = intEnd + 1; intEnd < end; ++intEnd) {
          char ch = jsonish.charAt(intEnd);
          int digVal;
          if ('0' <= ch && ch <= '9') {
            digVal = ch - '0';
          }
           else {
            ch |= 32;
            if ('a' <= ch && ch <= 'f') {
              digVal = ch - ('a' - 10);
            }
             else {
              break;
            }
            
          }
          
          maxDigVal = Math.max(digVal, maxDigVal);
        }
        
        reencoded = true;
      }
       else if (intEnd - pos > 1) {  
        probableBase = 8;
        firstDigitIndex = pos;
        for (int i = pos; i < intEnd; ++i) {
          int digVal = jsonish.charAt(i) - '0';
          if (digVal < 0) {
            break;
          }
          
          maxDigVal = Math.max(digVal, maxDigVal);
        }
        
        reencoded = true;
      }
      
      if (reencoded) {
        elide(pos, intEnd);
        String digits = jsonish.substring(firstDigitIndex, intEnd);
        int nDigits = digits.length();
        int base = probableBase > maxDigVal ? probableBase : maxDigVal > 10 ? 16 : 10;
        if (DIGITS_BY_BASE_THAT_FIT_IN_63B[base] >= nDigits) {
          long value = Long.parseLong(digits, base);
          sanitizedJson.append(value);
        }
         else {
          BigInteger value = new BigInteger(digits, base);
          sanitizedJson.append(value);
        }
        
      }
      
    }
    
    pos = intEnd;
    if (pos < end && jsonish.charAt(pos) == '.') { ++pos;
      int fractionEnd = endOfDigitRun(pos, end);
      if (fractionEnd == pos) {
        insert(pos, '0');
      }
      
      pos = fractionEnd;
    }
    
    if (pos < end && 'e' == (jsonish.charAt(pos) | 32)) { ++pos;
      if (pos < end) {
        switch (jsonish.charAt(pos)) {
          case '+': case '-': ++pos; break;
          default: break;
        }
        
      }
      
      int expEnd = endOfDigitRun(pos, end);
      if (expEnd == pos) {
        insert(pos, '0');
      }
      
      pos = expEnd;
    }
    
    if (pos != end) {
      elide(pos, end);
    }
    
  }
  
  private boolean canonicalizeNumber(int start, int end) {
    elide(start, start);
    int sanStart = sanitizedJson.length();
    normalizeNumber(start, end);
    elide(end, end);
    int sanEnd = sanitizedJson.length();
    return canonicalizeNumber(sanitizedJson, sanStart, sanEnd);
  }
  
  private static boolean canonicalizeNumber( StringBuilder sanitizedJson, int sanStart, int sanEnd) {
    int intStart, intEnd, fractionStart, fractionEnd, expStart, expEnd;
    intStart = sanStart + (sanitizedJson.charAt(sanStart) == '-' ? 1 : 0);
    for (intEnd = intStart; intEnd < sanEnd; ++intEnd) {
      char ch = sanitizedJson.charAt(intEnd);
      if (!('0' <= ch && ch <= '9')) { break; }
    }
    
    if (intEnd == sanEnd || '.' != sanitizedJson.charAt(intEnd)) {
      fractionStart = fractionEnd = intEnd;
    }
     else {
      fractionStart = intEnd + 1;
      for (fractionEnd = fractionStart; fractionEnd < sanEnd; ++fractionEnd) {
        char ch = sanitizedJson.charAt(fractionEnd);
        if (!('0' <= ch && ch <= '9')) { break; }
      }
      
    }
    
    if (fractionEnd == sanEnd) {
      expStart = expEnd = sanEnd;
    }
     else {
      assert 'e' == (sanitizedJson.charAt(fractionEnd) | 32);
      expStart = fractionEnd + 1;
      if (sanitizedJson.charAt(expStart) == '+') { ++expStart; }
      expEnd = sanEnd;
    }
    
    assert intStart      <= intEnd && intEnd        <= fractionStart && fractionStart <= fractionEnd && fractionEnd   <= expStart && expStart      <= expEnd;
    int exp;
    if (expEnd == expStart) {
      exp = 0;
    }
     else {
      try {
        exp = Integer.parseInt(sanitizedJson.substring(expStart, expEnd), 10);
      }
       catch (@SuppressWarnings("unused") NumberFormatException ex) {
        return false;
      }
      
    }
    
    int n = exp;  
    boolean sawDecimal = false;
    boolean zero = true;
    int digitOutPos = intStart;
    for (int i = intStart, nZeroesPending = 0; i < fractionEnd; ++i) {
      char ch = sanitizedJson.charAt(i);
      if (ch == '.') {
        sawDecimal = true;
        if (zero) { nZeroesPending = 0; }
        continue;
      }
      
      char digit = ch;
      if ((!zero || digit != '0') && !sawDecimal) { ++n; }
      if (digit == '0') { ++nZeroesPending;
      }
       else {
        if (zero) {  
          if (sawDecimal) {
            n -= nZeroesPending;
          }
          
          nZeroesPending = 0;
        }
        
        zero = false;
        while (nZeroesPending != 0 || digit != 0) {
          char vdigit;
          if (nZeroesPending == 0) {
            vdigit = digit;
            digit = (char) 0;
          }
           else {
            vdigit = '0'; --nZeroesPending;
          }
          
          sanitizedJson.setCharAt(digitOutPos++, vdigit);
        }
        
      }
      
    }
    
    sanitizedJson.setLength(digitOutPos);
    int k = digitOutPos - intStart;
    if (zero) {  
      sanitizedJson.setLength(sanStart);  
      sanitizedJson.append('0');
      return true;
    }
    
    if (k <= n && n <= 21) {
      for (int i = k; i < n; ++i) {
        sanitizedJson.append('0');
      }
      
    }
     else if (0 < n && n <= 21) {
      sanitizedJson.insert(intStart + n, '.');
    }
     else if (-6 < n && n <= 0) {
      sanitizedJson.insert(intStart, "0.000000".substring(0, 2 - n));
    }
     else {
      if (k == 1) {
      }
       else {
        sanitizedJson.insert(intStart + 1, '.');
      }
      
      int nLess1 = n-1;
      sanitizedJson.append('e').append(nLess1 < 0 ? '-' : '+') .append(Math.abs(nLess1));
    }
    
    return true;
  }
  
  private boolean isKeyword(int start, int end) {
    int n = end - start;
    if (n == 5) {
      return "false".regionMatches(0, jsonish, start, n);
    }
     else if (n == 4) {
      return "null".regionMatches(0, jsonish, start, n) || "true".regionMatches(0, jsonish, start, n);
    }
    
    return false;
  }
  
  private boolean isOctAt(int i) {
    return isOct(jsonish.charAt(i));
  }
  
  private static boolean isOct(char ch) {
    return '0' <= ch && ch <= '7';
  }
  
  private boolean isHexAt(int i) {
    return isHex(jsonish.charAt(i));
  }
  
  private static boolean isHex(char ch) {
    if ('0' <= ch && ch <= '9') { return true; }
    int lch = ch | 32;
    return 'a' <= lch && lch <= 'f';
  }
  
  private static int hexVal(char ch) {
    int lch = ch | 32;
    return lch - (lch <= '9' ? '0' : 'a' - 10);
  }
  
  private boolean isJsonSpecialChar(int i) {
    char ch = jsonish.charAt(i);
    if (ch <= ' ') { return true; }
    switch (ch) {
      case '"':
      case ',': case ':':
      case '[': case ']':
      case '{': case '}':
        return true;
      default: return false;
    }
    
  }
  
  private void appendHex(int n, int nDigits) {
    for (int quadsToShift = nDigits; --quadsToShift >= 0;) {
      int dig = (n >>> (4 * quadsToShift)) & 0xf;
      sanitizedJson.append((char) (dig + (dig < 10 ? '0' : (char) ('a' - 10))));
    }
    
  }
  
  private static final class UnbracketedComma extends Exception {
    private static final long serialVersionUID = 783239978717247850L;
  }
  
  private int endOfDigitRun(int start, int limit) {
    for (int end = start; end < limit; ++end) {
      char ch = jsonish.charAt(end);
      if (!('0' <= ch && ch <= '9')) { return end; }
    }
    
    return limit;
  }
  
  @SuppressWarnings("synthetic-access")
  private static final UnbracketedComma UNBRACKETED_COMMA = new UnbracketedComma();
  static {
    UNBRACKETED_COMMA.setStackTrace(new StackTraceElement[0]);
  }
  
  CharSequence toCharSequence() {
    return sanitizedJson != null ? sanitizedJson : jsonish;
  }
  
  @Override
  public String toString() {
    return sanitizedJson != null ? sanitizedJson.toString() : jsonish;
  }
  
  private static final char[] HEX_DIGITS = new char[] {     '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', };
  private static final int[] DIGITS_BY_BASE_THAT_FIT_IN_63B = { -1,               -1, 63,               39, 31, 27, 24, 22, 21 , 19, 18 , 18, 17, 17, 16, 16, 15 , };
  private static int unescapedChar(String s, int left) {
    int n = s.length();
    if (left >= n) {
      return 0;
    }
    
    char c = s.charAt(left);
    if (c == '\\') {
      if (left + 1 == n) {
        return 0x10000;
      }
      
      char nc = s.charAt(left + 1);
      switch (nc) {
        case '0': case '1': case '2': case '3':
        case '4': case '5': case '6': case '7': {
          int octalStart = left + 1;
          int octalEnd = octalStart; ++octalEnd;
          if (octalEnd < n && isOct(s.charAt(octalEnd))) { ++octalEnd;
            if (nc <= '3' && octalEnd < n && isOct(s.charAt(octalEnd))) { ++octalEnd;
            }
            
          }
          
          int value = 0;
          for (int j = octalStart; j < octalEnd; ++j) {
            char digit = s.charAt(j);
            value = (value << 3) | (digit - '0');
          }
          
          return ((octalEnd - left) << 16) | value;
        }
        
        case 'x':
          if (left + 3 < n) {
            char d0 = s.charAt(left + 2);
            char d1 = s.charAt(left + 3);
            if (isHex(d0) && isHex(d1)) {
              return 0x4000 | (hexVal(d0) << 4) | hexVal(d1);
            }
            
          }
          
          break;
        case 'u':
          if (left + 5 < n) {
            char d0 = s.charAt(left + 2);
            char d1 = s.charAt(left + 3);
            char d2 = s.charAt(left + 4);
            char d3 = s.charAt(left + 5);
            if (isHex(d0) && isHex(d1) && isHex(d2) && isHex(d3)) {
              return 0x6000 | (hexVal(d0) << 12) | (hexVal(d1) << 8) | (hexVal(d2) << 4) | hexVal(d3);
            }
            
          }
          
          break;
        case 'b': return (0x20000 | '\b');
        case 'f': return (0x20000 | '\f');
        case 'n': return 0x2000A;
        case 'r': return 0x2000D;
        case 't': return 0x20009;
        case 'v': return 0x20008;
        default: break;
      }
      
      return (0x20000) | nc;
    }
     else {
      return 0x10000 | c;
    }
    
  }
  
  private static int unescapedCharRev(String s, int rightIncl) {
    if (rightIncl < 0) {
      return 0;
    }
    
    for (int i = 1; i < 6; ++i) {
      int left = rightIncl - i;
      if (left < 0) { break; }
      if (s.charAt(left) == '\\') {
        int n = 1;
        while (left - n >= 0 && s.charAt(left - n) == '\\') { ++n;
        }
        
        if ((n & 1) == 0) {
          int unescaped = unescapedChar(s, left);
          if ((unescaped >>> 16) == i) {
            return unescaped;
          }
          
        }
        
        break;
      }
      
    }
    
    return 0x10000 | s.charAt(rightIncl);
  }
  
}


package org.apache.logging.log4j.core.appender;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.AbstractLifeCycle;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.ConfigurationException;
import org.apache.logging.log4j.message.Message;
import org.apache.logging.log4j.status.StatusLogger;
public abstract class AbstractManager implements AutoCloseable {
    protected static final Logger LOGGER = StatusLogger.getLogger();
    private static final Map<String, AbstractManager> MAP = new HashMap<>();
    private static final Lock LOCK = new ReentrantLock();
    protected int count;
    private final String name;
    private final LoggerContext loggerContext;
    protected AbstractManager(final LoggerContext loggerContext, final String name) {
        this.loggerContext = loggerContext;
        this.name = name;
        LOGGER.debug("Starting {} {}", this.getClass().getSimpleName(), name);
    }
    
    @Override
    public void close() {
        stop(AbstractLifeCycle.DEFAULT_STOP_TIMEOUT, AbstractLifeCycle.DEFAULT_STOP_TIMEUNIT);
    }
    
    public boolean stop(final long timeout, final TimeUnit timeUnit) {
        boolean stopped = true;
        LOCK.lock();
        try { --count;
            if (count <= 0) {
                MAP.remove(name);
                LOGGER.debug("Shutting down {} {}", this.getClass().getSimpleName(), getName());
                stopped = releaseSub(timeout, timeUnit);
                LOGGER.debug("Shut down {} {}, all resources released: {}", this.getClass().getSimpleName(), getName(), stopped);
            }
            
        }
         finally {
            LOCK.unlock();
        }
        
        return stopped;
    }
    
    @SuppressWarnings("resource")
    public static <M extends AbstractManager, T> M getManager(final String name, final ManagerFactory<M, T> factory, final T data) {
        LOCK.lock();
        try {
            @SuppressWarnings("unchecked")
            M manager = (M) MAP.get(name);
            if (manager == null) {
                manager = factory.createManager(name, data);
                if (manager == null) {
                    throw new IllegalStateException("ManagerFactory [" + factory + "] unable to create manager for [" + name + "] with data [" + data + "]");
                }
                
                MAP.put(name, manager);
            }
             else {
                manager.updateData(data);
            }
            
            manager.count++;
            return manager;
        }
         finally {
            LOCK.unlock();
        }
        
    }
    
    public void updateData(final Object data) {
    }
    
    public static boolean hasManager(final String name) {
        LOCK.lock();
        try {
            return MAP.containsKey(name);
        }
         finally {
            LOCK.unlock();
        }
        
    }
    
    protected static <M extends AbstractManager> M narrow(final Class<M> narrowClass, final AbstractManager manager) {
        if (narrowClass.isAssignableFrom(manager.getClass())) {
            return (M) manager;
        }
        
        throw new ConfigurationException( "Configuration has multiple incompatible Appenders pointing to the same resource '" + manager.getName() + "'");
    }
    
    protected static StatusLogger logger() {
        return StatusLogger.getLogger();
    }
    
    protected boolean releaseSub(final long timeout, final TimeUnit timeUnit) {
        return true;
    }
    
    protected int getCount() {
        return count;
    }
    
    public LoggerContext getLoggerContext() {
        return loggerContext;
    }
    
    @Deprecated
    public void release() {
        close();
    }
    
    public String getName() {
        return name;
    }
    
    public Map<String, String> getContentFormat() {
        return new HashMap<>();
    }
    
    protected void log(final Level level, final String message, final Throwable throwable) {
        final Message m = LOGGER.getMessageFactory().newMessage("{} {} {}: {}", getClass().getSimpleName(), getName(), message, throwable);
        LOGGER.log(level, m, throwable);
    }
    
    protected void logDebug(final String message, final Throwable throwable) {
        log(Level.DEBUG, message, throwable);
    }
    
    protected void logError(final String message, final Throwable throwable) {
        log(Level.ERROR, message, throwable);
    }
    
    protected void logWarn(final String message, final Throwable throwable) {
        log(Level.WARN, message, throwable);
    }
    
}


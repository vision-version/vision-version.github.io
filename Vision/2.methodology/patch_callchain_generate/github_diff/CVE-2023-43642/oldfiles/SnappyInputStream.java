package org.xerial.snappy;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
public class SnappyInputStream extends InputStream {
    private boolean finishedReading = false;
    protected final InputStream in;
    private byte[] compressed;
    private byte[] uncompressed;
    private int uncompressedCursor = 0;
    private int uncompressedLimit = 0;
    private byte[] header = new byte[SnappyCodec.headerSize()];
    public SnappyInputStream(InputStream input) throws IOException {
        this.in = input;
        readHeader();
    }
    
    @Override
    public void close() throws IOException {
        compressed = null;
        uncompressed = null;
        if (in != null) {
            in.close();
        }
        
    }
    
    protected void readHeader() throws IOException {
        int readBytes = 0;
        while (readBytes < header.length) {
            int ret = in.read(header, readBytes, header.length - readBytes);
            if (ret == -1) {
                break;
            }
            
            readBytes += ret;
        }
        
        if (readBytes == 0) {
            throw new SnappyIOException(SnappyErrorCode.EMPTY_INPUT, "Cannot decompress empty stream");
        }
        
        if (readBytes < header.length || !SnappyCodec.hasMagicHeaderPrefix(header)) {
            readFully(header, readBytes);
            return;
        }
        
    }
    
    private static boolean isValidHeader(byte[] header) throws IOException {
        SnappyCodec codec = SnappyCodec.readHeader(new ByteArrayInputStream(header));
        if (codec.isValidMagicHeader()) {
            if (codec.version < SnappyCodec.MINIMUM_COMPATIBLE_VERSION) {
                throw new SnappyIOException(SnappyErrorCode.INCOMPATIBLE_VERSION, String.format( "Compressed with an incompatible codec version %d. At least version %d is required", codec.version, SnappyCodec.MINIMUM_COMPATIBLE_VERSION));
            }
            
            return true;
        }
        
        else {
            return false;
        }
        
    }
    
    protected void readFully(byte[] fragment, int fragmentLength) throws IOException {
        if (fragmentLength == 0) {
            finishedReading = true;
            return;
        }
        
        compressed = new byte[Math.max(8 * 1024, fragmentLength)]; 
        System.arraycopy(fragment, 0, compressed, 0, fragmentLength);
        int cursor = fragmentLength;
        for (int readBytes = 0; (readBytes = in.read(compressed, cursor, compressed.length - cursor)) != -1; ) {
            cursor += readBytes;
            if (cursor >= compressed.length) {
                byte[] newBuf = new byte[(compressed.length * 2)];
                System.arraycopy(compressed, 0, newBuf, 0, compressed.length);
                compressed = newBuf;
            }
            
        }
        
        finishedReading = true;
        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, cursor);
        uncompressed = new byte[uncompressedLength];
        Snappy.uncompress(compressed, 0, cursor, uncompressed, 0);
        this.uncompressedCursor = 0;
        this.uncompressedLimit = uncompressedLength;
    }
    
    @Override
    public int read(byte[] b, int byteOffset, int byteLength) throws IOException {
        int writtenBytes = 0;
        for (; writtenBytes < byteLength; ) {
            if (uncompressedCursor >= uncompressedLimit) {
                if (hasNextChunk()) {
                    continue;
                }
                
                else {
                    return writtenBytes == 0 ? -1 : writtenBytes;
                }
                
            }
            
            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);
            System.arraycopy(uncompressed, uncompressedCursor, b, byteOffset + writtenBytes, bytesToWrite);
            writtenBytes += bytesToWrite;
            uncompressedCursor += bytesToWrite;
        }
        
        return writtenBytes;
    }
    
    public int rawRead(Object array, int byteOffset, int byteLength) throws IOException {
        int writtenBytes = 0;
        for (; writtenBytes < byteLength; ) {
            if (uncompressedCursor >= uncompressedLimit) {
                if (hasNextChunk()) {
                    continue;
                }
                
                else {
                    return writtenBytes == 0 ? -1 : writtenBytes;
                }
                
            }
            
            int bytesToWrite = Math.min(uncompressedLimit - uncompressedCursor, byteLength - writtenBytes);
            Snappy.arrayCopy(uncompressed, uncompressedCursor, bytesToWrite, array, byteOffset + writtenBytes);
            writtenBytes += bytesToWrite;
            uncompressedCursor += bytesToWrite;
        }
        
        return writtenBytes;
    }
    
    public int read(long[] d, int off, int len) throws IOException {
        return rawRead(d, off * 8, len * 8);
    }
    
    public int read(long[] d) throws IOException {
        return read(d, 0, d.length);
    }
    
    public int read(double[] d, int off, int len) throws IOException {
        return rawRead(d, off * 8, len * 8);
    }
    
    public int read(double[] d) throws IOException {
        return read(d, 0, d.length);
    }
    
    public int read(int[] d) throws IOException {
        return read(d, 0, d.length);
    }
    
    public int read(int[] d, int off, int len) throws IOException {
        return rawRead(d, off * 4, len * 4);
    }
    
    public int read(float[] d, int off, int len) throws IOException {
        return rawRead(d, off * 4, len * 4);
    }
    
    public int read(float[] d) throws IOException {
        return read(d, 0, d.length);
    }
    
    public int read(short[] d, int off, int len) throws IOException {
        return rawRead(d, off * 2, len * 2);
    }
    
    public int read(short[] d) throws IOException {
        return read(d, 0, d.length);
    }
    
    private int readNext(byte[] dest, int offset, int len) throws IOException {
        int readBytes = 0;
        while (readBytes < len) {
            int ret = in.read(dest, readBytes + offset, len - readBytes);
            if (ret == -1) {
                finishedReading = true;
                return readBytes;
            }
            
            readBytes += ret;
        }
        
        return readBytes;
    }
    
    protected boolean hasNextChunk() throws IOException {
        if (finishedReading) {
            return false;
        }
        
        uncompressedCursor = 0;
        uncompressedLimit = 0;
        int readBytes = readNext(header, 0, 4);
        if (readBytes < 4) {
            return false;
        }
        
        int chunkSize = SnappyOutputStream.readInt(header, 0);
        if (chunkSize == SnappyCodec.MAGIC_HEADER_HEAD) {
            int remainingHeaderSize = SnappyCodec.headerSize() - 4;
            readBytes = readNext(header, 4, remainingHeaderSize);
            if(readBytes < remainingHeaderSize) {
                throw new SnappyIOException(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format("Insufficient header size in a concatenated block"));
            }
            
            if (isValidHeader(header)) {
                return hasNextChunk();
            }
            
            else {
                return false;
            }
            
        }
        
        if (chunkSize < 0) {
            throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, "chunkSize is too big or negative : " + chunkSize);
        }
        
        if (compressed == null || chunkSize > compressed.length) {
            try {
                compressed = new byte[chunkSize];
            }
            
            catch (java.lang.OutOfMemoryError e) {
                throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, e.getMessage());
            }
            
        }
        
        readBytes = 0;
        while (readBytes < chunkSize) {
            int ret = in.read(compressed, readBytes, chunkSize - readBytes);
            if (ret == -1) {
                break;
            }
            
            readBytes += ret;
        }
        
        if (readBytes < chunkSize) {
            throw new IOException("failed to read chunk");
        }
        
        int uncompressedLength = Snappy.uncompressedLength(compressed, 0, chunkSize);
        if (uncompressed == null || uncompressedLength > uncompressed.length) {
            uncompressed = new byte[uncompressedLength];
        }
        
        int actualUncompressedLength = Snappy.uncompress(compressed, 0, chunkSize, uncompressed, 0);
        if (uncompressedLength != actualUncompressedLength) {
            throw new SnappyIOException(SnappyErrorCode.INVALID_CHUNK_SIZE, String.format("expected %,d bytes, but decompressed chunk has %,d bytes", uncompressedLength, actualUncompressedLength));
        }
        
        uncompressedLimit = actualUncompressedLength;
        return true;
    }
    
    @Override
    public int read() throws IOException {
        if (uncompressedCursor < uncompressedLimit) {
            return uncompressed[uncompressedCursor++] & 0xFF;
        }
        
        else {
            if (hasNextChunk()) {
                return read();
            }
            
            else {
                return -1;
            }
            
        }
        
    }
    
    @Override
    public int available() throws IOException {
        if (uncompressedCursor < uncompressedLimit) {
            return uncompressedLimit - uncompressedCursor;
        }
        
        else {
            if (hasNextChunk()) {
                return uncompressedLimit - uncompressedCursor;
            }
            
            else {
                return 0;
            }
            
        }
        
    }
    
}


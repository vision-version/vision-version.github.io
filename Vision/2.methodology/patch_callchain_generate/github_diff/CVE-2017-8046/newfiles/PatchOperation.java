package org.springframework.data.rest.webmvc.json.patch;
import static org.springframework.data.rest.webmvc.json.patch.PathToSpEL.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import org.springframework.core.CollectionFactory;
import org.springframework.core.convert.TypeDescriptor;
import org.springframework.data.mapping.PropertyPath;
import org.springframework.data.mapping.PropertyReferenceException;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionException;
import org.springframework.expression.spel.SpelEvaluationException;
import org.springframework.util.StringUtils;
public abstract class PatchOperation {
	private static final String INVALID_PATH_REFERENCE = "Invalid path reference %s on type %s (from source %s)!";
	protected final String op;
	protected final String path;
	protected final Object value;
	protected final Expression spelExpression;
	 public PatchOperation(String op, String path) {
		this(op, path, null);
	}
	
	 public PatchOperation(String op, String path, Object value) {
		this.op = op;
		this.path = path;
		this.value = value;
		this.spelExpression = pathToExpression(path);
	}
	
	 public String getOp() {
		return op;
	}
	
	 public String getPath() {
		return path;
	}
	
	 public Object getValue() {
		return value;
	}
	
	 protected Object popValueAtPath(Object target, String removePath) {
		Integer listIndex = targetListIndex(removePath);
		Expression expression = pathToExpression(removePath);
		Object value = expression.getValue(target);
		if (listIndex == null) {
			try {
				expression.setValue(target, null);
				return value;
			}
			 catch (NullPointerException o_O) {
				throw new PatchException("Path '" + removePath + "' is not nullable.", o_O);
			}
			 catch (SpelEvaluationException o_O) {
				throw new PatchException("Path '" + removePath + "' is not nullable.", o_O);
			}
			
		}
		 else {
			Expression parentExpression = pathToParentExpression(removePath);
			List<?> list = (List<?>) parentExpression.getValue(target);
			list.remove(listIndex >= 0 ? listIndex.intValue() : list.size() - 1);
			return value;
		}
		
	}
	
	 @SuppressWarnings({ "unchecked", "null" })
	protected void addValue(Object target, Object value) {
		Expression parentExpression = pathToParentExpression(path);
		Object parent = parentExpression != null ? parentExpression.getValue(target) : null;
		Integer listIndex = targetListIndex(path);
		if (parent == null || !(parent instanceof List) || listIndex == null) {
			TypeDescriptor descriptor = parentExpression.getValueTypeDescriptor(target);
			 if (descriptor.isCollection() && !Collection.class.isInstance(value)) {
				Collection<Object> collection = CollectionFactory.createCollection(descriptor.getType(), 1);
				collection.add(value);
				parentExpression.setValue(target, collection);
			}
			 else {
				spelExpression.setValue(target, value);
			}
			
		}
		 else {
			List<Object> list = (List<Object>) parentExpression.getValue(target);
			list.add(listIndex >= 0 ? listIndex.intValue() : list.size(), value);
		}
		
	}
	
	 protected void setValueOnTarget(Object target, Object value) {
		spelExpression.setValue(target, value);
	}
	
	 protected Object getValueFromTarget(Object target) {
		try {
			return spelExpression.getValue(target);
		}
		 catch (ExpressionException e) {
			throw new PatchException("Unable to get value from target", e);
		}
		
	}
	
	 protected <T> Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {
		verifyPath(entityType);
		return evaluate(spelExpression.getValueType(targetObject));
	}
	
	protected final <T> Object evaluate(Class<T> targetType) {
		return value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(targetType) : value;
	}
	
	 abstract <T> void perform(Object target, Class<T> type);
	private Integer targetListIndex(String path) {
		String[] pathNodes = path.split("\\/");
		String lastNode = pathNodes[pathNodes.length - 1];
		if (APPEND_CHARACTERS.contains(lastNode)) {
			return -1;
		}
		
		try {
			return Integer.parseInt(lastNode);
		}
		 catch (NumberFormatException e) {
			return null;
		}
		
	}
	
	 protected PropertyPath verifyPath(Class<?> type) {
		List<String> segments = new ArrayList<String>();
		for (String segment : path.split("/")) {
			if (!(segment.matches("\\d+") || segment.equals("-") || segment.isEmpty())) {
				segments.add(segment);
			}
			
		}
		
		if (segments.isEmpty()) {
			return null;
		}
		
		String pathSource = StringUtils.collectionToDelimitedString(segments, ".");
		try {
			return PropertyPath.from(pathSource, type);
		}
		 catch (PropertyReferenceException o_O) {
			throw new PatchException(String.format(INVALID_PATH_REFERENCE, pathSource, type, path), o_O);
		}
		
	}
	
}


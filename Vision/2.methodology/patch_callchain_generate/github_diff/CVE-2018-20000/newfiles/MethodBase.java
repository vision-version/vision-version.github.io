package org.bedework.webdav.servlet.common;
import org.bedework.util.misc.Logged;
import org.bedework.util.xml.XmlEmit;
import org.bedework.util.xml.XmlEmit.NameSpace;
import org.bedework.util.xml.XmlEmit.Notifier;
import org.bedework.util.xml.XmlUtil;
import org.bedework.util.xml.tagdefs.WebdavTags;
import org.bedework.webdav.servlet.shared.WebdavBadRequest;
import org.bedework.webdav.servlet.shared.WebdavException;
import org.bedework.webdav.servlet.shared.WebdavNsIntf;
import org.bedework.webdav.servlet.shared.WebdavNsNode;
import org.bedework.webdav.servlet.shared.WebdavProperty;
import org.bedework.webdav.servlet.shared.WebdavStatusCode;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import java.io.IOException;
import java.io.Reader;
import java.net.URLDecoder;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.StringTokenizer;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.ws.Holder;
public abstract class MethodBase extends Logged implements SecureXml {
  protected boolean dumpContent;
  protected boolean hasBriefHeader;
  protected WebdavNsIntf nsIntf;
  private String resourceUri;
  protected XmlEmit xml;
  public abstract void init();
  private SimpleDateFormat httpDateFormatter = new SimpleDateFormat("E, dd MMM yyyy HH:mm:ss ");
  public abstract void doMethod(HttpServletRequest req, HttpServletResponse resp) throws WebdavException;
  public static class MethodInfo {
    private Class methodClass;
    private boolean requiresAuth;
    public MethodInfo(final Class methodClass, final boolean requiresAuth) {
      this.methodClass = methodClass;
      this.requiresAuth = requiresAuth;
    }
    
    public Class getMethodClass() {
      return methodClass;
    }
    
    public boolean getRequiresAuth() {
      return requiresAuth;
    }
    
  }
  
  public void init(final WebdavNsIntf nsIntf, final boolean dumpContent) throws WebdavException{
    this.nsIntf = nsIntf;
    debug = getLogger().isDebugEnabled();
    this.dumpContent = dumpContent;
    xml = nsIntf.getXmlEmit();
    resourceUri = null;
    init();
  }
  
  public WebdavNsIntf getNsIntf() {
    return nsIntf;
  }
  
  public String getResourceUri(final HttpServletRequest req) throws WebdavException {
    if (resourceUri != null) {
      return resourceUri;
    }
    
    resourceUri = getNsIntf().getResourceUri(req);
    if (debug) {
      debug("resourceUri: " + resourceUri);
    }
    
    return resourceUri;
  }
  
  public static List<String> fixPath(final String path) throws WebdavException {
    if (path == null) {
      return null;
    }
    
    String decoded;
    try {
      decoded = URLDecoder.decode(path, "UTF8");
    }
     catch (final Throwable t) {
      throw new WebdavException("bad path: " + path);
    }
    
    if (decoded == null) {
      return (null);
    }
    
    if (decoded.indexOf('\\') >= 0) {
      decoded = decoded.replace('\\', '/');
    }
    
    if (!decoded.startsWith("/")) {
      decoded = "/" + decoded;
    }
    
    while (decoded.contains("//")) {
      decoded = decoded.replaceAll("//", "/");
    }
    
    final StringTokenizer st = new StringTokenizer(decoded, "/");
    final ArrayList<String> al = new ArrayList<String>();
    while (st.hasMoreTokens()) {
      final String s = st.nextToken();
      if (s.equals(".")) {
      }
       else if (s.equals("..")) {
        if (al.size() == 0) {
          return null;
        }
        
        al.remove(al.size() - 1);
      }
       else {
        al.add(s);
      }
      
    }
    
    return al;
  }
  
  protected int defaultDepth(final int depth, final int def) {
    if (depth < 0) {
      return def;
    }
    
    return depth;
  }
  
  protected void checkDepth(final int depth, final int val) throws WebdavException {
    if (depth != val) {
      throw new WebdavBadRequest();
    }
    
  }
  
  protected String getStatus(final int status, String message) {
    if (message == null) {
      message = WebdavStatusCode.getMessage(status);
    }
    
    return "HTTP/1.1 " + status + " " + message;
  }
  
  protected void addStatus(final int status, String message) throws WebdavException {
    try {
      if (message == null) {
        message = WebdavStatusCode.getMessage(status);
      }
      
      property(WebdavTags.status, "HTTP/1.1 " + status + " " + message);
    }
     catch (WebdavException wde) {
      throw wde;
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  protected void addHeaders(final HttpServletRequest req, final HttpServletResponse resp, final WebdavNsNode node) throws WebdavException {
    addDavHeader(resp, node);
    resp.addHeader("MS-Author-Via", "DAV");
    final StringBuilder methods = new StringBuilder();
    for (final String name: getNsIntf().getMethodNames()) {
      if (methods.length() > 0) {
        methods.append(", ");
      }
      
      methods.append(name);
    }
    
    resp.addHeader("Allow", methods.toString());
  }
  
  public void checkServerInfo(final HttpServletRequest req, final HttpServletResponse resp) throws WebdavException {
    final String curToken = getNsIntf().getServerInfo().getToken();
    final String method = req.getMethod();
    boolean sendServerInfoUrl = false;
    final String theirToken = req.getHeader("server-info-token");
    if (theirToken == null) {
      sendServerInfoUrl = method.equalsIgnoreCase("options");
    }
     else if (!theirToken.equals(curToken)) {
      sendServerInfoUrl = true;
    }
    
    if (sendServerInfoUrl) {
      resp.addHeader("Link", "<" + getNsIntf().makeServerInfoUrl(req) + ">; rel=\"server-info\"; " + "token=\"" + curToken + "\"");
    }
    
  }
  
  protected void addDavHeader(final HttpServletResponse resp, final WebdavNsNode node) throws WebdavException {
    resp.addHeader("DAV", getNsIntf().getDavHeader(node));
  }
  
  protected Document parseContent(final HttpServletRequest req, final HttpServletResponse resp) throws WebdavException{
    try {
      hasBriefHeader = Headers.brief(req);
      return parseContent(req.getContentLength(), getNsIntf().getReader(req));
    }
     catch (WebdavException we) {
      throw we;
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  protected Document parseContent(final int contentLength, final Reader reader) throws WebdavException{
    return parseXmlSafely(contentLength, reader);
  }
  
  protected String formatHTTPDate(final Timestamp val) {
    if (val == null) {
      return null;
    }
    
    synchronized (httpDateFormatter) {
      return httpDateFormatter.format(val) + "GMT";
    }
    
  }
  
  private class XmlNotifier extends Notifier {
    private boolean enabled;
    private Holder<Boolean> openFlag;
    XmlNotifier(final Holder<Boolean> openFlag) {
      this.openFlag = openFlag;
      enabled = true;
    }
    
    @Override
    public void doNotification() throws Throwable {
      enabled = false;
      if (!openFlag.value) {
        openFlag.value = true;
        openTag(WebdavTags.propstat);
        openTag(WebdavTags.prop);
      }
      
    }
    
    @Override
    public boolean isEnabled() {
      return enabled;
    }
    
  }
  
  public void doPropFind(final WebdavNsNode node, final Collection<WebdavProperty> props) throws WebdavException {
    final WebdavNsIntf intf = getNsIntf();
    final Collection<WebdavProperty> unknowns = new ArrayList<WebdavProperty>();
    final Holder<Boolean> openFlag = new Holder<Boolean>(Boolean.FALSE);
    final XmlNotifier notifier = new XmlNotifier(openFlag);
    try {
      xml.setNotifier(notifier);
      for (final WebdavProperty pr: props) {
        if (!intf.knownProperty(node, pr)) {
          unknowns.add(pr);
        }
         else  {
          addNs(pr.getTag().getNamespaceURI());
          if (!intf.generatePropValue(node, pr, false)) {
            unknowns.add(pr);
          }
          
        }
        
      }
      
      if (openFlag.value) {
        closeTag(WebdavTags.prop);
        addStatus(node.getStatus(), null);
        closeTag(WebdavTags.propstat);
      }
      
      xml.setNotifier(null);
      if (!hasBriefHeader && !unknowns.isEmpty()) {
        openTag(WebdavTags.propstat);
        openTag(WebdavTags.prop);
        for (final WebdavProperty prop: unknowns) {
          try {
            xml.emptyTag(prop.getTag());
          }
           catch (Throwable t) {
            throw new WebdavException(t);
          }
          
        }
        
        closeTag(WebdavTags.prop);
        addStatus(HttpServletResponse.SC_NOT_FOUND, null);
        closeTag(WebdavTags.propstat);
      }
      
    }
     finally {
      xml.setNotifier(null);
    }
    
  }
  
  protected Collection<Element> getChildren(final Node nd) throws WebdavException {
    try {
      return XmlUtil.getElements(nd);
    }
     catch (Throwable t) {
      if (debug) {
        getLogger().error(this, t);
      }
      
      throw new WebdavBadRequest(t.getMessage());
    }
    
  }
  
  protected Element[] getChildrenArray(final Node nd) throws WebdavException {
    try {
      return XmlUtil.getElementsArray(nd);
    }
     catch (Throwable t) {
      if (debug) {
        getLogger().error(this, t);
      }
      
      throw new WebdavBadRequest(t.getMessage());
    }
    
  }
  
  protected Element getOnlyChild(final Node nd) throws WebdavException {
    try {
      return XmlUtil.getOnlyElement(nd);
    }
     catch (Throwable t) {
      if (debug) {
        getLogger().error(this, t);
      }
      
      throw new WebdavBadRequest(t.getMessage());
    }
    
  }
  
  protected String getElementContent(final Element el) throws WebdavException {
    try {
      return XmlUtil.getElementContent(el);
    }
     catch (Throwable t) {
      if (debug) {
        getLogger().error(this, t);
      }
      
      throw new WebdavBadRequest(t.getMessage());
    }
    
  }
  
  protected boolean isEmpty(final Element el) throws WebdavException {
    try {
      return XmlUtil.isEmpty(el);
    }
     catch (Throwable t) {
      if (debug) {
        getLogger().error(this, t);
      }
      
      throw new WebdavBadRequest(t.getMessage());
    }
    
  }
  
  protected void startEmit(final HttpServletResponse resp) throws WebdavException {
    try {
      xml.startEmit(resp.getWriter());
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  public void addNs(final String val) throws WebdavException {
    if (xml.getNameSpace(val) == null) {
      try {
        xml.addNs(new NameSpace(val, null), false);
      }
       catch (IOException e) {
        throw new WebdavException(e);
      }
      
    }
    
  }
  
  public String getNsAbbrev(final String ns) {
    return xml.getNsAbbrev(ns);
  }
  
  protected void openTag(final QName tag) throws WebdavException {
    try {
      xml.openTag(tag);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  protected void openTagNoNewline(final QName tag) throws WebdavException {
    try {
      xml.openTagNoNewline(tag);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  protected void closeTag(final QName tag) throws WebdavException {
    try {
      xml.closeTag(tag);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  public void emptyTag(final QName tag) throws WebdavException {
    try {
      xml.emptyTag(tag);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  public void emptyTag(final Node nd) throws WebdavException {
    String ns = nd.getNamespaceURI();
    String ln = nd.getLocalName();
    emptyTag(new QName(ns, ln));
  }
  
  public void property(final QName tag, final String val) throws WebdavException {
    try {
      xml.property(tag, val);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  public void cdataProperty(final QName tag, final String attrName, final String attrVal, final String val) throws WebdavException {
    try {
      if (attrName == null) {
        xml.cdataProperty(tag, val);
      }
       else {
        xml.openTagSameLine(tag, attrName, attrVal);
        xml.cdataValue(val);
        xml.closeTagSameLine(tag);
      }
      
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  public void property(final QName tag, final Reader val) throws WebdavException {
    try {
      xml.property(tag, val);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  public void propertyTagVal(final QName tag, final QName tagVal) throws WebdavException {
    try {
      xml.propertyTagVal(tag, tagVal);
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
  protected void flush() throws WebdavException {
    try {
      xml.flush();
    }
     catch (Throwable t) {
      throw new WebdavException(t);
    }
    
  }
  
}


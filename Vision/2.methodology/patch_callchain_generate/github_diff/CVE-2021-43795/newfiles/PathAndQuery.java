package com.linecorp.armeria.internal.common;
import static io.netty.util.internal.StringUtil.decodeHexNibble;
import static java.util.Objects.requireNonNull;
import java.util.BitSet;
import java.util.Objects;
import java.util.Set;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.annotations.VisibleForTesting;
import com.linecorp.armeria.common.Flags;
import com.linecorp.armeria.common.annotation.Nullable;
import com.linecorp.armeria.common.metric.MeterIdPrefix;
import com.linecorp.armeria.internal.common.metric.CaffeineMetricSupport;
import io.micrometer.core.instrument.MeterRegistry;
import it.unimi.dsi.fastutil.Arrays;
import it.unimi.dsi.fastutil.bytes.ByteArrays;
public final class PathAndQuery {
    private static final PathAndQuery ROOT_PATH_QUERY = new PathAndQuery("/", null);
    private static final BitSet ALLOWED_PATH_CHARS = new BitSet();
    private static final BitSet ALLOWED_QUERY_CHARS = new BitSet();
    private static final BitSet RESERVED_CHARS = new BitSet();
    private static final char[][] TO_PERCENT_ENCODED_CHARS = new char[256][];
    static {
        final String allowedPathChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=";
        for (int i = 0; i < allowedPathChars.length(); i++) {
            ALLOWED_PATH_CHARS.set(allowedPathChars.charAt(i));
        }
        
        final String allowedQueryChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*,;=";
        for (int i = 0; i < allowedQueryChars.length(); i++) {
            ALLOWED_QUERY_CHARS.set(allowedQueryChars.charAt(i));
        }
        
        final String reservedChars = ":/?#[]@!$&'()*+,;=";
        for (int i = 0; i < reservedChars.length(); i++) {
            RESERVED_CHARS.set(reservedChars.charAt(i));
        }
        
        for (int i = 0; i < TO_PERCENT_ENCODED_CHARS.length; i++) {
            TO_PERCENT_ENCODED_CHARS[i] = String.format("%%%02X", i).toCharArray();
        }
        
    }
    
    private static final Bytes EMPTY_QUERY = new Bytes(0);
    private static final Bytes ROOT_PATH = new Bytes(new byte[] { '/' });
    @Nullable
    private static final Cache<String, PathAndQuery> CACHE = Flags.parsedPathCacheSpec() != null ? buildCache(Flags.parsedPathCacheSpec()) : null;
    private static Cache<String, PathAndQuery> buildCache(String spec) {
        return Caffeine.from(spec).build();
    }
    
    public static void registerMetrics(MeterRegistry registry, MeterIdPrefix idPrefix) {
        if (CACHE != null) {
            CaffeineMetricSupport.setup(registry, idPrefix, CACHE);
        }
        
    }
    
    @VisibleForTesting
    public static void clearCachedPaths() {
        requireNonNull(CACHE, "CACHE");
        CACHE.asMap().clear();
    }
    
    @VisibleForTesting
    public static Set<String> cachedPaths() {
        requireNonNull(CACHE, "CACHE");
        return CACHE.asMap().keySet();
    }
    
    @Nullable
    public static PathAndQuery parse(@Nullable String rawPath) {
        if (CACHE != null && rawPath != null) {
            final PathAndQuery parsed = CACHE.getIfPresent(rawPath);
            if (parsed != null) {
                return parsed;
            }
            
        }
        
        return splitPathAndQuery(rawPath);
    }
    
    public void storeInCache(@Nullable String rawPath) {
        if (CACHE != null && !cached && rawPath != null) {
            cached = true;
            CACHE.put(rawPath, this);
        }
        
    }
    
    private final String path;
    @Nullable
    private final String query;
    private boolean cached;
    private PathAndQuery(String path, @Nullable String query) {
        this.path = path;
        this.query = query;
    }
    
    public String path() {
        return path;
    }
    
    @Nullable
    public String query() {
        return query;
    }
    
    @Override
    public boolean equals(@Nullable Object o) {
        if (this == o) {
            return true;
        }
        
        if (!(o instanceof PathAndQuery)) {
            return false;
        }
        
        final PathAndQuery that = (PathAndQuery) o;
        return Objects.equals(path, that.path) && Objects.equals(query, that.query);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(path, query);
    }
    
    @Override
    public String toString() {
        if (query == null) {
            return path;
        }
        
        return path + '?' + query;
    }
    
    @Nullable
    private static PathAndQuery splitPathAndQuery(@Nullable final String pathAndQuery) {
        final Bytes path;
        final Bytes query;
        if (pathAndQuery == null) {
            return ROOT_PATH_QUERY;
        }
        
        final int queryPos = pathAndQuery.indexOf('?');
        if (queryPos >= 0) {
            if ((path = decodePercentsAndEncodeToUtf8( pathAndQuery, 0, queryPos, true)) == null) {
                return null;
            }
            
            if ((query = decodePercentsAndEncodeToUtf8( pathAndQuery, queryPos + 1, pathAndQuery.length(), false)) == null) {
                return null;
            }
            
        }
         else {
            if ((path = decodePercentsAndEncodeToUtf8( pathAndQuery, 0, pathAndQuery.length(), true)) == null) {
                return null;
            }
            
            query = null;
        }
        
        if (path.data[0] != '/' || path.isEncoded(0)) {
            return null;
        }
        
        if (pathContainsDoubleDots(path) || queryContainsDoubleDots(query)) {
            return null;
        }
        
        return new PathAndQuery(encodePathToPercents(path), encodeQueryToPercents(query));
    }
    
    @Nullable
    private static Bytes decodePercentsAndEncodeToUtf8(String value, int start, int end, boolean isPath) {
        final int length = end - start;
        if (length == 0) {
            return isPath ? ROOT_PATH : EMPTY_QUERY;
        }
        
        final Bytes buf = new Bytes(Math.max(length * 3 / 2, 4));
        boolean wasSlash = false;
        for (final CodePointIterator i = new CodePointIterator(value, start, end); i.hasNextCodePoint();) {             final int pos = i.position();
            final int cp = i.nextCodePoint();
            if (cp == '%') {
                final int hexEnd = pos + 3;
                if (hexEnd > end) {
                    return null;
                }
                
                final int digit1 = decodeHexNibble(value.charAt(pos + 1));
                final int digit2 = decodeHexNibble(value.charAt(pos + 2));
                if (digit1 < 0 || digit2 < 0) {
                    return null;
                }
                
                final int decoded = (digit1 << 4) | digit2;
                if (isPath) {
                    if (decoded == '/') {
                        buf.ensure(1);
                        buf.addEncoded((byte) '/');
                        wasSlash = false;
                    }
                     else {
                        if (appendOneByte(buf, decoded, wasSlash, isPath)) {
                            wasSlash = false;
                        }
                         else {
                            return null;
                        }
                        
                    }
                    
                }
                 else {
                    if (RESERVED_CHARS.get(decoded)) {
                        buf.ensure(1);
                        buf.addEncoded((byte) decoded);
                        wasSlash = false;
                    }
                     else if (appendOneByte(buf, decoded, wasSlash, isPath)) {
                        wasSlash = decoded == '/';
                    }
                     else {
                        return null;
                    }
                    
                }
                
                i.position(hexEnd);
                continue;
            }
            
            if (cp == '+' && !isPath) {
                buf.ensure(1);
                buf.addEncoded((byte) ' ');
                wasSlash = false;
                continue;
            }
            
            if (cp <= 0x7F) {
                if (!appendOneByte(buf, cp, wasSlash, isPath)) {
                    return null;
                }
                
                wasSlash = cp == '/';
                continue;
            }
            
            if (cp <= 0x7ff) {
                buf.ensure(2);
                buf.addEncoded((byte) ((cp >>> 6) | 0b110_00000));
                buf.addEncoded((byte) (cp & 0b111111 | 0b10_000000));
            }
             else if (cp <= 0xffff) {
                buf.ensure(3);
                buf.addEncoded((byte) ((cp >>> 12) | 0b1110_0000));
                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));
            }
             else if (cp <= 0x1fffff) {
                buf.ensure(4);
                buf.addEncoded((byte) ((cp >>> 18) | 0b11110_000));
                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));
            }
             else if (cp <= 0x3ffffff) {
                buf.ensure(5);
                buf.addEncoded((byte) ((cp >>> 24) | 0b111110_00));
                buf.addEncoded((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));
            }
             else {
                buf.ensure(6);
                buf.addEncoded((byte) ((cp >>> 30) | 0b1111110_0));
                buf.addEncoded((byte) (((cp >>> 24) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) (((cp >>> 18) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) (((cp >>> 12) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) (((cp >>> 6) & 0b111111) | 0b10_000000));
                buf.addEncoded((byte) ((cp & 0b111111) | 0b10_000000));
            }
            
            wasSlash = false;
        }
        
        return buf;
    }
    
    private static boolean appendOneByte(Bytes buf, int cp, boolean wasSlash, boolean isPath) {
        if (cp == 0x7F) {
            return false;
        }
        
        if (cp >>> 5 == 0) {
            if (isPath) {
                return false;
            }
             else if (cp != 0x0A && cp != 0x0D && cp != 0x09) {
                return false;
            }
            
        }
        
        if (cp == '/' && isPath) {
            if (!wasSlash) {
                buf.ensure(1);
                buf.add((byte) '/');
            }
             else {
            }
            
        }
         else {
            final BitSet allowedChars = isPath ? ALLOWED_PATH_CHARS : ALLOWED_QUERY_CHARS;
            buf.ensure(1);
            if (allowedChars.get(cp)) {
                buf.add((byte) cp);
            }
             else {
                buf.addEncoded((byte) cp);
            }
            
        }
        
        return true;
    }
    
    private static boolean pathContainsDoubleDots(Bytes path) {
        final int length = path.length;
        byte b0 = 0;
        byte b1 = 0;
        byte b2 = '/';
        for (int i = 1; i < length; i++) {
            final byte b3 = path.data[i];
            if (b1 == '.' && b2 == '.' && isSlash(b0) && isSlash(b3)) {
                return true;
            }
            
            b0 = b1;
            b1 = b2;
            b2 = b3;
        }
        
        return b1 == '.' && b2 == '.' && isSlash(b0);
    }
    
    private static boolean queryContainsDoubleDots(@Nullable Bytes query) {
        if (query == null) {
            return false;
        }
        
        final int length = query.length;
        boolean lookingForEquals = true;
        byte b0 = 0;
        byte b1 = 0;
        byte b2 = '/';
        for (int i = 0; i < length; i++) {
            byte b3 = query.data[i];
            switch (b3) {
                case '=':
                    if (lookingForEquals) {
                        lookingForEquals = false;
                        b3 = '/';
                    }
                    
                    break;
                case '&':
                case ';':
                    b3 = '/';
                    lookingForEquals = true;
                    break;
            }
            
            if (b1 == '.' && b2 == '.' && isSlash(b0) && isSlash(b3)) {
                return true;
            }
            
            b0 = b1;
            b1 = b2;
            b2 = b3;
        }
        
        return b1 == '.' && b2 == '.' && isSlash(b0);
    }
    
    private static boolean isSlash(byte b) {
        switch (b) {
            case '/':
            case '\\':
                return true;
            default: return false;
        }
        
    }
    
    private static String encodePathToPercents(Bytes value) {
        if (!value.hasEncodedBytes()) {
            return new String(value.data, 0, 0, value.length);
        }
        
        return slowEncodePathToPercents(value);
    }
    
    @Nullable
    private static String encodeQueryToPercents(@Nullable Bytes value) {
        if (value == null) {
            return null;
        }
        
        if (!value.hasEncodedBytes()) {
            return new String(value.data, 0, 0, value.length);
        }
        
        return slowEncodeQueryToPercents(value);
    }
    
    private static String slowEncodePathToPercents(Bytes value) {
        final int length = value.length;
        final StringBuilder buf = new StringBuilder(length + value.numEncodedBytes() * 2);
        for (int i = 0; i < length; i++) {
            final int b = value.data[i] & 0xFF;
            if (value.isEncoded(i)) {
                buf.append(TO_PERCENT_ENCODED_CHARS[b]);
                continue;
            }
            
            buf.append((char) b);
        }
        
        return buf.toString();
    }
    
    private static String slowEncodeQueryToPercents(Bytes value) {
        final int length = value.length;
        final StringBuilder buf = new StringBuilder(length + value.numEncodedBytes() * 2);
        for (int i = 0; i < length; i++) {
            final int b = value.data[i] & 0xFF;
            if (value.isEncoded(i)) {
                if (b == ' ') {
                    buf.append('+');
                }
                 else {
                    buf.append(TO_PERCENT_ENCODED_CHARS[b]);
                }
                
                continue;
            }
            
            buf.append((char) b);
        }
        
        return buf.toString();
    }
    
    private static final class Bytes {
        byte[] data;
        int length;
        @Nullable
        private BitSet encoded;
        private int numEncodedBytes;
        Bytes(int initialCapacity) {
            data = new byte[initialCapacity];
        }
        
        Bytes(byte[] data) {
            this.data = data;
            length = data.length;
        }
        
        void add(byte b) {
            data[length++] = b;
        }
        
        void addEncoded(byte b) {
            if (encoded == null) {
                encoded = new BitSet();
            }
            
            encoded.set(length);
            data[length++] = b;
            numEncodedBytes++;
        }
        
        boolean isEncoded(int index) {
            return encoded != null && encoded.get(index);
        }
        
        boolean hasEncodedBytes() {
            return encoded != null;
        }
        
        int numEncodedBytes() {
            return numEncodedBytes;
        }
        
        void ensure(int numBytes) {
            int newCapacity = length + numBytes;
            if (newCapacity <= data.length) {
                return;
            }
            
            newCapacity = (int) Math.max(Math.min((long) data.length + (data.length >> 1), Arrays.MAX_ARRAY_SIZE), newCapacity);
            data = ByteArrays.forceCapacity(data, newCapacity, length);
        }
        
    }
    
    private static final class CodePointIterator {
        private final CharSequence str;
        private final int end;
        private int pos;
        CodePointIterator(CharSequence str, int start, int end) {
            this.str = str;
            this.end = end;
            pos = start;
        }
        
        int position() {
            return pos;
        }
        
        void position(int pos) {
            this.pos = pos;
        }
        
        boolean hasNextCodePoint() {
            return pos < end;
        }
        
        int nextCodePoint() {
            assert pos < end;
            final char c1 = str.charAt(pos++);
            if (Character.isHighSurrogate(c1) && pos < end) {
                final char c2 = str.charAt(pos);
                if (Character.isLowSurrogate(c2)) {
                    pos++;
                    return Character.toCodePoint(c1, c2);
                }
                
            }
            
            return c1;
        }
        
    }
    
}


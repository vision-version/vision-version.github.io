package io.github.pixee.security;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
public final class ZipSecurity {
  private ZipSecurity() {}
  public static ZipInputStream createHardenedInputStream( final InputStream stream, final Charset charset) {
    return new HardenedZipInputStream(stream, charset);
  }
  
  public static ZipInputStream createHardenedInputStream(final InputStream stream) {
    return new HardenedZipInputStream(stream);
  }
  
  private static class HardenedZipInputStream extends ZipInputStream {
    private HardenedZipInputStream(final InputStream in) {
      super(in);
    }
    
    private HardenedZipInputStream(final InputStream in, final Charset charset) {
      super(in, charset);
    }
    
    @Override
    public ZipEntry getNextEntry() throws IOException {
      final ZipEntry entry = super.getNextEntry();
      final String name = entry.getName();
      if (!"".equals(name.trim())) {
        if (isRootFileEntry(name)) {
          throw new SecurityException("encountered zip file path that is absolute: " + name);
        }
        
        if (containsEscapesAndTargetsBelowRoot(name)) {
          throw new SecurityException("path to sensitive locations contained escapes: " + name);
        }
        
      }
      
      return entry;
    }
    
    private boolean containsEscapesAndTargetsBelowRoot(final String name) {
      if (name.contains("../") || name.contains("..\\")) {
        try {
          if (isBelowOrSisterToCurrentDirectory(name)) {
            return true;
          }
          
        }
         catch (IOException e) {
        }
        
      }
      
      return false;
    }
    
    private boolean isBelowOrSisterToCurrentDirectory(final String untrustedFileWithEscapes) throws IOException {
      final File currentDirectory = new File("").getCanonicalFile();
      final Path currentPathRoot = currentDirectory.toPath();
      final File untrustedFile = new File(currentDirectory, untrustedFileWithEscapes);
      final Path pathWithEscapes = untrustedFile.getCanonicalFile().toPath();
      return !pathWithEscapes.startsWith(currentPathRoot);
    }
    
    private boolean isRootFileEntry(final String name) {
      return name.startsWith("/");
    }
    
  }
  
}


package jodd.http;
import jodd.net.HttpMethod;
import jodd.net.MimeTypes;
import jodd.util.Base64;
import jodd.util.StringPool;
import jodd.util.StringUtil;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.function.Function;
import static jodd.util.StringPool.CRLF;
import static jodd.util.StringPool.SPACE;
public class HttpRequest extends HttpBase<HttpRequest> {
	protected String protocol = "http";
	protected String host = "localhost";
	protected int port = Defaults.DEFAULT_PORT;
	protected String method = "GET";
	protected String fragment = null;
	protected String path = StringPool.SLASH;
	protected HttpMultiMap<String> query;
	 public HttpRequest() {
		initRequest();
	}
	
	 protected void initRequest() {
		connectionKeepAlive(false);
		if (Defaults.headers.size() > 0) {
			for (Map.Entry<String, String> entry : Defaults.headers) {
				this.headers.add(entry.getKey(), entry.getValue());
			}
			
		}
		
	}
	
	 public String host() {
		return host;
	}
	
	 public HttpRequest host(final String host) {
		this.host = host;
		if (headers.contains(HEADER_HOST)) {
			headerOverwrite(HEADER_HOST, host);
		}
		
		return this;
	}
	
	 public String protocol() {
		return protocol;
	}
	
	 public HttpRequest protocol(final String protocol) {
		this.protocol = protocol;
		return this;
	}
	
	 public int port() {
		if (port == Defaults.DEFAULT_PORT) {
			if (protocol == null) {
				return 80;
			}
			
			if (protocol.equalsIgnoreCase("https")) {
				return 443;
			}
			
			return 80;
		}
		
		return port;
	}
	
	 public HttpRequest port(final int port) {
		this.port = port;
		return this;
	}
	
	 public String fragment() {
		return fragment;
	}
	
	 public HttpRequest set(String destination) {
		destination = destination.trim();
		 int ndx = destination.indexOf(' ');
		if (ndx != -1) {
			final String method = destination.substring(0, ndx).toUpperCase();
			try {
				final HttpMethod httpMethod = HttpMethod.valueOf(method);
				this.method = httpMethod.name();
				destination = destination.substring(ndx + 1);
			}
			
			catch (final IllegalArgumentException ignore) {
				 }
				 
		}
		
		 ndx = destination.indexOf("://");
		if (ndx != -1) {
			protocol = destination.substring(0, ndx);
			destination = destination.substring(ndx + 3);
		}
		
		 ndx = destination.indexOf('/');
		if (ndx == -1) {
			ndx = destination.length();
		}
		
		if (ndx != 0) {
			String hostToSet = destination.substring(0, ndx);
			destination = destination.substring(ndx);
			 ndx = hostToSet.indexOf(':');
			if (ndx == -1) {
				port = Defaults.DEFAULT_PORT;
			}
			 else {
				port = Integer.parseInt(hostToSet.substring(ndx + 1));
				hostToSet = hostToSet.substring(0, ndx);
			}
			
			host(hostToSet);
		}
		
		 path(destination);
		return this;
	}
	
	 public static HttpRequest create(final String method, final String destination) {
		return new HttpRequest() .method(method.toUpperCase()) .set(destination);
	}
	
	 public static HttpRequest connect(final String destination) {
		return new HttpRequest() .method(HttpMethod.CONNECT) .set(destination);
	}
	
	 public static HttpRequest get(final String destination) {
		return new HttpRequest() .method(HttpMethod.GET) .set(destination);
	}
	
	 public static HttpRequest post(final String destination) {
		return new HttpRequest() .method(HttpMethod.POST) .set(destination);
	}
	
	 public static HttpRequest put(final String destination) {
		return new HttpRequest() .method(HttpMethod.PUT) .set(destination);
	}
	
	 public static HttpRequest patch(final String destination) {
		return new HttpRequest() .method(HttpMethod.PATCH) .set(destination);
	}
	
	 public static HttpRequest delete(final String destination) {
		return new HttpRequest() .method(HttpMethod.DELETE) .set(destination);
	}
	
	 public static HttpRequest head(final String destination) {
		return new HttpRequest() .method(HttpMethod.HEAD) .set(destination);
	}
	
	 public static HttpRequest trace(final String destination) {
		return new HttpRequest() .method(HttpMethod.TRACE) .set(destination);
	}
	
	 public static HttpRequest options(final String destination) {
		return new HttpRequest() .method(HttpMethod.OPTIONS) .set(destination);
	}
	
	 public String method() {
		return method;
	}
	
	 public HttpRequest method(final String method) {
		this.method = method.toUpperCase();
		return this;
	}
	
	public HttpRequest method(final HttpMethod httpMethod) {
		this.method = httpMethod.name();
		return this;
	}
	
	 public String path() {
		return path;
	}
	
	 public HttpRequest path(String path){
		 if (!path.startsWith(StringPool.SLASH)) {
			path = StringPool.SLASH + path;
		}
		
		try {
			 final int fragmentIndex = path.indexOf('#');
			if (path.indexOf('#') != -1) {
				this.fragment = URLEncoder.encode(path.substring(fragmentIndex + 1), StandardCharsets.UTF_8.name());
				path = path.substring(0, fragmentIndex);
			}
			
			final int ndx = path.indexOf('?');
			if (ndx != -1) {
				final String queryString = path.substring(ndx + 1);
				path = URLEncoder.encode(path.substring(0, ndx), StandardCharsets.UTF_8.name());
				query = HttpUtil.parseQuery(queryString, true);
			}
			 else {
				query = HttpMultiMap.newCaseInsensitiveMap();
			}
			
			this.path = URLEncoder.encode(path, StandardCharsets.UTF_8.name());
			;
		}
		catch (UnsupportedEncodingException e) {
			return null;
		}
		
		return this;
	}
	
	 public HttpRequest multipart(final boolean multipart) {
		this.multipart = multipart;
		return this;
	}
	
	 public HttpRequest cookies(final Cookie... cookies) {
		if (cookies.length == 0) {
			return this;
		}
		
		final StringBuilder cookieString = new StringBuilder();
		boolean first = true;
		for (final Cookie cookie : cookies) {
			final Integer maxAge = cookie.getMaxAge();
			if (maxAge != null && maxAge.intValue() == 0) {
				continue;
			}
			
			if (!first) {
				cookieString.append("; ");
			}
			
			first = false;
			cookieString.append(cookie.getName());
			cookieString.append('=');
			cookieString.append(cookie.getValue());
		}
		
		headerOverwrite("cookie", cookieString.toString());
		return this;
	}
	
	 public HttpRequest query(final String name, final String value) {
		query.add(name, value);
		return this;
	}
	
	 public HttpRequest query(final String name1, final Object value1, final Object... parameters) {
		query(name1, value1 == null ? null : value1.toString());
		for (int i = 0; i < parameters.length; i += 2) {
			final String name = parameters[i].toString();
			final String value = parameters[i + 1].toString();
			query.add(name, value);
		}
		
		return this;
	}
	
	 public HttpRequest query(final Map<String, String> queryMap) {
		for (final Map.Entry<String, String> entry : queryMap.entrySet()) {
			query.add(entry.getKey(), entry.getValue());
		}
		
		return this;
	}
	
	 public HttpMultiMap<String> query() {
		return query;
	}
	
	 public HttpRequest clearQueries() {
		query.clear();
		return this;
	}
	
	 public HttpRequest queryRemove(final String name) {
		query.remove(name);
		return this;
	}
	
	 public HttpRequest queryString(final String queryString) {
		return queryString(queryString, true);
	}
	
	 public HttpRequest queryString(final String queryString, final boolean decode) {
		this.query = HttpUtil.parseQuery(queryString, decode);
		return this;
	}
	
	 public String queryString() {
		if (query == null) {
			return StringPool.EMPTY;
		}
		
		return HttpUtil.buildQuery(query, queryEncoding);
	}
	
	 protected String queryEncoding = Defaults.queryEncoding;
	 public HttpRequest queryEncoding(final String encoding) {
		this.queryEncoding = encoding;
		return this;
	}
	
	 public String url() {
		final StringBuilder url = new StringBuilder();
		url.append(hostUrl());
		if (path != null) {
			url.append(path);
		}
		
		final String queryString = queryString();
		if (StringUtil.isNotBlank(queryString)) {
			url.append('?');
			url.append(queryString);
		}
		
		if (fragment != null) {
			url.append('#');
			url.append(fragment);
		}
		
		return url.toString();
	}
	
	 public String hostUrl() {
		final StringBuilder url = new StringBuilder();
		if (protocol != null) {
			url.append(protocol);
			url.append("://");
		}
		
		if (host != null) {
			url.append(host);
		}
		
		if (port != Defaults.DEFAULT_PORT) {
			url.append(':');
			url.append(port);
		}
		
		return url.toString();
	}
	
	 public HttpRequest basicAuthentication(final String username, final String password) {
		if (username != null && password != null) {
			final String data = username.concat(StringPool.COLON).concat(password);
			final String base64 = Base64.encodeToString(data);
			headerOverwrite(HEADER_AUTHORIZATION, "Basic " + base64);
		}
		
		return this;
	}
	
	 public HttpRequest tokenAuthentication(final String token) {
		if (token != null) {
			headerOverwrite(HEADER_AUTHORIZATION, "Bearer " + token);
		}
		
		return this;
	}
	
	 private boolean trustAllCertificates;
	private boolean verifyHttpsHost = true;
	 public HttpRequest trustAllCerts(final boolean trust) {
		trustAllCertificates = trust;
		return this;
	}
	
	 public boolean trustAllCertificates() {
		return trustAllCertificates;
	}
	
	 public HttpRequest verifyHttpsHost(final boolean verifyHttpsHost) {
		this.verifyHttpsHost = verifyHttpsHost;
		return this;
	}
	
	 public boolean verifyHttpsHost() {
		return verifyHttpsHost;
	}
	
	 public HttpRequest setHostHeader() {
		String hostPort = this.host;
		if (port != Defaults.DEFAULT_PORT) {
			hostPort += StringPool.COLON + port;
		}
		
		headerOverwrite(HEADER_HOST, hostPort);
		return this;
	}
	
	 public HttpRequest monitor(final HttpProgressListener httpProgressListener) {
		this.httpProgressListener = httpProgressListener;
		return this;
	}
	
	 protected int timeout = -1;
	protected int connectTimeout = -1;
	protected boolean followRedirects = false;
	protected int maxRedirects = 50;
	 public HttpRequest timeout(final int milliseconds) {
		this.timeout = milliseconds;
		return this;
	}
	
	 public int timeout() {
		return timeout;
	}
	
	 public HttpRequest connectionTimeout(final int milliseconds) {
		this.connectTimeout = milliseconds;
		return this;
	}
	
	 public int connectionTimeout() {
		return connectTimeout;
	}
	
	 public HttpRequest followRedirects(final boolean followRedirects) {
		this.followRedirects = followRedirects;
		return this;
	}
	
	 public boolean isFollowRedirects() {
		return this.followRedirects;
	}
	
	 public HttpRequest maxRedirects(final int maxRedirects) {
		this.maxRedirects = maxRedirects;
		return this;
	}
	
	 public int maxRedirects() {
		return this.maxRedirects;
	}
	
	 protected HttpConnection httpConnection;
	protected HttpConnectionProvider httpConnectionProvider;
	 public HttpRequest withConnectionProvider(final HttpConnectionProvider httpConnectionProvider) {
		this.httpConnectionProvider = httpConnectionProvider;
		return this;
	}
	
	 public HttpConnectionProvider connectionProvider() {
		return httpConnectionProvider;
	}
	
	 public HttpConnection connection() {
		return httpConnection;
	}
	
	 public HttpRequest open() {
		if (httpConnectionProvider == null) {
			return open(HttpConnectionProvider.get());
		}
		
		return open(httpConnectionProvider);
	}
	
	 public HttpRequest open(final HttpConnectionProvider httpConnectionProvider) {
		if (this.httpConnection != null) {
			throw new HttpException("Connection already opened");
		}
		
		try {
			this.httpConnectionProvider = httpConnectionProvider;
			this.httpConnection = httpConnectionProvider.createHttpConnection(this);
		}
		 catch (final IOException ioex) {
			throw new HttpException("Can't connect to: " + url(), ioex);
		}
		
		return this;
	}
	
	 public HttpRequest open(final HttpConnection httpConnection) {
		if (this.httpConnection != null) {
			throw new HttpException("Connection already opened");
		}
		
		this.httpConnection = httpConnection;
		this.httpConnectionProvider = null;
		return this;
	}
	
	 public HttpRequest keepAlive(final HttpResponse httpResponse, final boolean doContinue) {
		boolean keepAlive = httpResponse.isConnectionPersistent();
		if (keepAlive) {
			final HttpConnection previousConnection = httpResponse.getHttpRequest().httpConnection;
			if (previousConnection != null) {
				 this.httpConnection = previousConnection;
				this.httpConnectionProvider = httpResponse.getHttpRequest().connectionProvider();
			}
			
			 }
			  else {
			 httpResponse.close();
			 keepAlive = true;
		}
		
		 if (!doContinue) {
			keepAlive = false;
		}
		
		connectionKeepAlive(keepAlive);
		 if (httpConnection == null) {
			open(httpResponse.getHttpRequest().connectionProvider());
		}
		
		return this;
	}
	
	 public HttpResponse send() {
		if (!followRedirects) {
			return _send();
		}
		
		int redirects = this.maxRedirects;
		while (redirects > 0) {
			redirects--;
			final HttpResponse httpResponse = _send();
			final int statusCode = httpResponse.statusCode();
			if (HttpStatus.isRedirect(statusCode)) {
				_reset();
				final String location = httpResponse.location();
				if (location == null) {
					return httpResponse;
				}
				
				set(location);
				continue;
			}
			
			return httpResponse;
		}
		
		throw new HttpException("Max number of redirects exceeded: " + this.maxRedirects);
	}
	
	 private void _reset() {
		headers.remove(HEADER_HOST);
	}
	
	private HttpResponse _send() {
		if (httpConnection == null) {
			open();
		}
		
		 final HttpResponse httpResponse;
		try {
			final OutputStream outputStream = httpConnection.getOutputStream();
			sendTo(outputStream);
			final InputStream inputStream = httpConnection.getInputStream();
			httpResponse = HttpResponse.readFrom(inputStream);
			httpResponse.assignHttpRequest(this);
		}
		 catch (final IOException ioex) {
			throw new HttpException(ioex);
		}
		
		final boolean keepAlive = httpResponse.isConnectionPersistent();
		if (!keepAlive) {
			 httpConnection.close();
			httpConnection = null;
		}
		
		return httpResponse;
	}
	
	 @Override
	protected Buffer buffer(final boolean fullRequest) {
		 if (header(HEADER_HOST) == null) {
			setHostHeader();
		}
		
		 final Buffer formBuffer = formBuffer();
		 final String queryString = queryString();
		 if (method.equals("POST") && (contentLength() == null)) {
			contentLength(0);
		}
		
		 final Buffer request = new Buffer();
		request.append(method) .append(SPACE) .append(path);
		if (query != null && !query.isEmpty()) {
			request.append('?');
			request.append(queryString);
		}
		
		request.append(SPACE) .append(httpVersion) .append(CRLF);
		populateHeaderAndBody(request, formBuffer, fullRequest);
		return request;
	}
	
	 public static HttpRequest readFrom(final InputStream in) {
		return readFrom(in, StandardCharsets.ISO_8859_1.name());
	}
	
	public static HttpRequest readFrom(final InputStream in, final String encoding) {
		final BufferedReader reader;
		try {
			reader = new BufferedReader(new InputStreamReader(in, encoding));
		}
		 catch (final UnsupportedEncodingException uneex) {
			return null;
		}
		
		final HttpRequest httpRequest = new HttpRequest();
		httpRequest.headers.clear();
		final String line;
		try {
			line = reader.readLine();
		}
		 catch (final IOException ioex) {
			throw new HttpException(ioex);
		}
		
		if (!StringUtil.isBlank(line)) {
			final String[] s = StringUtil.splitc(line, ' ');
			httpRequest.method(s[0]);
			httpRequest.path(s[1]);
			httpRequest.httpVersion(s[2]);
			httpRequest.readHeaders(reader);
			httpRequest.readBody(reader);
		}
		
		return httpRequest;
	}
	
	 public HttpRequest contentTypeJson() {
		return contentType(MimeTypes.MIME_APPLICATION_JSON);
	}
	
	 public HttpRequest acceptJson() {
		return accept(MimeTypes.MIME_APPLICATION_JSON);
	}
	
	 public CompletableFuture<HttpResponse> sendAsync() {
		return CompletableFuture.supplyAsync(this::send);
	}
	
	 public <R> R sendAndReceive(final Function<HttpResponse, R> responseHandler) {
		return responseHandler.apply(send());
	}
	
	 public void sendAndReceive(final Consumer<HttpResponse> responseHandler) {
		responseHandler.accept(send());
	}
	
}


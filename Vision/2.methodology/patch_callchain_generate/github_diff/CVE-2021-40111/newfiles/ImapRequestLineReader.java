package org.apache.james.imap.decode;
import static java.nio.charset.StandardCharsets.US_ASCII;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CodingErrorAction;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import javax.mail.Flags;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.james.imap.api.ImapConstants;
import org.apache.james.imap.api.Tag;
import org.apache.james.imap.api.display.HumanReadableText;
import org.apache.james.imap.api.display.ModifiedUtf7;
import org.apache.james.imap.api.message.IdRange;
import org.apache.james.imap.api.message.UidRange;
import org.apache.james.imap.api.message.request.DayMonthYear;
import org.apache.james.imap.api.process.ImapSession;
import org.apache.james.imap.api.process.SearchResUtil;
import org.apache.james.imap.message.Literal;
import org.apache.james.mailbox.MessageUid;
public abstract class ImapRequestLineReader {
    private static final int QUOTED_BUFFER_INITIAL_CAPACITY = 64;
    protected boolean nextSeen = false;
    protected char nextChar; 
    public static int cap(char next) {
        return next > 'Z' ? next ^ 32 : next;
    }
    
    public char nextWordChar() throws DecodingException {
        char next = nextChar();
        while (next == ' ') {
            consume();
            next = nextChar();
        }
        
        if (next == '\r' || next == '\n') {
            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Missing argument.");
        }
        
        return next;
    }
    
    public abstract char nextChar() throws DecodingException;
    public void eol() throws DecodingException {
        char next = nextChar();
        while (next == ' ') {
            consume();
            next = nextChar();
        }
        
        if (next == '\r') {
            consume();
            next = nextChar();
        }
        
        if (next != '\n') {
            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Expected end-of-line, found '" + (char) next + "'.");
        }
        
    }
    
    public char consume() throws DecodingException {
        char current = nextChar();
        nextSeen = false;
        nextChar = 0;
        return current;
    }
    
    public abstract Literal read(int size, boolean extraCRLF) throws IOException;
    protected abstract void commandContinuationRequest() throws DecodingException;
    public void consumeLine() throws DecodingException {
        char next = nextChar();
        while (next != '\n') {
            consume();
            next = nextChar();
        }
        
        consume();
    }
    
    public String atom() throws DecodingException {
        return consumeWord(new AtomCharValidator(), true);
    }
    
    public Tag tag() throws DecodingException {
        CharacterValidator validator = new TagCharValidator();
        return new Tag(consumeWord(validator));
    }
    
    public String astring() throws DecodingException {
        return astring(null);
    }
    
    public String astring(Charset charset) throws DecodingException {
        char next = nextWordChar();
        switch (next) {
        case '"':
            return consumeQuoted(charset);
        case '{':
            return consumeLiteral(charset);
        default: return atom();
        }
        
    }
    
    public String nstring() throws DecodingException {
        char next = nextWordChar();
        switch (next) {
        case '"':
            return consumeQuoted();
        case '{':
            return consumeLiteral(null);
        default: String value = atom();
            if ("NIL".equals(value)) {
                return null;
            }
             else {
                throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Invalid nstring value: valid values are '\"...\"', '{12} CRLF *CHAR8', and 'NIL'.");
            }
            
        }
        
    }
    
    public String mailbox() throws DecodingException {
       return ModifiedUtf7.decodeModifiedUTF7(mailboxUTF7());
    }
    
    public String mailboxUTF7() throws DecodingException {
        String mailbox = astring();
        if (mailbox.equalsIgnoreCase(ImapConstants.INBOX_NAME)) {
            return ImapConstants.INBOX_NAME;
        }
         else {
            return mailbox;
        }
        
    }
    
    public DayMonthYear date() throws DecodingException {
        final char one = consume();
        final char two = consume();
        final int day;
        if (two == '-') {
            day = DecoderUtils.decodeFixedDay(' ', one);
        }
         else {
            day = DecoderUtils.decodeFixedDay(one, two);
            nextIsDash();
        }
        
        final char monthFirstChar = consume();
        final char monthSecondChar = consume();
        final char monthThirdChar = consume();
        final int month = DecoderUtils.decodeMonth(monthFirstChar, monthSecondChar, monthThirdChar) + 1;
        nextIsDash();
        final char milleniumChar = consume();
        final char centuryChar = consume();
        final char decadeChar = consume();
        final char yearChar = consume();
        final int year = DecoderUtils.decodeYear(milleniumChar, centuryChar, decadeChar, yearChar);
        return new DayMonthYear(day, month, year);
    }
    
    private void nextIsDash() throws DecodingException {
        final char next = consume();
        if (next != '-') {
            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Expected dash but was " + next);
        }
        
    }
    
    public LocalDateTime dateTime() throws DecodingException {
        char next = nextWordChar();
        String dateString;
        if (next == '"') {
            dateString = consumeQuoted();
        }
         else {
            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "DateTime values must be quoted.");
        }
        
        return DecoderUtils.decodeDateTime(dateString);
    }
    
    public String consumeWord(CharacterValidator validator) throws DecodingException {
        return consumeWord(validator, false);
    }
    
    private String consumeWord(CharacterValidator validator, boolean stripParen) throws DecodingException {
        StringBuilder atom = new StringBuilder();
        char next = nextWordChar();
        while (!isWhitespace(next) && (stripParen == false || next != ')')) { if (validator.isValid(next)) { if (stripParen == false || next != '(') {
                    atom.append(next);
                }
                
                consume();
            }
             else {
                throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Invalid character: '" + next + "'");
            }
            
            next = nextChar();
        }
        
        return atom.toString();
    }
    
    private static boolean isWhitespace(char next) {
        return (next == ' ' || next == '\n' || next == '\r' || next == '\t');
    }
    
    public String consumeLiteral(Charset charset) throws DecodingException {
        if (charset == null) {
            return consumeLiteral(US_ASCII);
        }
         else {
            try {
                ImmutablePair<Integer, Literal> literal = consumeLiteral(false);
                try (InputStream in = literal.right.getInputStream()) {
                    Integer size = literal.left;
                    byte[] data = IOUtils.readFully(in, size);
                    ByteBuffer buffer = ByteBuffer.wrap(data);
                    return decode(charset, buffer);
                }
                 catch (IOException e) {
                    throw new DecodingException(HumanReadableText.BAD_IO_ENCODING, "Bad character encoding", e);
                }
                 finally {
                    if (literal.right instanceof Closeable) {
                        try {
                            ((Closeable) literal.right).close();
                        }
                         catch (IOException e) {
                        }
                        
                    }
                    
                }
                
            }
             catch (IOException e) {
                throw new DecodingException(HumanReadableText.SOCKET_IO_FAILURE, "Could not read literal", e);
            }
            
        }
        
    }
    
    public ImmutablePair<Integer, Literal> consumeLiteral(boolean extraCRLF) throws IOException {
        consumeChar('{');
        StringBuilder digits = new StringBuilder();
        char next = nextChar();
        while (next != '}' && next != '+') {
            digits.append(next);
            consume();
            next = nextChar();
        }
        
        boolean synchronizedLiteral = true;
        if (next == '+') {
            synchronizedLiteral = false;
            consumeChar('+');
        }
        
        consumeChar('}');
        consumeCRLF();
        if (synchronizedLiteral) {
            commandContinuationRequest();
        }
        
        int size = Integer.parseInt(digits.toString());
        return ImmutablePair.of(size, read(size, extraCRLF));
    }
    
    private String decode(Charset charset, ByteBuffer buffer) throws DecodingException {
        try {
            return charset.newDecoder().onMalformedInput(CodingErrorAction.REPORT).onUnmappableCharacter(CodingErrorAction.REPORT).decode(buffer).toString();
        }
         catch (IllegalStateException | CharacterCodingException e) {
            throw new DecodingException(HumanReadableText.BAD_IO_ENCODING, "Bad character encoding", e);
        }
        
    }
    
    private void consumeCRLF() throws DecodingException {
        char next = nextChar();
        if (next != '\n') {
            consumeChar('\r');
        }
        
        consumeChar('\n');
    }
    
    public void consumeChar(char expected) throws DecodingException {
        char consumed = consume();
        if (consumed != expected) {
            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Expected:'" + expected + "' found:'" + consumed + "'");
        }
        
    }
    
    public String consumeQuoted() throws DecodingException {
        return consumeQuoted(null);
    }
    
    protected String consumeQuoted(Charset charset) throws DecodingException {
        if (charset == null) {
            return consumeQuoted(US_ASCII);
        }
         else {
            consumeChar('"');
            final QuotedStringDecoder decoder = new QuotedStringDecoder(charset);
            final String result = decoder.decode(this);
            consumeChar('"');
            return result;
        }
        
    }
    
    public Flags flagList() throws DecodingException {
        Flags flags = new Flags();
        nextWordChar();
        consumeChar('(');
        CharacterValidator validator = new NoopCharValidator();
        String nextWord = consumeWord(validator);
        while (!nextWord.endsWith(")")) {
            DecoderUtils.setFlag(nextWord, flags);
            nextWord = consumeWord(validator);
            if (nextWord.isEmpty()) {
                throw new DecodingException(HumanReadableText.FAILED, "Empty word encountered");
            }
            
        }
        
        if (nextWord.length() > 1) {
            int parenIndex = nextWord.indexOf(')');
            if (parenIndex > 0) {
                final String nextFlag = nextWord.substring(0, parenIndex);
                DecoderUtils.setFlag(nextFlag, flags);
            }
            
        }
        
        return flags;
    }
    
    public Flags flag() throws DecodingException {
        Flags flags = new Flags();
        nextWordChar();
        CharacterValidator validator = new NoopCharValidator();
        String nextFlag = consumeWord(validator);
        DecoderUtils.setFlag(nextFlag, flags);
        return flags;
    }
    
    public long number() throws DecodingException {
        return number(false);
    }
    
    public long number(boolean stopOnParen) throws DecodingException {
        return readDigits(0, 0, true, stopOnParen);
    }
    
    private long readDigits(int add, long total, boolean first, boolean stopOnParen ) throws DecodingException {
        final char next;
        if (first) {
            next = nextWordChar();
        }
         else {
            consume();
            next = nextChar();
        }
        
        final long currentTotal = (10 * total) + add;
        switch (next) {
        case '0':
            return readDigits(0, currentTotal, false, stopOnParen);
        case '1':
            return readDigits(1, currentTotal, false, stopOnParen);
        case '2':
            return readDigits(2, currentTotal, false, stopOnParen);
        case '3':
            return readDigits(3, currentTotal, false, stopOnParen);
        case '4':
            return readDigits(4, currentTotal, false, stopOnParen);
        case '5':
            return readDigits(5, currentTotal, false, stopOnParen);
        case '6':
            return readDigits(6, currentTotal, false, stopOnParen);
        case '7':
            return readDigits(7, currentTotal, false, stopOnParen);
        case '8':
            return readDigits(8, currentTotal, false, stopOnParen);
        case '9':
            return readDigits(9, currentTotal, false, stopOnParen);
        case '.':
        case ' ':
        case '>':
        case '\r':
        case '\n':
        case '\t':
            return currentTotal;
        case ')':
            if (stopOnParen) {
                return currentTotal;
            }
             else {
                throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Expected a digit but was " + next);
            }
            
        default: throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Expected a digit but was " + next);
        }
        
    }
    
    public long nzNumber() throws DecodingException {
        long number = number();
        if (number == 0) {
            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Zero value not permitted.");
        }
        
        return number;
    }
    
    public static boolean isCHAR(char chr) {
        return (chr >= 0x01 && chr <= 0x7f);
    }
    
    public static boolean isListWildcard(char chr) {
        return (chr == '*' || chr == '%');
    }
    
    public static boolean isQuotedSpecial(char chr) {
        return (chr == '"' || chr == '\\');
    }
    
    public IdRange[] parseIdRange() throws DecodingException {
        return parseIdRange(null);
    }
    
    public IdRange[] parseIdRange(ImapSession session) throws DecodingException {
        if (session != null) {
            char c = nextWordChar();
            if (c == '$') {
                consume();
                return SearchResUtil.getSavedSequenceSet(session);
            }
            
        }
        
        CharacterValidator validator = new MessageSetCharValidator();
        String nextWord = consumeWord(validator, true);
        int commaPos = nextWord.indexOf(',');
        if (commaPos == -1) {
            return new IdRange[] { parseRange(nextWord) };
        }
        
        ArrayList<IdRange> rangeList = new ArrayList<>();
        int pos = 0;
        while (commaPos != -1) {
            String range = nextWord.substring(pos, commaPos);
            IdRange set = parseRange(range);
            rangeList.add(set);
            pos = commaPos + 1;
            commaPos = nextWord.indexOf(',', pos);
        }
        
        String range = nextWord.substring(pos);
        rangeList.add(parseRange(range));
        List<IdRange> merged = IdRange.mergeRanges(rangeList);
        return merged.toArray(IdRange[]::new);
    }
    
    public UidRange[] parseUidRange() throws DecodingException {
        CharacterValidator validator = new MessageSetCharValidator();
        String nextWord = consumeWord(validator, true);
        int commaPos = nextWord.indexOf(',');
        if (commaPos == -1) {
            return new UidRange[] { parseUidRange(nextWord) };
        }
        
        ArrayList<UidRange> rangeList = new ArrayList<>();
        int pos = 0;
        while (commaPos != -1) {
            String range = nextWord.substring(pos, commaPos);
            UidRange set = parseUidRange(range);
            rangeList.add(set);
            pos = commaPos + 1;
            commaPos = nextWord.indexOf(',', pos);
        }
        
        String range = nextWord.substring(pos);
        rangeList.add(parseUidRange(range));
        List<UidRange> merged = UidRange.mergeRanges(rangeList);
        return merged.toArray(UidRange[]::new);
    }
    
    public char nextNonSpaceChar() throws DecodingException {
        char next = nextChar();
        while (next == ' ') {
            consume();
            next = nextChar();
        }
        
        return next;
    }
    
    private IdRange parseRange(String range) throws DecodingException {
        int pos = range.indexOf(':');
        try {
            if (pos == -1) {
                if (range.length() == 1 && range.charAt(0) == '*') {
                    return new IdRange(Long.MAX_VALUE, Long.MAX_VALUE);
                }
                 else {
                    long value = parseUnsignedInteger(range);
                    return new IdRange(value);
                }
                
            }
             else {
                long val1 = parseUnsignedInteger(range.substring(0, pos));
                long val2 = parseUnsignedInteger(range.substring(pos + 1));
                if (val1 == Long.MAX_VALUE && val2 == Long.MAX_VALUE) {
                    return new IdRange(Long.MAX_VALUE, Long.MAX_VALUE);
                }
                 else if (val1 <= val2) {
                    return new IdRange(val1, val2);
                }
                 else if (val1 == Long.MAX_VALUE) {
                    return new IdRange(val2, Long.MAX_VALUE);
                }
                 else {
                    return new IdRange(val2, val1);
                }
                
            }
            
        }
         catch (NumberFormatException e) {
            throw new DecodingException(HumanReadableText.INVALID_MESSAGESET, "Invalid message set.", e);
        }
        
    }
    
    private UidRange parseUidRange(String range) throws DecodingException {
        int pos = range.indexOf(':');
        try {
            if (pos == -1) {
                if (range.length() == 1 && range.charAt(0) == '*') {
                    return new UidRange(MessageUid.MAX_VALUE);
                }
                 else {
                    long value = parseUnsignedInteger(range);
                    return new UidRange(MessageUid.of(value));
                }
                
            }
             else {
                long val1 = parseUnsignedInteger(range.substring(0, pos));
                long val2 = parseUnsignedInteger(range.substring(pos + 1));
                if (val1 == Long.MAX_VALUE && val2 == Long.MAX_VALUE) {
                    return new UidRange(MessageUid.MAX_VALUE);
                }
                 else if (val1 <= val2) {
                    return new UidRange(MessageUid.of(val1), MessageUid.of(val2));
                }
                 else if (val1 == Long.MAX_VALUE) {
                    return new UidRange(MessageUid.of(val2), MessageUid.MAX_VALUE);
                }
                 else {
                    return new UidRange(MessageUid.of(val2), MessageUid.of(val1));
                }
                
            }
            
        }
         catch (NumberFormatException e) {
            throw new DecodingException(HumanReadableText.INVALID_MESSAGESET, "Invalid message set.", e);
        }
        
    }
    
    private long parseUnsignedInteger(String value) throws DecodingException {
        if (value.length() == 1 && value.charAt(0) == '*') {
            return Long.MAX_VALUE;
        }
         else {
            long number = Long.parseLong(value);
            if (number < ImapConstants.MIN_NZ_NUMBER || number > ImapConstants.MAX_NZ_NUMBER) {
                throw new DecodingException(HumanReadableText.INVALID_MESSAGESET, "Invalid message set. Numbers must be unsigned 32-bit Integers");
            }
            
            return number;
        }
        
    }
    
    public interface CharacterValidator {
        boolean isValid(char chr);
    }
    
    public static class StringMatcherCharacterValidator implements CharacterValidator {
        public static StringMatcherCharacterValidator ignoreCase(String expectedString) {
            return new StringMatcherCharacterValidator(expectedString);
        }
        
        static boolean asciiEqualsIgnoringCase(Character c1, Character c2) {
            return Character.toUpperCase(c1) == Character.toUpperCase(c2);
        }
        
        private final String expectedString;
        private int position = 0;
        private StringMatcherCharacterValidator(String expectedString) {
            this.expectedString = expectedString;
        }
        
        @Override
        public boolean isValid(char chr) {
            if (position >= expectedString.length()) {
                return false;
            }
             else {
                return asciiEqualsIgnoringCase(chr, expectedString.charAt(position++));
            }
            
        }
        
    }
    
    public static class NoopCharValidator implements CharacterValidator {
        @Override
        public boolean isValid(char chr) {
            return true;
        }
        
    }
    
    public static class AtomCharValidator implements CharacterValidator {
        @Override
        public boolean isValid(char chr) {
            return (isCHAR(chr) && !isAtomSpecial(chr) && !isListWildcard(chr) && !isQuotedSpecial(chr));
        }
        
        private boolean isAtomSpecial(char chr) {
            return (chr == '(' || chr == ')' || chr == '{' || chr == ' ' || chr == Character.CONTROL);
        }
        
    }
    
    public static class TagCharValidator extends AtomCharValidator {
        @Override
        public boolean isValid(char chr) {
            if (chr == '+') {
                return false;
            }
            
            return super.isValid(chr);
        }
        
    }
    
    public static class MessageSetCharValidator implements CharacterValidator {
        @Override
        public boolean isValid(char chr) {
            return (isDigit(chr) || chr == ':' || chr == '*' || chr == ',');
        }
        
        private boolean isDigit(char chr) {
            return '0' <= chr && chr <= '9';
        }
        
    }
    
    private static class QuotedStringDecoder {
        private final CharsetDecoder decoder;
        private final ByteBuffer buffer;
        CharBuffer charBuffer;
        public QuotedStringDecoder(Charset charset) {
            decoder = charset.newDecoder();
            buffer = ByteBuffer.allocate(QUOTED_BUFFER_INITIAL_CAPACITY);
            charBuffer = CharBuffer.allocate(QUOTED_BUFFER_INITIAL_CAPACITY);
        }
        
        public String decode(ImapRequestLineReader request) throws DecodingException {
            try {
                decoder.reset();
                char next = request.nextChar();
                while (next != '"') {
                    if (!buffer.hasRemaining()) {
                        decodeByteBufferToCharacterBuffer(false);
                    }
                    
                    if (next == '\\') {
                        request.consume();
                        next = request.nextChar();
                        if (!isQuotedSpecial(next)) {
                            throw new DecodingException(HumanReadableText.ILLEGAL_ARGUMENTS, "Invalid escaped character in quote: '" + next + "'");
                        }
                        
                    }
                    
                    buffer.put((byte) next);
                    request.consume();
                    next = request.nextChar();
                }
                
                completeDecoding();
                return charBuffer.toString();
            }
             catch (IllegalStateException e) {
                throw new DecodingException(HumanReadableText.BAD_IO_ENCODING, "Bad character encoding", e);
            }
            
        }
        
        private void completeDecoding() throws DecodingException {
            decodeByteBufferToCharacterBuffer(true);
            flush();
            charBuffer.flip();
        }
        
        private void flush() throws DecodingException {
            final CoderResult coderResult = decoder.flush(charBuffer);
            if (coderResult.isOverflow()) {
                upsizeCharBuffer();
                flush();
            }
             else if (coderResult.isError()) {
                throw new DecodingException(HumanReadableText.BAD_IO_ENCODING, "Bad character encoding");
            }
            
        }
        
        private CoderResult decodeByteBufferToCharacterBuffer(boolean endOfInput) throws DecodingException {
            buffer.flip();
            return decodeMoreBytesToCharacterBuffer(endOfInput);
        }
        
        private CoderResult decodeMoreBytesToCharacterBuffer(boolean endOfInput) throws DecodingException {
            final CoderResult coderResult = decoder.decode(buffer, charBuffer, endOfInput);
            if (coderResult.isOverflow()) {
                upsizeCharBuffer();
                return decodeMoreBytesToCharacterBuffer(endOfInput);
            }
             else if (coderResult.isError()) {
                throw new DecodingException(HumanReadableText.BAD_IO_ENCODING, "Bad character encoding");
            }
             else if (coderResult.isUnderflow()) {
                buffer.clear();
            }
            
            return coderResult;
        }
        
        private void upsizeCharBuffer() {
            final int oldCapacity = charBuffer.capacity();
            CharBuffer oldBuffer = charBuffer;
            charBuffer = CharBuffer.allocate(oldCapacity + QUOTED_BUFFER_INITIAL_CAPACITY);
            oldBuffer.flip();
            charBuffer.put(oldBuffer);
        }
        
    }
    
}


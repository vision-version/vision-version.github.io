package org.dromara.hutool.core.math;
import org.dromara.hutool.core.text.CharUtil;
import org.dromara.hutool.core.text.StrUtil;
import java.math.BigInteger;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Locale;
public class NumberParser {
	 public static final NumberParser INSTANCE = of(null);
	 public static NumberParser of(final Locale locale) {
		return of(locale, true);
	}
	
	 public static NumberParser of(final Locale locale, final boolean zeroIfNaN) {
		return new NumberParser(locale, zeroIfNaN);
	}
	
	private static final String NaN = "NaN";
	private final Locale locale;
	private final boolean zeroIfNaN;
	 public NumberParser(final Locale locale, final boolean zeroIfNaN) {
		this.locale = locale;
		this.zeroIfNaN = zeroIfNaN;
	}
	
	 public int parseInt(final String numberStr) throws NumberFormatException {
		if (isBlankOrNaN(numberStr)) {
			return 0;
		}
		
		if (StrUtil.startWithIgnoreCase(numberStr, "0x")) {
			 return Integer.parseInt(numberStr.substring(2), 16);
		}
		
		if (StrUtil.containsIgnoreCase(numberStr, "E")) {
			 throw new NumberFormatException(StrUtil.format("Unsupported int format: [{}]", numberStr));
		}
		
		try {
			return Integer.parseInt(numberStr);
		}
		 catch (final NumberFormatException e) {
			return doParse(numberStr).intValue();
		}
		
	}
	
	 public long parseLong(final String numberStr) {
		if (isBlankOrNaN(numberStr)) {
			return 0;
		}
		
		if (StrUtil.startWithIgnoreCase(numberStr, "0x")) {
			 return Long.parseLong(numberStr.substring(2), 16);
		}
		
		try {
			return Long.parseLong(numberStr);
		}
		 catch (final NumberFormatException e) {
			return doParse(numberStr).longValue();
		}
		
	}
	
	 public float parseFloat(final String numberStr) {
		if (isBlankOrNaN(numberStr)) {
			return 0;
		}
		
		try {
			return Float.parseFloat(numberStr);
		}
		 catch (final NumberFormatException e) {
			return doParse(numberStr).floatValue();
		}
		
	}
	
	 public double parseDouble(final String numberStr) {
		if (isBlankOrNaN(numberStr)) {
			return 0;
		}
		
		try {
			return Double.parseDouble(numberStr);
		}
		 catch (final NumberFormatException e) {
			return doParse(numberStr).doubleValue();
		}
		
	}
	
	 public BigInteger parseBigInteger(String str) {
		str = StrUtil.trimToNull(str);
		if (null == str) {
			return null;
		}
		
		int pos = 0; 
		int radix = 10;
		boolean negate = false; 
		if (str.startsWith("-")) {
			negate = true;
			pos = 1;
		}
		
		if (str.startsWith("0x", pos) || str.startsWith("0X", pos)) {
			 radix = 16;
			pos += 2;
		}
		 else if (str.startsWith("#", pos)) {
			 radix = 16;
			pos++;
		}
		 else if (str.startsWith("0", pos) && str.length() > pos + 1) {
			 radix = 8;
			pos++;
		}
		 
		if (pos > 0) {
			str = str.substring(pos);
		}
		
		final BigInteger value = new BigInteger(str, radix);
		return negate ? value.negate() : value;
	}
	
	 public Number parseNumber(final String numberStr) throws NumberFormatException {
		if (isBlankOrNaN(numberStr)) {
			 return 0;
		}
		
		 if (StrUtil.startWithIgnoreCase(numberStr, "0x")) {
			 return Long.parseLong(numberStr.substring(2), 16);
		}
		
		return doParse(numberStr);
	}
	
	 private Number doParse(String numberStr) {
		Locale locale = this.locale;
		if (null == locale) {
			locale = Locale.getDefault(Locale.Category.FORMAT);
		}
		
		if(StrUtil.startWith(numberStr, CharUtil.PLUS)){
			 numberStr = StrUtil.subSuf(numberStr, 1);
		}
		
		try {
			final NumberFormat format = NumberFormat.getInstance(locale);
			if (format instanceof DecimalFormat) {
				 ((DecimalFormat) format).setParseBigDecimal(true);
			}
			
			return format.parse(numberStr);
		}
		 catch (final ParseException e) {
			final NumberFormatException nfe = new NumberFormatException(e.getMessage());
			nfe.initCause(e);
			throw nfe;
		}
		
	}
	
	 private boolean isBlankOrNaN(final String numberStr) throws NumberFormatException {
		if (StrUtil.isBlank(numberStr)) {
			return true;
		}
		
		if (NaN.equals(numberStr)) {
			if (zeroIfNaN) {
				return true;
			}
			 else {
				throw new NumberFormatException("Can not parse NaN when 'zeroIfNaN' is false!");
			}
			
		}
		
		return false;
	}
	
}


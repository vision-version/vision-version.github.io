package org.dromara.hutool.core.math;
import org.dromara.hutool.core.array.ArrayUtil;
import org.dromara.hutool.core.comparator.CompareUtil;
import org.dromara.hutool.core.lang.Assert;
import org.dromara.hutool.core.text.StrUtil;
import org.dromara.hutool.core.util.ObjUtil;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.Collection;
import java.util.Locale;
import java.util.Objects;
public class NumberUtil extends NumberValidator {
	 private static final int DEFAULT_DIV_SCALE = 10;
	 public static BigDecimal add(final Number... values) {
		if (ArrayUtil.isEmpty(values)) {
			return BigDecimal.ZERO;
		}
		
		Number value = values[0];
		BigDecimal result = toBigDecimal(value);
		for (int i = 1; i < values.length; i++) {
			value = values[i];
			if (null != value) {
				result = result.add(toBigDecimal(value));
			}
			
		}
		
		return result;
	}
	
	 public static BigDecimal add(final String... values) {
		if (ArrayUtil.isEmpty(values)) {
			return BigDecimal.ZERO;
		}
		
		String value = values[0];
		BigDecimal result = toBigDecimal(value);
		for (int i = 1; i < values.length; i++) {
			value = values[i];
			if (StrUtil.isNotBlank(value)) {
				result = result.add(toBigDecimal(value));
			}
			
		}
		
		return result;
	}
	
	 public static BigDecimal sub(final Number... values) {
		if (ArrayUtil.isEmpty(values)) {
			return BigDecimal.ZERO;
		}
		
		Number value = values[0];
		BigDecimal result = toBigDecimal(value);
		for (int i = 1; i < values.length; i++) {
			value = values[i];
			if (null != value) {
				result = result.subtract(toBigDecimal(value));
			}
			
		}
		
		return result;
	}
	
	 public static BigDecimal sub(final String... values) {
		if (ArrayUtil.isEmpty(values)) {
			return BigDecimal.ZERO;
		}
		
		String value = values[0];
		BigDecimal result = toBigDecimal(value);
		for (int i = 1; i < values.length; i++) {
			value = values[i];
			if (StrUtil.isNotBlank(value)) {
				result = result.subtract(toBigDecimal(value));
			}
			
		}
		
		return result;
	}
	
	 public static BigDecimal mul(final Number... values) {
		if (ArrayUtil.isEmpty(values) || ArrayUtil.hasNull(values)) {
			return BigDecimal.ZERO;
		}
		
		Number value = values[0];
		if (isZero(value)) {
			return BigDecimal.ZERO;
		}
		
		BigDecimal result = toBigDecimal(value);
		for (int i = 1; i < values.length; i++) {
			value = values[i];
			if (isZero(value)) {
				return BigDecimal.ZERO;
			}
			
			result = result.multiply(toBigDecimal(value));
		}
		
		return result;
	}
	
	 public static BigDecimal mul(final String... values) {
		if (ArrayUtil.isEmpty(values) || ArrayUtil.hasNull(values)) {
			return BigDecimal.ZERO;
		}
		
		BigDecimal result = toBigDecimal(values[0]);
		if (isZero(result)) {
			return BigDecimal.ZERO;
		}
		
		BigDecimal ele;
		for (int i = 1; i < values.length; i++) {
			ele = toBigDecimal(values[i]);
			if (isZero(ele)) {
				return BigDecimal.ZERO;
			}
			
			result = result.multiply(ele);
		}
		
		return result;
	}
	
	 public static BigDecimal div(final Number v1, final Number v2) {
		return div(v1, v2, DEFAULT_DIV_SCALE);
	}
	
	 public static BigDecimal div(final String v1, final String v2) {
		return div(v1, v2, DEFAULT_DIV_SCALE);
	}
	
	 public static BigDecimal div(final Number v1, final Number v2, final int scale) {
		return div(v1, v2, scale, RoundingMode.HALF_UP);
	}
	
	 public static BigDecimal div(final String v1, final String v2, final int scale) {
		return div(v1, v2, scale, RoundingMode.HALF_UP);
	}
	
	 public static BigDecimal div(final String v1, final String v2, final int scale, final RoundingMode roundingMode) {
		return div(toBigDecimal(v1), toBigDecimal(v2), scale, roundingMode);
	}
	
	 public static BigDecimal div(final Number v1, final Number v2, int scale, final RoundingMode roundingMode) {
		Assert.notNull(v2, "Divisor must be not null !");
		if (null == v1 || isZero(v1)) {
			 return BigDecimal.ZERO;
		}
		
		if (scale < 0) {
			scale = -scale;
		}
		
		return toBigDecimal(v1).divide(toBigDecimal(v2), scale, roundingMode);
	}
	
	 public static int ceilDiv(final int v1, final int v2) {
		return (int) Math.ceil((double) v1 / v2);
	}
	
	 public static BigDecimal round(final double v, final int scale) {
		return round(v, scale, RoundingMode.HALF_UP);
	}
	
	 public static String roundStr(final double v, final int scale) {
		return round(v, scale).toPlainString();
	}
	
	 public static BigDecimal round(final BigDecimal number, final int scale) {
		return round(number, scale, RoundingMode.HALF_UP);
	}
	
	 public static String roundStr(final String numberStr, final int scale) {
		return roundStr(numberStr, scale, RoundingMode.HALF_UP);
	}
	
	 public static BigDecimal round(final double v, final int scale, final RoundingMode roundingMode) {
		return round(toBigDecimal(v), scale, roundingMode);
	}
	
	 public static String roundStr(final double v, final int scale, final RoundingMode roundingMode) {
		return round(v, scale, roundingMode).toPlainString();
	}
	
	 public static BigDecimal round(BigDecimal number, int scale, RoundingMode roundingMode) {
		if (null == number) {
			number = BigDecimal.ZERO;
		}
		
		if (scale < 0) {
			scale = 0;
		}
		
		if (null == roundingMode) {
			roundingMode = RoundingMode.HALF_UP;
		}
		
		return number.setScale(scale, roundingMode);
	}
	
	 public static String roundStr(final String numberStr, final int scale, final RoundingMode roundingMode) {
		return round(toBigDecimal(numberStr), scale, roundingMode).toPlainString();
	}
	
	 public static BigDecimal roundHalfEven(final Number number, final int scale) {
		return round(toBigDecimal(number), scale, RoundingMode.HALF_EVEN);
	}
	
	 public static BigDecimal roundDown(final Number number, final int scale) {
		return round(toBigDecimal(number), scale, RoundingMode.DOWN);
	}
	
	 public static String format(final String pattern, final double value) {
		Assert.isTrue(isValid(value), "value is NaN or Infinite!");
		return new DecimalFormat(pattern).format(value);
	}
	
	 public static String format(final String pattern, final long value) {
		return new DecimalFormat(pattern).format(value);
	}
	
	 public static String format(final String pattern, final Object value) {
		return format(pattern, value, null);
	}
	
	 public static String format(final String pattern, final Object value, final RoundingMode roundingMode) {
		if (value instanceof Number) {
			Assert.isTrue(isValidNumber((Number) value), "value is NaN or Infinite!");
		}
		
		final DecimalFormat decimalFormat = new DecimalFormat(pattern);
		if (null != roundingMode) {
			decimalFormat.setRoundingMode(roundingMode);
		}
		
		return decimalFormat.format(value);
	}
	
	 public static String formatMoney(final double value) {
		return format(",##0.00", value);
	}
	
	 public static String formatPercent(final double number, final int scale) {
		final NumberFormat format = NumberFormat.getPercentInstance();
		format.setMaximumFractionDigits(scale);
		return format.format(number);
	}
	
	 public static String formatThousands(final double number, final int scale) {
		final NumberFormat format = NumberFormat.getNumberInstance();
		format.setMaximumFractionDigits(scale);
		return format.format(number);
	}
	
	 public static int[] range(final int stopIncluded) {
		return range(0, stopIncluded, 1);
	}
	
	 public static int[] range(final int startInclude, final int stopIncluded) {
		return range(startInclude, stopIncluded, 1);
	}
	
	 public static int[] range(int startInclude, int stopIncluded, int step) {
		if (startInclude > stopIncluded) {
			final int tmp = startInclude;
			startInclude = stopIncluded;
			stopIncluded = tmp;
		}
		
		if (step <= 0) {
			step = 1;
		}
		
		final int deviation = stopIncluded + 1 - startInclude;
		int length = deviation / step;
		if (deviation % step != 0) {
			length += 1;
		}
		
		final int[] range = new int[length];
		for (int i = 0; i < length; i++) {
			range[i] = startInclude;
			startInclude += step;
		}
		
		return range;
	}
	
	 public static Collection<Integer> appendRange(final int start, final int stop, final Collection<Integer> values) {
		return appendRange(start, stop, 1, values);
	}
	
	 public static Collection<Integer> appendRange(final int startInclude, final int stopInclude, int step, final Collection<Integer> values) {
		if (startInclude < stopInclude) {
			step = Math.abs(step);
		}
		 else if (startInclude > stopInclude) {
			step = -Math.abs(step);
		}
		 else {
			values.add(startInclude);
			return values;
		}
		
		for (int i = startInclude; (step > 0) ? i <= stopInclude : i >= stopInclude; i += step) {
			values.add(i);
		}
		
		return values;
	}
	
	 public static String getBinaryStr(final Number number) {
		if (number instanceof Long) {
			return Long.toBinaryString((Long) number);
		}
		 else if (number instanceof Integer) {
			return Integer.toBinaryString((Integer) number);
		}
		 else {
			return Long.toBinaryString(number.longValue());
		}
		
	}
	
	 public static int binaryToInt(final String binaryStr) {
		return Integer.parseInt(binaryStr, 2);
	}
	
	 public static long binaryToLong(final String binaryStr) {
		return Long.parseLong(binaryStr, 2);
	}
	
	 public static boolean equals(final Number number1, final Number number2) {
		if (number1 instanceof BigDecimal && number2 instanceof BigDecimal) {
			 return CompareUtil.equals((BigDecimal) number1, (BigDecimal) number2);
		}
		
		return Objects.equals(number1, number2);
	}
	
	 public static String toStr(final Number number, final String defaultValue) {
		return (null == number) ? defaultValue : toStr(number);
	}
	
	 public static String toStr(final Number number) {
		return toStr(number, true);
	}
	
	 public static String toStr(final Number number, final boolean isStripTrailingZeros) {
		Assert.notNull(number, "Number is null !");
		 if (number instanceof BigDecimal) {
			return toStr((BigDecimal) number, isStripTrailingZeros);
		}
		
		Assert.isTrue(isValidNumber(number), "Number is non-finite!");
		 String string = number.toString();
		if (isStripTrailingZeros) {
			if (string.indexOf('.') > 0 && string.indexOf('e') < 0 && string.indexOf('E') < 0) {
				while (string.endsWith("0")) {
					string = string.substring(0, string.length() - 1);
				}
				
				if (string.endsWith(".")) {
					string = string.substring(0, string.length() - 1);
				}
				
			}
			
		}
		
		return string;
	}
	
	 public static String toStr(final BigDecimal bigDecimal) {
		return toStr(bigDecimal, true);
	}
	
	 public static String toStr(BigDecimal bigDecimal, final boolean isStripTrailingZeros) {
		Assert.notNull(bigDecimal, "BigDecimal is null !");
		if (isStripTrailingZeros) {
			bigDecimal = bigDecimal.stripTrailingZeros();
		}
		
		return bigDecimal.toPlainString();
	}
	
	 public static BigDecimal toBigDecimal(final Number number) {
		if (null == number) {
			return BigDecimal.ZERO;
		}
		
		if (number instanceof BigDecimal) {
			return (BigDecimal) number;
		}
		 else if (number instanceof Long) {
			return new BigDecimal((Long) number);
		}
		 else if (number instanceof Integer) {
			return new BigDecimal((Integer) number);
		}
		 else if (number instanceof BigInteger) {
			return new BigDecimal((BigInteger) number);
		}
		
		 return new BigDecimal(number.toString());
	}
	
	 public static BigDecimal toBigDecimal(final String numberStr) {
		if (StrUtil.isBlank(numberStr)) {
			return BigDecimal.ZERO;
		}
		
		 try{
			return new BigDecimal(numberStr);
		}
		 catch (final Exception ignore){
			 }
			 
		 return toBigDecimal(parseNumber(numberStr));
	}
	
	 public static BigInteger toBigInteger(final Number number) {
		if (null == number) {
			return BigInteger.ZERO;
		}
		
		if (number instanceof BigInteger) {
			return (BigInteger) number;
		}
		 else if (number instanceof Long) {
			return BigInteger.valueOf((Long) number);
		}
		
		return toBigInteger(number.longValue());
	}
	
	 public static BigInteger toBigInteger(final String number) {
		return StrUtil.isBlank(number) ? BigInteger.ZERO : new BigInteger(number);
	}
	
	 public static int count(final int total, final int pageSize) {
		 return (total + pageSize - 1) / pageSize;
	}
	
	 public static int zeroToOne(final int value) {
		return 0 == value ? 1 : value;
	}
	
	 public static int nullToZero(final Integer number) {
		return number == null ? 0 : number;
	}
	
	 public static long nullToZero(final Long number) {
		return number == null ? 0L : number;
	}
	
	 public static double nullToZero(final Double number) {
		return number == null ? 0.0 : number;
	}
	
	 public static float nullToZero(final Float number) {
		return number == null ? 0.0f : number;
	}
	
	 public static short nullToZero(final Short number) {
		return number == null ? (short) 0 : number;
	}
	
	 public static byte nullToZero(final Byte number) {
		return number == null ? (byte) 0 : number;
	}
	
	 public static BigInteger nullToZero(final BigInteger number) {
		return number == null ? BigInteger.ZERO : number;
	}
	
	 public static BigDecimal nullToZero(final BigDecimal decimal) {
		return ObjUtil.defaultIfNull(decimal, BigDecimal.ZERO);
	}
	
	 public static BigInteger parseBigInteger(final String numberStr) {
		return NumberParser.INSTANCE.parseBigInteger(numberStr);
	}
	
	 public static boolean isBeside(final long number1, final long number2) {
		return Math.abs(number1 - number2) == 1;
	}
	
	 public static boolean isBeside(final int number1, final int number2) {
		return Math.abs(number1 - number2) == 1;
	}
	
	 public static int partValue(final int total, final int partCount) {
		return partValue(total, partCount, true);
	}
	
	 public static int partValue(final int total, final int partCount, final boolean isPlusOneWhenHasRem) {
		int partValue = total / partCount;
		if (isPlusOneWhenHasRem && total % partCount > 0) {
			partValue++;
		}
		
		return partValue;
	}
	
	 public static BigDecimal pow(final Number number, final int n) {
		return pow(toBigDecimal(number), n);
	}
	
	 public static BigDecimal pow(final BigDecimal number, final int n) {
		return number.pow(n);
	}
	
	 public static boolean isPowerOfTwo(final long n) {
		return (n > 0) && ((n & (n - 1)) == 0);
	}
	
	 public static Integer parseInt(final String numberStr, final Integer defaultValue) {
		if (StrUtil.isNotBlank(numberStr)) {
			try {
				return parseInt(numberStr);
			}
			 catch (final NumberFormatException ignore) {
				 }
				 
		}
		
		return defaultValue;
	}
	
	 public static int parseInt(final String numberStr) throws NumberFormatException {
		return NumberParser.INSTANCE.parseInt(numberStr);
	}
	
	 public static Long parseLong(final String numberStr, final Long defaultValue) {
		if (StrUtil.isNotBlank(numberStr)) {
			try {
				return parseLong(numberStr);
			}
			 catch (final NumberFormatException ignore) {
				 }
				 
		}
		
		return defaultValue;
	}
	
	 public static long parseLong(final String numberStr) {
		return NumberParser.INSTANCE.parseLong(numberStr);
	}
	
	 public static Float parseFloat(final String numberStr, final Float defaultValue) {
		if (StrUtil.isNotBlank(numberStr)) {
			try {
				return parseFloat(numberStr);
			}
			 catch (final NumberFormatException ignore) {
				 }
				 
		}
		
		return defaultValue;
	}
	
	 public static float parseFloat(final String numberStr) {
		return NumberParser.INSTANCE.parseFloat(numberStr);
	}
	
	 public static Double parseDouble(final String numberStr, final Double defaultValue) {
		if (StrUtil.isNotBlank(numberStr)) {
			try {
				return parseDouble(numberStr);
			}
			 catch (final NumberFormatException ignore) {
				 }
				 
		}
		
		return defaultValue;
	}
	
	 public static double parseDouble(final String numberStr) {
		return NumberParser.INSTANCE.parseDouble(numberStr);
	}
	
	 public static Number parseNumber(final String numberStr, final Number defaultValue) {
		if (StrUtil.isNotBlank(numberStr)) {
			try {
				return parseNumber(numberStr);
			}
			 catch (final NumberFormatException ignore) {
				 }
				 
		}
		
		return defaultValue;
	}
	
	 public static Number parseNumber(final String numberStr) throws NumberFormatException {
		return NumberParser.INSTANCE.parseNumber(numberStr);
	}
	
	 public static Number parseNumber(final String numberStr, final Locale locale) throws NumberFormatException {
		return NumberParser.of(locale).parseNumber(numberStr);
	}
	
	 public static boolean isValidNumber(final Number number) {
		if (null == number) {
			return false;
		}
		
		if (number instanceof Double) {
			return (!((Double) number).isInfinite()) && (!((Double) number).isNaN());
		}
		 else if (number instanceof Float) {
			return (!((Float) number).isInfinite()) && (!((Float) number).isNaN());
		}
		
		return true;
	}
	
	 public static boolean isValid(final double number) {
		return !(Double.isNaN(number) || Double.isInfinite(number));
	}
	
	 public static boolean isValid(final float number) {
		return !(Float.isNaN(number) || Float.isInfinite(number));
	}
	
	 public static double calculate(final String expression) {
		return Calculator.conversion(expression);
	}
	
	 public static double toDouble(final Number value) {
		if (value instanceof Float) {
			return Double.parseDouble(value.toString());
		}
		 else {
			return value.doubleValue();
		}
		
	}
	
	 public static boolean isOdd(final int num) {
		return (num & 1) == 1;
	}
	
	 public static boolean isEven(final int num) {
		return !isOdd(num);
	}
	
	 public static boolean isZero(final Number n) {
		Assert.notNull(n);
		if (n instanceof Byte || n instanceof Short || n instanceof Integer || n instanceof Long) {
			return 0L == n.longValue();
		}
		 else if (n instanceof BigInteger) {
			return equals(BigInteger.ZERO, n);
		}
		 else if (n instanceof Float) {
			return 0f == n.floatValue();
		}
		 else if (n instanceof Double) {
			return 0d == n.doubleValue();
		}
		
		return equals(toBigDecimal(n), BigDecimal.ZERO);
	}
	
}


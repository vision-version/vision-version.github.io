package org.apache.pdfbox.io;
import java.io.EOFException;
import java.io.IOException;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.pdfbox.cos.COSStream;
class ScratchFileBuffer implements RandomAccess {
    private final int pageSize;
    private ScratchFile pageHandler;
    private long size = 0;
    private int currentPagePositionInPageIndexes;
    private long currentPageOffset;
    private byte[] currentPage;
    private int positionInPage;
    private boolean currentPageContentChanged = false;
    private int[] pageIndexes = new int[16];
    private int pageCount = 0;
    private static final Log LOG = LogFactory.getLog(ScratchFileBuffer.class);
    ScratchFileBuffer(ScratchFile pageHandler) throws IOException {
        pageHandler.checkClosed();
        this.pageHandler = pageHandler;
        pageSize = this.pageHandler.getPageSize();
        addPage();
    }
    
    private void checkClosed() throws IOException {
        if (pageHandler == null){
            throw new IOException("Buffer already closed");
        }
        
        pageHandler.checkClosed();
    }
    
    private void addPage() throws IOException {
        if (pageCount+1 >= pageIndexes.length){
            int newSize = pageIndexes.length*2;
            if (newSize<pageIndexes.length){
                if (pageIndexes.length == Integer.MAX_VALUE){
                    throw new IOException("Maximum buffer size reached.");
                }
                
                newSize = Integer.MAX_VALUE;
            }
            
            int[] newPageIndexes = new int[newSize];
            System.arraycopy(pageIndexes, 0, newPageIndexes, 0, pageCount);
            pageIndexes = newPageIndexes;
        }
        
        int newPageIdx = pageHandler.getNewPage();
        pageIndexes[pageCount] = newPageIdx;
        currentPagePositionInPageIndexes = pageCount;
        currentPageOffset = ((long)pageCount) * pageSize; 
        pageCount++;
        currentPage = new byte[pageSize];
        positionInPage = 0;
    }
    
    @Override
    public long length() throws IOException {
        return size;
    }
    
    private boolean ensureAvailableBytesInPage(boolean addNewPageIfNeeded) throws IOException {
        if (positionInPage >= pageSize){
            if (currentPageContentChanged){
                pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);
                currentPageContentChanged = false;
            }
            
            if (currentPagePositionInPageIndexes+1 < pageCount){
                currentPage = pageHandler.readPage(pageIndexes[++currentPagePositionInPageIndexes]);
                currentPageOffset = ((long)currentPagePositionInPageIndexes) * pageSize;
                positionInPage = 0;
            }
            
            else if (addNewPageIfNeeded){
                addPage();
            }
            
            else{
                return false;
            }
            
        }
        
        return true;
    }
    
    @Override
    public void write(int b) throws IOException {
        checkClosed();
        ensureAvailableBytesInPage(true);
        currentPage[positionInPage++] = (byte) b;
        currentPageContentChanged = true;
        if(currentPageOffset + positionInPage > size) {
            size = currentPageOffset + positionInPage;
        }
        
    }
    
    @Override
    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }
    
    @Override
    public void write(byte[] b, int off, int len) throws IOException {
        checkClosed();
        int remain = len;
        int bOff   = off;
        while (remain > 0){
            ensureAvailableBytesInPage(true);
            int bytesToWrite = Math.min(remain, pageSize-positionInPage);
            System.arraycopy(b, bOff, currentPage, positionInPage, bytesToWrite);
            positionInPage += bytesToWrite;
            currentPageContentChanged = true;
            bOff   += bytesToWrite;
            remain -= bytesToWrite;
        }
        
        if(currentPageOffset + positionInPage > size) {
            size = currentPageOffset + positionInPage;
        }
        
    }
    
    @Override
    public final void clear() throws IOException {
        checkClosed();
        pageHandler.markPagesAsFree(pageIndexes, 1, pageCount - 1);
        pageCount = 1;
        if (currentPagePositionInPageIndexes > 0){
            currentPage = pageHandler.readPage(pageIndexes[0]);
            currentPagePositionInPageIndexes = 0;
            currentPageOffset = 0;
        }
        
        positionInPage = 0;
        size = 0;
        currentPageContentChanged = false;
    }
    
    @Override
    public long getPosition() throws IOException {
        checkClosed();
        return currentPageOffset + positionInPage;
    }
    
    @Override
    public void seek(long seekToPosition) throws IOException {
        checkClosed();
        if (seekToPosition > size){
            throw new EOFException();
        }
        
        if (seekToPosition < 0){
            throw new IOException("Negative seek offset: " + seekToPosition);
        }
        
        if ((seekToPosition >= currentPageOffset) && (seekToPosition <= currentPageOffset + pageSize)){
            positionInPage = (int) (seekToPosition - currentPageOffset);
        }
        
        else{
            if (currentPageContentChanged){
                pageHandler.writePage(pageIndexes[currentPagePositionInPageIndexes], currentPage);
                currentPageContentChanged = false;
            }
            
            int newPagePosition = (int) (seekToPosition / pageSize);
            if (seekToPosition % pageSize == 0 && seekToPosition == size){
                newPagePosition--; 
            }
            
            currentPage = pageHandler.readPage(pageIndexes[newPagePosition]);
            currentPagePositionInPageIndexes = newPagePosition;
            currentPageOffset = ((long)currentPagePositionInPageIndexes) * pageSize;
            positionInPage = (int) (seekToPosition - currentPageOffset);
        }
        
    }
    
    @Override
    public boolean isClosed() {
        return pageHandler == null;
    }
    
    @Override
    public int peek() throws IOException {
        int result = read();
        if (result != -1){
            rewind(1);
        }
        
        return result;
    }
    
    @Override
    public void rewind(int bytes) throws IOException {
        seek(currentPageOffset + positionInPage - bytes);
    }
    
    @Override
    public byte[] readFully(int length) throws IOException {
        byte[] bytes = new byte[length];
        int bytesRead = 0;
        do {
            int count = read(bytes, bytesRead, length - bytesRead);
            if (count < 0){
                throw new EOFException();
            }
            
            bytesRead += count;
        }
         while (bytesRead < length);
        return bytes;
    }
    
    @Override
    public boolean isEOF() throws IOException {
        checkClosed();
        return currentPageOffset + positionInPage >= size;
    }
    
    @Override
    public int available() throws IOException {
        checkClosed();
        return (int) Math.min(size - (currentPageOffset + positionInPage), Integer.MAX_VALUE);
    }
    
    @Override
    public int read() throws IOException {
        checkClosed();
        if (currentPageOffset + positionInPage >= size){
            return -1;
        }
        
        if (! ensureAvailableBytesInPage(false)){
            throw new IOException("Unexpectedly no bytes available for read in buffer.");
        }
        
        return currentPage[positionInPage++] & 0xff;
    }
    
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }
    
    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        checkClosed();
        if (currentPageOffset + positionInPage >= size){
            return -1;
        }
        
        int remain = (int) Math.min(len, size - (currentPageOffset + positionInPage));
        int totalBytesRead = 0;
        int bOff           = off;
        while (remain > 0){
            if (! ensureAvailableBytesInPage(false)){
                throw new IOException("Unexpectedly no bytes available for read in buffer.");
            }
            
            int readBytes = Math.min(remain, pageSize - positionInPage);
            System.arraycopy(currentPage, positionInPage, b, bOff, readBytes);
            positionInPage += readBytes;
            totalBytesRead += readBytes;
            bOff += readBytes;
            remain -= readBytes;
        }
        
        return totalBytesRead;
    }
    
    @Override
    public void close() throws IOException {
        if (pageHandler != null) {
            pageHandler.markPagesAsFree(pageIndexes, 0, pageCount);
            pageHandler = null;
            pageIndexes = null;
            currentPage = null;
            currentPageOffset = 0;
            currentPagePositionInPageIndexes = -1;
            positionInPage = 0;
            size = 0;
        }
        
    }
    
    @Override
    protected void finalize() throws Throwable {
        try {
            if ((pageHandler != null) && LOG.isDebugEnabled()){
                LOG.debug("ScratchFileBuffer not closed!");
            }
            
            close();
        }
        
        finally {
            super.finalize();
        }
        
    }
    
}


package org.apache.pdfbox.io;
import java.io.EOFException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.util.LinkedHashMap;
import java.util.Map;
public class RandomAccessBufferedFileInputStream extends InputStream implements RandomAccessRead {
    private static final String TMP_FILE_PREFIX = "tmpPDFBox";
    private int pageSizeShift = 12;
    private int pageSize = 1 << pageSizeShift;
    private long pageOffsetMask = -1L << pageSizeShift;
    private int maxCachedPages = 1000;
    private File tempFile;
    private byte[] lastRemovedCachePage = null;
    private final Map<Long, byte[]> pageCache = new LinkedHashMap<Long, byte[]>( maxCachedPages, 0.75f, true ) {         private static final long serialVersionUID = -6302488539257741101L;
        @Override
        protected boolean removeEldestEntry( Map.Entry<Long, byte[]> eldest ) {
            final boolean doRemove = size() > maxCachedPages;
            if (doRemove){
                lastRemovedCachePage = eldest.getValue();
            }
            
            return doRemove;
        }
        
    };
    private long curPageOffset = -1;
    private byte[] curPage = new byte[pageSize];
    private int offsetWithinPage = 0;
    private final RandomAccessFile raFile;
    private final long fileLength;
    private long fileOffset = 0;
    private boolean isClosed;
    public RandomAccessBufferedFileInputStream( String filename ) throws IOException  {
        this(new File(filename));
    }
    
    public RandomAccessBufferedFileInputStream( File file ) throws IOException  {
        raFile = new RandomAccessFile(file, "r");
        fileLength = file.length();
        seek(0);
    }
    
    public RandomAccessBufferedFileInputStream( InputStream input ) throws IOException  {
        tempFile = createTmpFile(input);
        fileLength = tempFile.length();
        raFile = new RandomAccessFile(tempFile, "r");
        seek(0);
    }
    
    private File createTmpFile(InputStream input) throws IOException {
        FileOutputStream fos = null;
        try {
            File tmpFile = File.createTempFile(TMP_FILE_PREFIX, ".pdf");
            fos = new FileOutputStream(tmpFile);
            IOUtils.copy(input, fos);
            return tmpFile;
        }
        
        finally {
            IOUtils.closeQuietly(input);
            IOUtils.closeQuietly(fos);
        }
        
    }
    
    private void deleteTempFile() {
        if (tempFile != null){
            tempFile.delete();
        }
        
    }
    
    @Override
    public long getPosition() {
        return fileOffset;
    }
    
    @Override
    public void seek( final long newOffset ) throws IOException {
        final long newPageOffset = newOffset & pageOffsetMask;
        if ( newPageOffset != curPageOffset ){
            byte[] newPage = pageCache.get( newPageOffset );
            if ( newPage == null ){
                raFile.seek( newPageOffset );
                newPage = readPage();
                pageCache.put( newPageOffset, newPage );
            }
            
            curPageOffset = newPageOffset;
            curPage = newPage;
        }
        
        offsetWithinPage = (int) ( newOffset - curPageOffset );
        fileOffset = newOffset;
    }
    
    private byte[] readPage() throws IOException {
        byte[] page;
        if ( lastRemovedCachePage != null ){
            page = lastRemovedCachePage;
            lastRemovedCachePage = null;
        }
        
        else{
            page = new byte[pageSize];
        }
        
        int readBytes = 0;
        while ( readBytes < pageSize ){
            int curBytesRead = raFile.read( page, readBytes, pageSize - readBytes);
            if (curBytesRead < 0){
                break;
            }
            
            readBytes += curBytesRead;
        }
        
        return page;
    }
    
    @Override
    public int read() throws IOException {
        if ( fileOffset >= fileLength ){
            return -1;
        }
        
        if ( offsetWithinPage == pageSize ){
            seek( fileOffset );
        }
        
        fileOffset++;
        return curPage[offsetWithinPage++] & 0xff;
    }
    
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }
    
    @Override
    public int read( byte[] b, int off, int len ) throws IOException {
        if ( fileOffset >= fileLength ){
            return -1;
        }
        
        if ( offsetWithinPage == pageSize ){
            seek( fileOffset );
        }
        
        int commonLen = Math.min( pageSize - offsetWithinPage, len );
        if ( ( fileLength - fileOffset ) < pageSize ){
            commonLen = Math.min( commonLen, (int) ( fileLength - fileOffset ) );
        }
        
        System.arraycopy( curPage, offsetWithinPage, b, off, commonLen );
        offsetWithinPage += commonLen;
        fileOffset += commonLen;
        return commonLen;
    }
    
    @Override
    public int available() throws IOException {
        return (int) Math.min( fileLength - fileOffset, Integer.MAX_VALUE );
    }
    
    @Override
    public long skip( long n ) throws IOException {
        long toSkip = n;
        if ( fileLength - fileOffset < toSkip ){
            toSkip = fileLength - fileOffset;
        }
        
        if ( ( toSkip < pageSize ) && ( ( offsetWithinPage + toSkip ) <= pageSize ) ){
            offsetWithinPage += toSkip;
            fileOffset += toSkip;
        }
        
        else{
            seek( fileOffset + toSkip );
        }
        
        return toSkip;
    }
    
    @Override
    public long length() throws IOException {
        return fileLength;
    }
    
    @Override
    public void close() throws IOException {
        raFile.close();
        deleteTempFile();
        pageCache.clear();
        isClosed = true;
    }
    
    @Override
    public boolean isClosed() {
        return isClosed;
    }
    
    @Override
    public int peek() throws IOException {
        int result = read();
        if (result != -1){
            rewind(1);
        }
        
        return result;
    }
    
    @Override
    public void rewind(int bytes) throws IOException {
        seek(getPosition() - bytes);
    }
    
    @Override
    public byte[] readFully(int length) throws IOException {
        byte[] bytes = new byte[length];
        int bytesRead = 0;
        do {
            int count = read(bytes, bytesRead, length - bytesRead);
            if (count < 0){
                throw new EOFException();
            }
            
            bytesRead += count;
        }
         while (bytesRead < length);
        return bytes;
    }
    
    @Override
    public boolean isEOF() throws IOException {
        int peek = peek();
        return peek == -1;
    }
    
}


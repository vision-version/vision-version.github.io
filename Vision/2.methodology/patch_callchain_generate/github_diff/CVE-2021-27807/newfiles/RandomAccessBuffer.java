package org.apache.pdfbox.io;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
public class RandomAccessBuffer implements RandomAccess, Cloneable {
    private static final int DEFAULT_CHUNK_SIZE = 1024;
    private int chunkSize = DEFAULT_CHUNK_SIZE;
    private List<byte[]> bufferList = null;
    private byte[] currentBuffer;
    private long pointer;
    private int currentBufferPointer;
    private long size;
    private int bufferListIndex;
    private int bufferListMaxIndex;
    public RandomAccessBuffer() {
        this(DEFAULT_CHUNK_SIZE);
    }
    
    private RandomAccessBuffer(int definedChunkSize) {
        bufferList = new ArrayList<byte[]>();
        chunkSize = definedChunkSize;
        currentBuffer = new byte[chunkSize];
        bufferList.add(currentBuffer);
        pointer = 0;
        currentBufferPointer = 0;
        size = 0;
        bufferListIndex = 0;
        bufferListMaxIndex = 0;
    }
    
    public RandomAccessBuffer(byte[] input) {
        bufferList = new ArrayList<byte[]>(1);
        chunkSize = input.length;
        currentBuffer = input;
        bufferList.add(currentBuffer);
        pointer = 0;
        currentBufferPointer = 0;
        size = chunkSize;
        bufferListIndex = 0;
        bufferListMaxIndex = 0;
    }
    
    public RandomAccessBuffer(InputStream input) throws IOException {
        this();
        byte[] byteBuffer = new byte[8192];
        int bytesRead = 0;
        while ((bytesRead = input.read(byteBuffer)) > -1) {
            write(byteBuffer, 0, bytesRead);
        }
        
        seek(0);
    }
    
    @Override
    public RandomAccessBuffer clone() {
        RandomAccessBuffer copy = new RandomAccessBuffer(chunkSize);
        copy.bufferList = new ArrayList<byte[]>(bufferList.size());
        for (byte [] buffer : bufferList){
            byte [] newBuffer = new byte [buffer.length];
            System.arraycopy(buffer,0,newBuffer,0,buffer.length);
            copy.bufferList.add(newBuffer);
        }
        
        if (currentBuffer!=null){
            copy.currentBuffer = copy.bufferList.get(copy.bufferList.size()-1);
        }
        
        else{
            copy.currentBuffer = null;
        }
        
        copy.pointer = pointer;
        copy.currentBufferPointer = currentBufferPointer;
        copy.size = size;
        copy.bufferListIndex = bufferListIndex;
        copy.bufferListMaxIndex = bufferListMaxIndex;
        return copy;
    }
    
    @Override
    public void close() throws IOException {
        currentBuffer = null;
        bufferList.clear();
        pointer = 0;
        currentBufferPointer = 0;
        size = 0;
        bufferListIndex = 0;
    }
    
    @Override
    public void clear() {
        bufferList.clear();
        currentBuffer = new byte[chunkSize];
        bufferList.add(currentBuffer);
        pointer = 0;
        currentBufferPointer = 0;
        size = 0;
        bufferListIndex = 0;
        bufferListMaxIndex = 0;
    }
    
    @Override
    public void seek(long position) throws IOException {
        checkClosed();
        if (position < 0){
            throw new IOException("Invalid position "+position);
        }
        
        pointer = position;
        if (pointer < size){
            bufferListIndex = (int)(pointer / chunkSize);
            currentBufferPointer = (int)(pointer % chunkSize);
            currentBuffer = bufferList.get(bufferListIndex);
        }
        
        else{
            bufferListIndex = bufferListMaxIndex;
            currentBuffer = bufferList.get(bufferListIndex);
            currentBufferPointer = (int)(size % chunkSize);
        }
        
    }
    
    @Override
    public long getPosition() throws IOException {
       checkClosed();
       return pointer;
    }
    
    @Override
    public int read() throws IOException {
        checkClosed();
        if (pointer >= this.size){
            return -1;
        }
        
        if (currentBufferPointer >= chunkSize){
            if (bufferListIndex >= bufferListMaxIndex){
                return -1;
            }
            
            else{
                currentBuffer = bufferList.get(++bufferListIndex);
                currentBufferPointer = 0;
            }
            
        }
        
        pointer++;
        return currentBuffer[currentBufferPointer++] & 0xff;
    }
    
    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        checkClosed();
        if (pointer >= size){
            return -1;
        }
        
        int bytesRead = readRemainingBytes(b, offset, length);
        while (bytesRead < length && available() > 0){
            bytesRead += readRemainingBytes(b, offset + bytesRead, length - bytesRead);
            if (currentBufferPointer == chunkSize){
                nextBuffer();
            }
            
        }
        
        return bytesRead;
    }
    
    private int readRemainingBytes(byte[] b, int offset, int length) {
        int maxLength = (int) Math.min(length, size-pointer);
        int remainingBytes = chunkSize - currentBufferPointer;
        if (remainingBytes == 0){
            return 0;
        }
        
        if (maxLength >= remainingBytes){
            System.arraycopy(currentBuffer, currentBufferPointer, b, offset, remainingBytes);
            currentBufferPointer += remainingBytes;
            pointer += remainingBytes;
            return remainingBytes;
        }
        
        else{
            System.arraycopy(currentBuffer, currentBufferPointer, b, offset, maxLength);
            currentBufferPointer += maxLength;
            pointer += maxLength;
            return maxLength;
        }
        
    }
    
    @Override
    public long length() throws IOException {
        checkClosed();
        return size;
    }
    
    @Override
    public void write(int b) throws IOException {
        checkClosed();
        if (currentBufferPointer >= chunkSize){
            if (pointer + chunkSize >= Integer.MAX_VALUE){
                throw new IOException("RandomAccessBuffer overflow");
            }
            
            expandBuffer();
        }
        
        currentBuffer[currentBufferPointer++] = (byte)b;
        pointer++;
        if (pointer > this.size){
            this.size = pointer;
        }
        
        if (currentBufferPointer >= chunkSize){
            if (pointer + chunkSize >= Integer.MAX_VALUE){
                throw new IOException("RandomAccessBuffer overflow");
            }
            
            expandBuffer();
        }
        
    }
    
    @Override
    public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
    }
    
    @Override
    public void write(byte[] b, int offset, int length) throws IOException {
        checkClosed();
        long newSize = pointer + length;
        int remainingBytes = chunkSize - currentBufferPointer;
        if (length >= remainingBytes){
            if (newSize > Integer.MAX_VALUE){
                throw new IOException("RandomAccessBuffer overflow");
            }
            
            System.arraycopy(b, offset, currentBuffer, currentBufferPointer, remainingBytes);
            int newOffset = offset + remainingBytes;
            long remainingBytes2Write = length - remainingBytes;
            int numberOfNewArrays = (int)remainingBytes2Write / chunkSize;
            for (int i=0;i<numberOfNewArrays;i++){
                expandBuffer();
                System.arraycopy(b, newOffset, currentBuffer, currentBufferPointer, chunkSize);
                newOffset += chunkSize;
            }
            
            remainingBytes2Write -= numberOfNewArrays * (long) chunkSize;
            if (remainingBytes2Write >= 0){
                expandBuffer();
                if (remainingBytes2Write > 0){
                    System.arraycopy(b, newOffset, currentBuffer, currentBufferPointer, (int)remainingBytes2Write);
                }
                
                currentBufferPointer = (int)remainingBytes2Write;
            }
            
        }
        
        else{
            System.arraycopy(b, offset, currentBuffer, currentBufferPointer, length);
            currentBufferPointer += length;
        }
        
        pointer += length;
        if (pointer > this.size){
            this.size = pointer;
        }
        
    }
    
    private void expandBuffer() throws IOException {
        if (bufferListMaxIndex > bufferListIndex){
            nextBuffer();
        }
        
        else{
            currentBuffer = new byte[chunkSize];
            bufferList.add(currentBuffer);
            currentBufferPointer = 0;
            bufferListMaxIndex++;
            bufferListIndex++;
        }
        
    }
    
    private void nextBuffer() throws IOException {
        if (bufferListIndex == bufferListMaxIndex){
            throw new IOException("No more chunks available, end of buffer reached");
        }
        
        currentBufferPointer = 0;
        currentBuffer = bufferList.get(++bufferListIndex);
    }
    
    private void checkClosed() throws IOException {
        if (currentBuffer==null){
            throw new IOException("RandomAccessBuffer already closed");
        }
        
    }
    
    @Override
    public boolean isClosed() {
        return currentBuffer == null;
    }
    
    @Override
    public boolean isEOF() throws IOException {
        checkClosed();
        return pointer >= size;
    }
    
    @Override
    public int available() throws IOException {
        return (int) Math.min(length() - getPosition(), Integer.MAX_VALUE);
    }
    
    @Override
    public int peek() throws IOException {
        int result = read();
        if (result != -1){
            rewind(1);
        }
        
        return result;
    }
    
    @Override
    public void rewind(int bytes) throws IOException {
        checkClosed();
        seek(getPosition() - bytes);
    }
    
    @Override
    public byte[] readFully(int length) throws IOException {
        byte[] bytes = new byte[length];
        int bytesRead = 0;
        do {
            int count = read(bytes, bytesRead, length - bytesRead);
            if (count < 0){
                throw new EOFException();
            }
            
            bytesRead += count;
        }
         while (bytesRead < length);
        return bytes;
    }
    
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }
    
}


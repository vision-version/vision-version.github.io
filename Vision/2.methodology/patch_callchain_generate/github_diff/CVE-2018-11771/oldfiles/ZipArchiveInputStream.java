package org.apache.commons.compress.archivers.zip;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.zip.CRC32;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;
import org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;
import org.apache.commons.compress.utils.ArchiveUtils;
import org.apache.commons.compress.utils.IOUtils;
import org.apache.commons.compress.utils.InputStreamStatistics;
import static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;
import static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;
import static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;
import static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;
public class ZipArchiveInputStream extends ArchiveInputStream implements InputStreamStatistics {
    private final ZipEncoding zipEncoding;
    final String encoding;
    private final boolean useUnicodeExtraFields;
    private final InputStream in;
    private final Inflater inf = new Inflater(true);
    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);
    private CurrentEntry current = null;
    private boolean closed = false;
    private boolean hitCentralDirectory = false;
    private ByteArrayInputStream lastStoredEntry = null;
    private boolean allowStoredEntriesWithDataDescriptor = false;
    private long uncompressedCount = 0;
    private static final int LFH_LEN = 30;
    private static final int CFH_LEN = 46;
    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;
    private final byte[] lfhBuf = new byte[LFH_LEN];
    private final byte[] skipBuf = new byte[1024];
    private final byte[] shortBuf = new byte[SHORT];
    private final byte[] wordBuf = new byte[WORD];
    private final byte[] twoDwordBuf = new byte[2 * DWORD];
    private int entriesRead = 0;
    public ZipArchiveInputStream(final InputStream inputStream) {
        this(inputStream, ZipEncodingHelper.UTF8);
    }
    
    public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {
        this(inputStream, encoding, true);
    }
    
    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {
        this(inputStream, encoding, useUnicodeExtraFields, false);
    }
    
    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields, final boolean allowStoredEntriesWithDataDescriptor) {
        this.encoding = encoding;
        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);
        this.useUnicodeExtraFields = useUnicodeExtraFields;
        in = new PushbackInputStream(inputStream, buf.capacity());
        this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;
        buf.limit(0);
    }
    
    public ZipArchiveEntry getNextZipEntry() throws IOException {
        uncompressedCount = 0;
        boolean firstEntry = true;
        if (closed || hitCentralDirectory) {
            return null;
        }
        
        if (current != null) {
            closeEntry();
            firstEntry = false;
        }
        
        long currentHeaderOffset = getBytesRead();
        try {
            if (firstEntry) {
                readFirstLocalFileHeader(lfhBuf);
            }
             else {
                readFully(lfhBuf);
            }
            
        }
         catch (final EOFException e) {
            return null;
        }
        
        final ZipLong sig = new ZipLong(lfhBuf);
        if (!sig.equals(ZipLong.LFH_SIG)) {
            if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG) || isApkSigningBlock(lfhBuf)) {
                hitCentralDirectory = true;
                skipRemainderOfArchive();
                return null;
            }
            
            throw new ZipException(String.format("Unexpected record signature: 0X%X", sig.getValue()));
        }
        
        int off = WORD;
        current = new CurrentEntry();
        final int versionMadeBy = ZipShort.getValue(lfhBuf, off);
        off += SHORT;
        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);
        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);
        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();
        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;
        current.hasDataDescriptor = gpFlag.usesDataDescriptor();
        current.entry.setGeneralPurposeBit(gpFlag);
        off += SHORT;
        current.entry.setMethod(ZipShort.getValue(lfhBuf, off));
        off += SHORT;
        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));
        current.entry.setTime(time);
        off += WORD;
        ZipLong size = null, cSize = null;
        if (!current.hasDataDescriptor) {
            current.entry.setCrc(ZipLong.getValue(lfhBuf, off));
            off += WORD;
            cSize = new ZipLong(lfhBuf, off);
            off += WORD;
            size = new ZipLong(lfhBuf, off);
            off += WORD;
        }
         else {
            off += 3 * WORD;
        }
        
        final int fileNameLen = ZipShort.getValue(lfhBuf, off);
        off += SHORT;
        final int extraLen = ZipShort.getValue(lfhBuf, off);
        off += SHORT; 
        final byte[] fileName = new byte[fileNameLen];
        readFully(fileName);
        current.entry.setName(entryEncoding.decode(fileName), fileName);
        if (hasUTF8Flag) {
            current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);
        }
        
        final byte[] extraData = new byte[extraLen];
        readFully(extraData);
        current.entry.setExtra(extraData);
        if (!hasUTF8Flag && useUnicodeExtraFields) {
            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);
        }
        
        processZip64Extra(size, cSize);
        current.entry.setLocalHeaderOffset(currentHeaderOffset);
        current.entry.setDataOffset(getBytesRead());
        current.entry.setStreamContiguous(true);
        ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());
        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {
            if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {
                InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());
                switch (m) {
                case UNSHRINKING:
                    current.in = new UnshrinkingInputStream(bis);
                    break;
                case IMPLODING:
                    current.in = new ExplodingInputStream( current.entry.getGeneralPurposeBit().getSlidingDictionarySize(), current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(), bis);
                    break;
                case BZIP2:
                    current.in = new BZip2CompressorInputStream(bis);
                    break;
                case ENHANCED_DEFLATED:
                    current.in = new Deflate64CompressorInputStream(bis);
                    break;
                default: break;
                }
                
            }
            
        }
         else if (m == ZipMethod.ENHANCED_DEFLATED) {
            current.in = new Deflate64CompressorInputStream(in);
        }
        
        entriesRead++;
        return current.entry;
    }
    
    private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {
        readFully(lfh);
        final ZipLong sig = new ZipLong(lfh);
        if (sig.equals(ZipLong.DD_SIG)) {
            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);
        }
        
        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {
            final byte[] missedLfhBytes = new byte[4];
            readFully(missedLfhBytes);
            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);
            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);
        }
        
    }
    
    private void processZip64Extra(final ZipLong size, final ZipLong cSize) {
        final Zip64ExtendedInformationExtraField z64 = (Zip64ExtendedInformationExtraField) current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);
        current.usesZip64 = z64 != null;
        if (!current.hasDataDescriptor) {
            if (z64 != null  && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {
                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());
                current.entry.setSize(z64.getSize().getLongValue());
            }
             else {
                current.entry.setCompressedSize(cSize.getValue());
                current.entry.setSize(size.getValue());
            }
            
        }
        
    }
    
    @Override
    public ArchiveEntry getNextEntry() throws IOException {
        return getNextZipEntry();
    }
    
    @Override
    public boolean canReadEntryData(final ArchiveEntry ae) {
        if (ae instanceof ZipArchiveEntry) {
            final ZipArchiveEntry ze = (ZipArchiveEntry) ae;
            return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze) && supportsCompressedSizeFor(ze);
        }
        
        return false;
    }
    
    @Override
    public int read(final byte[] buffer, final int offset, final int length) throws IOException {
        if (closed) {
            throw new IOException("The stream is closed");
        }
        
        if (current == null) {
            return -1;
        }
        
        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {
            throw new ArrayIndexOutOfBoundsException();
        }
        
        ZipUtil.checkRequestedFeatures(current.entry);
        if (!supportsDataDescriptorFor(current.entry)) {
            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);
        }
        
        if (!supportsCompressedSizeFor(current.entry)) {
            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE, current.entry);
        }
        
        int read;
        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
            read = readStored(buffer, offset, length);
        }
         else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
            read = readDeflated(buffer, offset, length);
        }
         else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            read = current.in.read(buffer, offset, length);
        }
         else {
            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);
        }
        
        if (read >= 0) {
            current.crc.update(buffer, offset, read);
            uncompressedCount += read;
        }
        
        return read;
    }
    
    @Override
    public long getCompressedCount() {
        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {
            return current.bytesRead;
        }
         else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {
            return getBytesInflated();
        }
         else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {
            return ((UnshrinkingInputStream) current.in).getCompressedCount();
        }
         else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {
            return ((ExplodingInputStream) current.in).getCompressedCount();
        }
         else if (current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {
            return ((Deflate64CompressorInputStream) current.in).getCompressedCount();
        }
         else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {
            return ((BZip2CompressorInputStream) current.in).getCompressedCount();
        }
         else {
            return -1;
        }
        
    }
    
    @Override
    public long getUncompressedCount() {
        return uncompressedCount;
    }
    
    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {
        if (current.hasDataDescriptor) {
            if (lastStoredEntry == null) {
                readStoredEntry();
            }
            
            return lastStoredEntry.read(buffer, offset, length);
        }
        
        final long csize = current.entry.getSize();
        if (current.bytesRead >= csize) {
            return -1;
        }
        
        if (buf.position() >= buf.limit()) {
            buf.position(0);
            final int l = in.read(buf.array());
            if (l == -1) {
                return -1;
            }
            
            buf.limit(l);
            count(l);
            current.bytesReadFromStream += l;
        }
        
        int toRead = Math.min(buf.remaining(), length);
        if ((csize - current.bytesRead) < toRead) {
            toRead = (int) (csize - current.bytesRead);
        }
        
        buf.get(buffer, offset, toRead);
        current.bytesRead += toRead;
        return toRead;
    }
    
    private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {
        final int read = readFromInflater(buffer, offset, length);
        if (read <= 0) {
            if (inf.finished()) {
                return -1;
            }
             else if (inf.needsDictionary()) {
                throw new ZipException("This archive needs a preset dictionary" + " which is not supported by Commons" + " Compress.");
            }
             else if (read == -1) {
                throw new IOException("Truncated ZIP file");
            }
            
        }
        
        return read;
    }
    
    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {
        int read = 0;
        do {
            if (inf.needsInput()) {
                final int l = fill();
                if (l > 0) {
                    current.bytesReadFromStream += buf.limit();
                }
                 else if (l == -1) {
                    return -1;
                }
                 else {
                    break;
                }
                
            }
            
            try {
                read = inf.inflate(buffer, offset, length);
            }
             catch (final DataFormatException e) {
                throw (IOException) new ZipException(e.getMessage()).initCause(e);
            }
            
        }
         while (read == 0 && inf.needsInput());
        return read;
    }
    
    @Override
    public void close() throws IOException {
        if (!closed) {
            closed = true;
            try {
                in.close();
            }
             finally {
                inf.end();
            }
            
        }
        
    }
    
    @Override
    public long skip(final long value) throws IOException {
        if (value >= 0) {
            long skipped = 0;
            while (skipped < value) {
                final long rem = value - skipped;
                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));
                if (x == -1) {
                    return skipped;
                }
                
                skipped += x;
            }
            
            return skipped;
        }
        
        throw new IllegalArgumentException();
    }
    
    public static boolean matches(final byte[] signature, final int length) {
        if (length < ZipArchiveOutputStream.LFH_SIG.length) {
            return false;
        }
        
        return checksig(signature, ZipArchiveOutputStream.LFH_SIG)  || checksig(signature, ZipArchiveOutputStream.EOCD_SIG)  || checksig(signature, ZipArchiveOutputStream.DD_SIG)  || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());
    }
    
    private static boolean checksig(final byte[] signature, final byte[] expected) {
        for (int i = 0; i < expected.length; i++) {
            if (signature[i] != expected[i]) {
                return false;
            }
            
        }
        
        return true;
    }
    
    private void closeEntry() throws IOException {
        if (closed) {
            throw new IOException("The stream is closed");
        }
        
        if (current == null) {
            return;
        }
        
        if (currentEntryHasOutstandingBytes()) {
            drainCurrentEntryData();
        }
         else {
            skip(Long.MAX_VALUE); 
            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED ? getBytesInflated() : current.bytesRead;
            final int diff = (int) (current.bytesReadFromStream - inB);
            if (diff > 0) {
                pushback(buf.array(), buf.limit() - diff, diff);
                current.bytesReadFromStream -= diff;
            }
            
            if (currentEntryHasOutstandingBytes()) {
                drainCurrentEntryData();
            }
            
        }
        
        if (lastStoredEntry == null && current.hasDataDescriptor) {
            readDataDescriptor();
        }
        
        inf.reset();
        buf.clear().flip();
        current = null;
        lastStoredEntry = null;
    }
    
    private boolean currentEntryHasOutstandingBytes() {
        return current.bytesReadFromStream <= current.entry.getCompressedSize() && !current.hasDataDescriptor;
    }
    
    private void drainCurrentEntryData() throws IOException {
        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;
        while (remaining > 0) {
            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));
            if (n < 0) {
                throw new EOFException("Truncated ZIP entry: " + ArchiveUtils.sanitize(current.entry.getName()));
            }
            
            count(n);
            remaining -= n;
        }
        
    }
    
    private long getBytesInflated() {
        long inB = inf.getBytesRead();
        if (current.bytesReadFromStream >= TWO_EXP_32) {
            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {
                inB += TWO_EXP_32;
            }
            
        }
        
        return inB;
    }
    
    private int fill() throws IOException {
        if (closed) {
            throw new IOException("The stream is closed");
        }
        
        final int length = in.read(buf.array());
        if (length > 0) {
            buf.limit(length);
            count(buf.limit());
            inf.setInput(buf.array(), 0, buf.limit());
        }
        
        return length;
    }
    
    private void readFully(final byte[] b) throws IOException {
        readFully(b, 0);
    }
    
    private void readFully(final byte[] b, final int off) throws IOException {
        final int len = b.length - off;
        final int count = IOUtils.readFully(in, b, off, len);
        count(count);
        if (count < len) {
            throw new EOFException();
        }
        
    }
    
    private void readDataDescriptor() throws IOException {
        readFully(wordBuf);
        ZipLong val = new ZipLong(wordBuf);
        if (ZipLong.DD_SIG.equals(val)) {
            readFully(wordBuf);
            val = new ZipLong(wordBuf);
        }
        
        current.entry.setCrc(val.getValue());
        readFully(twoDwordBuf);
        final ZipLong potentialSig = new ZipLong(twoDwordBuf, DWORD);
        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {
            pushback(twoDwordBuf, DWORD, DWORD);
            current.entry.setCompressedSize(ZipLong.getValue(twoDwordBuf));
            current.entry.setSize(ZipLong.getValue(twoDwordBuf, WORD));
        }
         else {
            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(twoDwordBuf));
            current.entry.setSize(ZipEightByteInteger.getLongValue(twoDwordBuf, DWORD));
        }
        
    }
    
    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {
        return !entry.getGeneralPurposeBit().usesDataDescriptor() || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED) || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();
    }
    
    private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {
        return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN || entry.getMethod() == ZipEntry.DEFLATED || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || (entry.getGeneralPurposeBit().usesDataDescriptor() && allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED);
    }
    
    private void readStoredEntry() throws IOException {
        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        int off = 0;
        boolean done = false;
        final int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;
        while (!done) {
            final int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);
            if (r <= 0) {
                throw new IOException("Truncated ZIP file");
            }
            
            if (r + off < 4) {
                off += r;
                continue;
            }
            
            done = bufferContainsSignature(bos, off, r, ddLen);
            if (!done) {
                off = cacheBytesRead(bos, off, r, ddLen);
            }
            
        }
        
        final byte[] b = bos.toByteArray();
        lastStoredEntry = new ByteArrayInputStream(b);
    }
    
    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();
    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();
    private static final byte[] DD = ZipLong.DD_SIG.getBytes();
    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen) throws IOException {
        boolean done = false;
        int readTooMuch = 0;
        for (int i = 0; !done && i < offset + lastRead - 4; i++) {
            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {
                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3]) || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {
                    readTooMuch = offset + lastRead - i - expectedDDLen;
                    done = true;
                }
                
                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {
                    readTooMuch = offset + lastRead - i;
                    done = true;
                }
                
                if (done) {
                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);
                    bos.write(buf.array(), 0, i);
                    readDataDescriptor();
                }
                
            }
            
        }
        
        return done;
    }
    
    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {
        final int cacheable = offset + lastRead - expecteDDLen - 3;
        if (cacheable > 0) {
            bos.write(buf.array(), 0, cacheable);
            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);
            offset = expecteDDLen + 3;
        }
         else {
            offset += lastRead;
        }
        
        return offset;
    }
    
    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {
        ((PushbackInputStream) in).unread(buf, offset, length);
        pushedBackBytes(length);
    }
    
    private void skipRemainderOfArchive() throws IOException {
        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);
        findEocdRecord();
        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD  - SHORT );
        readFully(shortBuf);
        realSkip(ZipShort.getValue(shortBuf));
    }
    
    private void findEocdRecord() throws IOException {
        int currentByte = -1;
        boolean skipReadCall = false;
        while (skipReadCall || (currentByte = readOneByte()) > -1) {
            skipReadCall = false;
            if (!isFirstByteOfEocdSig(currentByte)) {
                continue;
            }
            
            currentByte = readOneByte();
            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {
                if (currentByte == -1) {
                    break;
                }
                
                skipReadCall = isFirstByteOfEocdSig(currentByte);
                continue;
            }
            
            currentByte = readOneByte();
            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {
                if (currentByte == -1) {
                    break;
                }
                
                skipReadCall = isFirstByteOfEocdSig(currentByte);
                continue;
            }
            
            currentByte = readOneByte();
            if (currentByte == -1 || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {
                break;
            }
            
            skipReadCall = isFirstByteOfEocdSig(currentByte);
        }
        
    }
    
    private void realSkip(final long value) throws IOException {
        if (value >= 0) {
            long skipped = 0;
            while (skipped < value) {
                final long rem = value - skipped;
                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));
                if (x == -1) {
                    return;
                }
                
                count(x);
                skipped += x;
            }
            
            return;
        }
        
        throw new IllegalArgumentException();
    }
    
    private int readOneByte() throws IOException {
        final int b = in.read();
        if (b != -1) {
            count(1);
        }
        
        return b;
    }
    
    private boolean isFirstByteOfEocdSig(final int b) {
        return b == ZipArchiveOutputStream.EOCD_SIG[0];
    }
    
    private static final byte[] APK_SIGNING_BLOCK_MAGIC = new byte[] {         'A', 'P', 'K', ' ', 'S', 'i', 'g', ' ', 'B', 'l', 'o', 'c', 'k', ' ', '4', '2', };
    private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);
    private boolean isApkSigningBlock(byte[] suspectLocalFileHeader) throws IOException {
        BigInteger len = ZipEightByteInteger.getValue(suspectLocalFileHeader);
        BigInteger toSkip = len.add(BigInteger.valueOf(DWORD - suspectLocalFileHeader.length - APK_SIGNING_BLOCK_MAGIC.length));
        byte[] magic = new byte[APK_SIGNING_BLOCK_MAGIC.length];
        try {
            if (toSkip.signum() < 0) {
                int off = suspectLocalFileHeader.length + toSkip.intValue();
                if (off < DWORD) {
                    return false;
                }
                
                int bytesInBuffer = Math.abs(toSkip.intValue());
                System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));
                if (bytesInBuffer < magic.length) {
                    readFully(magic, bytesInBuffer);
                }
                
            }
             else {
                while (toSkip.compareTo(LONG_MAX) > 0) {
                    realSkip(Long.MAX_VALUE);
                    toSkip = toSkip.add(LONG_MAX.negate());
                }
                
                realSkip(toSkip.longValue());
                readFully(magic);
            }
            
        }
         catch (EOFException ex) {
            return false;
        }
        
        return Arrays.equals(magic, APK_SIGNING_BLOCK_MAGIC);
    }
    
    private static final class CurrentEntry {
        private final ZipArchiveEntry entry = new ZipArchiveEntry();
        private boolean hasDataDescriptor;
        private boolean usesZip64;
        private long bytesRead;
        private long bytesReadFromStream;
        private final CRC32 crc = new CRC32();
        private InputStream in;
    }
    
    private class BoundedInputStream extends InputStream {
        private final InputStream in;
        private final long max;
        private long pos = 0;
        public BoundedInputStream(final InputStream in, final long size) {
            this.max = size;
            this.in = in;
        }
        
        @Override
        public int read() throws IOException {
            if (max >= 0 && pos >= max) {
                return -1;
            }
            
            final int result = in.read();
            pos++;
            count(1);
            current.bytesReadFromStream++;
            return result;
        }
        
        @Override
        public int read(final byte[] b) throws IOException {
            return this.read(b, 0, b.length);
        }
        
        @Override
        public int read(final byte[] b, final int off, final int len) throws IOException {
            if (max >= 0 && pos >= max) {
                return -1;
            }
            
            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;
            final int bytesRead = in.read(b, off, (int) maxRead);
            if (bytesRead == -1) {
                return -1;
            }
            
            pos += bytesRead;
            count(bytesRead);
            current.bytesReadFromStream += bytesRead;
            return bytesRead;
        }
        
        @Override
        public long skip(final long n) throws IOException {
            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;
            final long skippedBytes = IOUtils.skip(in, toSkip);
            pos += skippedBytes;
            return skippedBytes;
        }
        
        @Override
        public int available() throws IOException {
            if (max >= 0 && pos >= max) {
                return 0;
            }
            
            return in.available();
        }
        
    }
    
}


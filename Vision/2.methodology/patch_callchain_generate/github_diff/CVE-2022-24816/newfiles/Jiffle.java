package it.geosolutions.jaiext.jiffle;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.tree.ParseTree;
import org.codehaus.janino.SimpleCompiler;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import it.geosolutions.jaiext.jiffle.parser.ExpressionWorker;
import it.geosolutions.jaiext.jiffle.parser.ImagesBlockWorker;
import it.geosolutions.jaiext.jiffle.parser.InitBlockWorker;
import it.geosolutions.jaiext.jiffle.parser.JiffleLexer;
import it.geosolutions.jaiext.jiffle.parser.JiffleParser;
import it.geosolutions.jaiext.jiffle.parser.JiffleParserErrorListener;
import it.geosolutions.jaiext.jiffle.parser.Messages;
import it.geosolutions.jaiext.jiffle.parser.OptionsBlockWorker;
import it.geosolutions.jaiext.jiffle.parser.RuntimeModelWorker;
import it.geosolutions.jaiext.jiffle.parser.SourcePositionsWorker;
import it.geosolutions.jaiext.jiffle.parser.VarWorker;
import it.geosolutions.jaiext.jiffle.parser.node.GetSourceValue;
import it.geosolutions.jaiext.jiffle.parser.node.Script;
import it.geosolutions.jaiext.jiffle.parser.node.SourceWriter;
import it.geosolutions.jaiext.jiffle.runtime.JiffleDirectRuntime;
import it.geosolutions.jaiext.jiffle.runtime.JiffleIndirectRuntime;
import it.geosolutions.jaiext.jiffle.runtime.JiffleRuntime;
public class Jiffle {
    public static final Logger LOGGER = Logger.getLogger(Jiffle.class.getName());
    boolean includeScript;
    public static enum RuntimeModel {
        DIRECT(JiffleDirectRuntime.class), INDIRECT(JiffleIndirectRuntime.class);
        private Class<? extends JiffleRuntime> runtimeClass;
        private RuntimeModel(Class<? extends JiffleRuntime> clazz) {
            this.runtimeClass = clazz;
        }
        
        public Class<? extends JiffleRuntime> getRuntimeClass() {
            return runtimeClass;
        }
        
        public static Jiffle.RuntimeModel get(Class<? extends JiffleRuntime> clazz) {
            for (Jiffle.RuntimeModel t : Jiffle.RuntimeModel.values()) {
                if (t.runtimeClass.isAssignableFrom(clazz)) {
                    return t;
                }
                
            }
            
            return null;
        }
        
    }
    
    private static int refCount = 0;
    public static enum ImageRole {
        SOURCE, DEST;
    }
    
    private String name;
    private String theScript;
    private Script scriptModel;
    private Map<String, Jiffle.ImageRole> imageParams;
    private Map<String, Integer> destinationBands;
    public Jiffle() {
        init();
    }
    
    public Jiffle(String script, Map<String, Jiffle.ImageRole> params) throws it.geosolutions.jaiext.jiffle.JiffleException {
        init();
        setScript(script);
        setImageParams(params);
        compile();
    }
    
    public Jiffle(File scriptFile, Map<String, Jiffle.ImageRole> params) throws it.geosolutions.jaiext.jiffle.JiffleException {
        init();
        setScript(scriptFile);
        setImageParams(params);
        compile();
    }
    
    public boolean isIncludeScript() {
        return includeScript;
    }
    
    public void setIncludeScript(boolean includeScript) {
        this.includeScript = includeScript;
    }
    
    public final void setScript(String script) throws it.geosolutions.jaiext.jiffle.JiffleException {
        if (script == null || script.trim().length() == 0) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException("script is empty !");
        }
        
        clearCompiledObjects();
        theScript = script + "\n";
    }
    
    public final void setScript(File scriptFile) throws it.geosolutions.jaiext.jiffle.JiffleException {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(scriptFile));
            StringBuilder sb = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.length() > 0) {
                    sb.append(line);
                    sb.append('\n');  
                }
                
            }
            
            setScript(sb.toString());
        }
         catch (IOException ex) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException("Could not read the script file", ex);
        }
         finally {
            if (reader != null) {
                try {
                    reader.close();
                }
                 catch (IOException ignored) {
                }
                
            }
            
        }
        
    }
    
    public String getScript() {
        return theScript == null ? "" : theScript;
    }
    
    public final void setImageParams(Map<String, Jiffle.ImageRole> params) {
        imageParams.clear();
        imageParams.putAll(params);
    }
    
    public Map<String, Jiffle.ImageRole> getImageParams() {
        return Collections.unmodifiableMap(imageParams);
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public final void compile() throws it.geosolutions.jaiext.jiffle.JiffleException {
        if (theScript == null) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException("No script has been set");
        }
        
        Jiffle.Result<ParseTree> parseResult = parseScript(theScript);
        if (parseResult.messages.isError()) {
            reportMessages(parseResult);
            return;
        }
        
        ParseTree tree = parseResult.result;
        if (imageParams.isEmpty()) {
            Jiffle.Result<Map<String, Jiffle.ImageRole>> r = getScriptImageParams( tree);
            if (r.messages.isError()) {
                reportMessages(r);
                return;
            }
            
            if (r.result.isEmpty()) {
                throw new it.geosolutions.jaiext.jiffle.JiffleException( "No image parameters provided and none found in script");
            }
            
            setImageParams(r.result);
        }
        
        OptionsBlockWorker optionsWorker = new OptionsBlockWorker(tree);
        reportMessages(optionsWorker.messages);
        InitBlockWorker initWorker = new InitBlockWorker(tree);
        reportMessages(initWorker.messages);
        VarWorker vw = new VarWorker(tree, imageParams);
        ExpressionWorker expressionWorker = new ExpressionWorker(tree, vw);
        reportMessages(expressionWorker.messages);
        RuntimeModelWorker worker = new RuntimeModelWorker(tree, optionsWorker.options, expressionWorker.getProperties(), expressionWorker.getScopes());
        this.scriptModel = worker.getScriptNode();
        this.destinationBands = worker.getDestinationBands();
    }
    
    public boolean isCompiled() {
        return scriptModel != null;
    }
    
    public JiffleDirectRuntime getRuntimeInstance() throws it.geosolutions.jaiext.jiffle.JiffleException {
        return (JiffleDirectRuntime) getRuntimeInstance(RuntimeModel.DIRECT);
    }
    
    public JiffleRuntime getRuntimeInstance(Jiffle.RuntimeModel model) throws it.geosolutions.jaiext.jiffle.JiffleException {
        return createRuntimeInstance(model, getRuntimeBaseClass(model), includeScript);
    }
    
    public <T extends JiffleRuntime> T getRuntimeInstance(Class<T> baseClass) throws it.geosolutions.jaiext.jiffle.JiffleException {
        RuntimeModel model = RuntimeModel.get(baseClass);
        if (model == null) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException(baseClass.getName() + " does not implement a required Jiffle runtime interface");
        }
        
        return (T) createRuntimeInstance(model, baseClass, includeScript);
    }
    
    private JiffleRuntime createRuntimeInstance(RuntimeModel model, Class<? extends JiffleRuntime> runtimeClass, boolean scriptInDocs) throws it.geosolutions.jaiext.jiffle.JiffleException {
        if (!isCompiled()) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException("The script has not been compiled");
        }
        
        String runtimeSource = createRuntimeSource(model, runtimeClass.getName(), scriptInDocs);
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.log(Level.FINE, "Jiffle script compiled to:\n\n" + runtimeSource);    
        }
        
        try {
            SimpleCompiler compiler = new SimpleCompiler();
            compiler.cook(runtimeSource);
            StringBuilder sb = new StringBuilder();
            sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get( it.geosolutions.jaiext.jiffle.JiffleProperties.RUNTIME_PACKAGE_KEY)).append(".");
            switch (model) {
                case DIRECT:
                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get( it.geosolutions.jaiext.jiffle.JiffleProperties.DIRECT_CLASS_KEY));
                    break;
                case INDIRECT:
                    sb.append(it.geosolutions.jaiext.jiffle.JiffleProperties.get( it.geosolutions.jaiext.jiffle.JiffleProperties.INDIRECT_CLASS_KEY));
                    break;
                default: throw new IllegalArgumentException("Internal compiler error");
            }
            
            Class<?> clazz = compiler.getClassLoader().loadClass(sb.toString());
            JiffleRuntime runtime = (JiffleRuntime) clazz.newInstance();
            runtime.setImageParams(imageParams);
            if (runtime instanceof JiffleIndirectRuntime) {
                ((JiffleIndirectRuntime) runtime).setDestinationBands(destinationBands);
            }
            
            return runtime;
        }
         catch (Exception ex) {
            if (model == RuntimeModel.INDIRECT) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Runtime source error for source: " + runtimeSource);
                }
                
                throw new JiffleException("Runtime source error", ex);
            }
            
            throw new JiffleException("Runtime source error for source: " + runtimeSource, ex);
        }
        
    }
    
    public String getRuntimeSource(boolean scriptInDocs) throws it.geosolutions.jaiext.jiffle.JiffleException {
        return getRuntimeSource(RuntimeModel.DIRECT, scriptInDocs);
    }
    
    public String getRuntimeSource(Jiffle.RuntimeModel model, boolean scriptInDocs) throws it.geosolutions.jaiext.jiffle.JiffleException {
        return createRuntimeSource(model, getRuntimeBaseClass(model).getName(), scriptInDocs);
    }
    
    private Class<? extends JiffleRuntime> getRuntimeBaseClass(RuntimeModel model) {
        Class<? extends JiffleRuntime> baseClass = null;
        switch (model) {
            case DIRECT:
                baseClass = it.geosolutions.jaiext.jiffle.JiffleProperties.DEFAULT_DIRECT_BASE_CLASS;
                break;
            case INDIRECT:
                baseClass = it.geosolutions.jaiext.jiffle.JiffleProperties.DEFAULT_INDIRECT_BASE_CLASS;
                break;
        }
        
        return baseClass;
    }
    
    private String createRuntimeSource(RuntimeModel model, String baseClassName, boolean scriptInDocs) {
        SourceWriter writer = new SourceWriter(model);
        if (scriptInDocs) {
            writer.setScript(theScript);
        }
        
        writer.setBaseClassName(baseClassName);
        scriptModel.write(writer);
        return writer.getSource();
    }
    
    private void init() {
        Jiffle.refCount++ ;
        imageParams = new HashMap<String, Jiffle.ImageRole>();
    }
    
    private void clearCompiledObjects() {
    }
    
    private static Jiffle.Result<ParseTree> parseScript(String script) {
        CharStream input = CharStreams.fromString(script);
        JiffleLexer lexer = new JiffleLexer(input);
        TokenStream tokens = new CommonTokenStream(lexer);
        JiffleParser parser = new JiffleParser(tokens);
        parser.removeErrorListeners();
        JiffleParserErrorListener errListener = new JiffleParserErrorListener();
        parser.addErrorListener(errListener);
        ParseTree tree = parser.script();
        return new Jiffle.Result(tree, errListener.messages);
    }
    
    private static Jiffle.Result<Map<String, Jiffle.ImageRole>> getScriptImageParams(ParseTree tree) {
        ImagesBlockWorker reader = new ImagesBlockWorker(tree);
        return new Jiffle.Result(reader.imageVars, reader.messages);
    }
    
    private static void reportMessages(Jiffle.Result result) throws it.geosolutions.jaiext.jiffle.JiffleException {
        reportMessages(result.messages);
    }
    
    private static void reportMessages(Messages messages) throws it.geosolutions.jaiext.jiffle.JiffleException {
        if (messages.isError()) {
            String expectionMessage = messages.toString();
            throw new it.geosolutions.jaiext.jiffle.JiffleException(expectionMessage);
        }
        
    }
    
    private static class Result<T> {
        final T result;
        final Messages messages;
        public Result(T result, Messages messages) {
            this.result = result;
            this.messages = messages;
        }
        
    }
    
    public static Set<GetSourceValue> getReadPositions(String script, List<String> sourceImageNames) throws JiffleException {
        Jiffle.Result<ParseTree> parseResult = parseScript(script);
        if (parseResult.messages.isError()) {
            reportMessages(parseResult);
            return Collections.emptySet();
        }
        
        ParseTree tree = parseResult.result;
        if (sourceImageNames == null) {
            Jiffle.Result<Map<String, Jiffle.ImageRole>> r = getScriptImageParams(tree);
            sourceImageNames = r.result .entrySet() .stream() .filter(k -> k.getValue() == ImageRole.SOURCE) .map(k -> k.getKey()) .collect(Collectors.toList());
        }
        
        if (sourceImageNames.isEmpty()) {
            return Collections.emptySet();
        }
        
        SourcePositionsWorker worker = new SourcePositionsWorker(tree, sourceImageNames);
        Set<GetSourceValue> positions = worker.getPositions();
        return positions;
    }
    
}


package com.vaadin.flow.component.treegrid;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import com.vaadin.flow.component.ClientCallable;
import com.vaadin.flow.component.Component;
import com.vaadin.flow.component.ComponentEventListener;
import com.vaadin.flow.component.ComponentUtil;
import com.vaadin.flow.component.dependency.JsModule;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.grid.GridArrayUpdater;
import com.vaadin.flow.component.grid.GridArrayUpdater.UpdateQueueData;
import com.vaadin.flow.component.grid.dataview.GridDataView;
import com.vaadin.flow.component.grid.dataview.GridLazyDataView;
import com.vaadin.flow.component.grid.dataview.GridListDataView;
import com.vaadin.flow.data.binder.PropertyDefinition;
import com.vaadin.flow.data.provider.BackEndDataProvider;
import com.vaadin.flow.data.provider.CallbackDataProvider;
import com.vaadin.flow.data.provider.CompositeDataGenerator;
import com.vaadin.flow.data.provider.DataChangeEvent;
import com.vaadin.flow.data.provider.DataCommunicator;
import com.vaadin.flow.data.provider.DataProvider;
import com.vaadin.flow.data.provider.ListDataProvider;
import com.vaadin.flow.data.provider.hierarchy.HasHierarchicalDataProvider;
import com.vaadin.flow.data.provider.hierarchy.HierarchicalArrayUpdater.HierarchicalUpdate;
import com.vaadin.flow.data.provider.hierarchy.HierarchicalDataCommunicator;
import com.vaadin.flow.data.provider.hierarchy.HierarchicalDataProvider;
import com.vaadin.flow.data.provider.hierarchy.HierarchicalQuery;
import com.vaadin.flow.data.provider.hierarchy.TreeData;
import com.vaadin.flow.data.renderer.ComponentRenderer;
import com.vaadin.flow.data.renderer.TemplateRenderer;
import com.vaadin.flow.dom.DisabledUpdateMode;
import com.vaadin.flow.dom.Element;
import com.vaadin.flow.function.SerializableBiFunction;
import com.vaadin.flow.function.SerializableComparator;
import com.vaadin.flow.function.SerializableConsumer;
import com.vaadin.flow.function.SerializablePredicate;
import com.vaadin.flow.function.SerializableSupplier;
import com.vaadin.flow.function.ValueProvider;
import com.vaadin.flow.internal.JsonUtils;
import com.vaadin.flow.server.VaadinRequest;
import com.vaadin.flow.shared.Registration;
import elemental.json.JsonArray;
import elemental.json.JsonObject;
import elemental.json.JsonValue;
@JsModule("@vaadin/grid/src/vaadin-grid-tree-toggle.js")
public class TreeGrid<T> extends Grid<T> implements HasHierarchicalDataProvider<T> {
    private static final class TreeGridUpdateQueue extends UpdateQueue implements HierarchicalUpdate {
        private SerializableConsumer<List<JsonValue>> arrayUpdateListener;
        private TreeGridUpdateQueue(UpdateQueueData data, int size) {
            super(data, size);
        }
        
        public void setArrayUpdateListener( SerializableConsumer<List<JsonValue>> arrayUpdateListener) {
            this.arrayUpdateListener = arrayUpdateListener;
        }
        
        @Override
        public void set(int start, List<JsonValue> items) {
            super.set(start, items);
            if (arrayUpdateListener != null) {
                arrayUpdateListener.accept(items);
            }
            
        }
        
        @Override
        public void set(int start, List<JsonValue> items, String parentKey) {
            enqueue("$connector.set", start, items.stream().collect(JsonUtils.asArray()), parentKey);
            if (arrayUpdateListener != null) {
                arrayUpdateListener.accept(items);
            }
            
        }
        
        @Override
        public void clear(int start, int length) {
            if (!getData().getHasExpandedItems().get()) {
                enqueue("$connector.clearExpanded");
            }
            
            super.clear(start, length);
        }
        
        @Override
        public void clear(int start, int length, String parentKey) {
            enqueue("$connector.clear", start, length, parentKey);
        }
        
        @Override
        public void commit(int updateId, String parentKey, int levelSize) {
            enqueue("$connector.confirmParent", updateId, parentKey, levelSize);
            commit();
        }
        
    }
    
    private class TreeGridArrayUpdaterImpl implements TreeGridArrayUpdater {
        private UpdateQueueData data;
        private SerializableBiFunction<UpdateQueueData, Integer, UpdateQueue> updateQueueFactory;
        private final int EAGER_FETCH_VIEWPORT_SIZE_ESTIMATE = 40;
        private int viewportRemaining = 0;
        private final List<JsonValue> queuedParents = new ArrayList<>();
        private VaadinRequest previousRequest;
        public TreeGridArrayUpdaterImpl( SerializableBiFunction<UpdateQueueData, Integer, UpdateQueue> updateQueueFactory) {
            this.updateQueueFactory = updateQueueFactory;
        }
        
        @Override
        public TreeGridUpdateQueue startUpdate(int sizeChange) {
            TreeGridUpdateQueue queue = (TreeGridUpdateQueue) updateQueueFactory .apply(data, sizeChange);
            if (VaadinRequest.getCurrent() != null && !VaadinRequest.getCurrent().equals(previousRequest)) {
                viewportRemaining = EAGER_FETCH_VIEWPORT_SIZE_ESTIMATE;
                queuedParents.clear();
                previousRequest = VaadinRequest.getCurrent();
            }
            
            queue.setArrayUpdateListener((items) -> {
                queuedParents.addAll(0, items);
                while (viewportRemaining > 0 && !queuedParents.isEmpty()) {
                    viewportRemaining--;
                    JsonObject parent = (JsonObject) queuedParents.remove(0);
                    T parentItem = getDataCommunicator().getKeyMapper() .get(parent.getString("key"));
                    if (isExpanded(parentItem)) {
                        int childLength = Math.max( EAGER_FETCH_VIEWPORT_SIZE_ESTIMATE, getPageSize());
                        getDataCommunicator().setParentRequestedRange(0, childLength, parentItem);
                        break;
                    }
                    
                }
                
            }
            
);
            return queue;
        }
        
        @Override
        public void initialize() {
            initConnector();
            updateSelectionModeOnClient();
            getDataCommunicator().setRequestedRange(0, getPageSize());
        }
        
        @Override
        public void setUpdateQueueData(UpdateQueueData data) {
            this.data = data;
        }
        
        @Override
        public UpdateQueueData getUpdateQueueData() {
            return data;
        }
        
    }
    
    private final AtomicLong uniqueKeyCounter = new AtomicLong(0);
    private final Map<Object, Long> objectUniqueKeyMap = new HashMap<>();
    ValueProvider<T, String> defaultUniqueKeyProvider = item -> String.valueOf( objectUniqueKeyMap.computeIfAbsent(getDataProvider().getId(item), key -> uniqueKeyCounter.getAndIncrement()));
    private Registration dataProviderRegistration;
    public TreeGrid() {
        super(50, TreeGridUpdateQueue::new, new TreeDataCommunicatorBuilder<T>());
        setUniqueKeyProperty("key");
        getArrayUpdater().getUpdateQueueData() .setHasExpandedItems(getDataCommunicator()::hasExpandedItems);
    }
    
    public TreeGrid(Class<T> beanType) {
        super(beanType, TreeGridUpdateQueue::new, new TreeDataCommunicatorBuilder<T>());
        setUniqueKeyProperty("key");
        getArrayUpdater().getUpdateQueueData() .setHasExpandedItems(getDataCommunicator()::hasExpandedItems);
    }
    
    @Override
    protected GridArrayUpdater createDefaultArrayUpdater( SerializableBiFunction<UpdateQueueData, Integer, UpdateQueue> updateQueueFactory) {
        return new TreeGridArrayUpdaterImpl(updateQueueFactory);
    }
    
    public TreeGrid(HierarchicalDataProvider<T, ?> dataProvider) {
        this();
        setDataProvider(dataProvider);
    }
    
    private static class TreeDataCommunicatorBuilder<T> extends DataCommunicatorBuilder<T, TreeGridArrayUpdater> {
        @Override
        protected DataCommunicator<T> build(Element element, CompositeDataGenerator<T> dataGenerator, TreeGridArrayUpdater arrayUpdater, SerializableSupplier<ValueProvider<T, String>> uniqueKeyProviderSupplier) {
            return new HierarchicalDataCommunicator<>(dataGenerator, arrayUpdater, data -> element.callJsFunction( "$connector.updateHierarchicalData", data), element.getNode(), uniqueKeyProviderSupplier);
        }
        
    }
    
    public void setUniqueKeyDataGenerator(String propertyName, ValueProvider<T, String> uniqueKeyProvider) {
        setUniqueKeyProperty(propertyName);
        setUniqueKeyProvider(uniqueKeyProvider);
        getDataProvider().refreshAll();
    }
    
    @Override
    protected ValueProvider<T, String> getUniqueKeyProvider() {
        return Optional.ofNullable(super.getUniqueKeyProvider()) .orElse(defaultUniqueKeyProvider);
    }
    
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public Registration addExpandListener( ComponentEventListener<ExpandEvent<T, TreeGrid<T>>> listener) {
        return ComponentUtil.addListener(this, ExpandEvent.class, (ComponentEventListener) listener);
    }
    
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public Registration addCollapseListener( ComponentEventListener<CollapseEvent<T, TreeGrid<T>>> listener) {
        return ComponentUtil.addListener(this, CollapseEvent.class, (ComponentEventListener) listener);
    }
    
    @Override
    public void setDataProvider(DataProvider<T, ?> dataProvider) {
        if (dataProvider instanceof HierarchicalDataProvider) {
            this.setDataProvider((HierarchicalDataProvider) dataProvider);
        }
         else {
            throw new IllegalArgumentException( "TreeGrid only accepts hierarchical data providers. " + "An example of interface to be used: HierarchicalDataProvider");
        }
        
    }
    
    @Override
    public void setDataProvider( HierarchicalDataProvider<T, ?> hierarchicalDataProvider) {
        if (dataProviderRegistration != null) {
            dataProviderRegistration.remove();
        }
        
        dataProviderRegistration = hierarchicalDataProvider .addDataProviderListener(e -> {
                    if (!(e instanceof DataChangeEvent.DataRefreshEvent)) {
                        getElement().executeJs( "$0.$connector && $0.$connector.reset()", getElement());
                    }
                    
                }
                
);
        super.setDataProvider(hierarchicalDataProvider);
    }
    
    @Deprecated
    @Override
    public GridLazyDataView<T> setItems( BackEndDataProvider<T, Void> dataProvider) {
        throw new UnsupportedOperationException( "TreeGrid only accepts hierarchical data providers. " + "Use another setDataProvider/setItems method instead with hierarchical data." + "An example of interface to be used: HierarchicalDataProvider");
    }
    
    @Deprecated
    @Override
    public GridLazyDataView<T> setItems( CallbackDataProvider.FetchCallback<T, Void> fetchCallback) {
        throw new UnsupportedOperationException( "TreeGrid only accepts hierarchical data providers. " + "Use another setDataProvider/setItems method instead with hierarchical data." + "An example of interface to be used: HierarchicalDataProvider");
    }
    
    @Deprecated
    @Override
    public GridListDataView<T> setItems(ListDataProvider<T> dataProvider) {
        throw new UnsupportedOperationException( "TreeGrid only accepts hierarchical data providers. " + "Use another setDataProvider/setItems method instead with hierarchical data." + "An example of interface to be used: HierarchicalDataProvider");
    }
    
    @Deprecated
    @Override
    public GridListDataView<T> setItems(T... items) {
        throw new UnsupportedOperationException( "TreeGrid only accepts hierarchical data providers. " + "Use another setDataProvider/setItems method instead with hierarchical data." + "An example of interface to be used: HierarchicalDataProvider");
    }
    
    @Deprecated
    @Override
    public GridListDataView<T> setItems(Collection<T> items) {
        throw new UnsupportedOperationException( "TreeGrid only accepts hierarchical data providers. " + "Use another setDataProvider/setItems method instead with hierarchical data." + "An example of interface to be used: HierarchicalDataProvider");
    }
    
    @Deprecated
    @Override
    public GridListDataView<T> getListDataView() {
        throw new UnsupportedOperationException( "TreeGrid does not support list data view.");
    }
    
    @Deprecated
    @Override
    public GridLazyDataView<T> getLazyDataView() {
        throw new UnsupportedOperationException( "TreeGrid does not support lazy data view.");
    }
    
    @Deprecated
    @Override
    public GridDataView<T> getGenericDataView() {
        throw new UnsupportedOperationException( "TreeGrid does not support generic data view.");
    }
    
    public Column<T> addHierarchyColumn(ValueProvider<T, ?> valueProvider) {
        Column<T> column = addColumn(TemplateRenderer .<T> of("<vaadin-grid-tree-toggle " + "leaf='[[!item.children]]' expanded='{{expanded}}' level='[[level]]'>[[item.name]]" + "</vaadin-grid-tree-toggle>") .withProperty("children", item -> getDataCommunicator().hasChildren(item)) .withProperty("name", value -> String.valueOf(valueProvider.apply(value))));
        final SerializableComparator<T> comparator = (a, b) -> compareMaybeComparables(valueProvider.apply(a), valueProvider.apply(b));
        column.setComparator(comparator);
        return column;
    }
    
    public <V extends Component> Column<T> addComponentHierarchyColumn( ValueProvider<T, V> componentProvider) {
        return addColumn(new HierarchyColumnComponentRenderer<V, T>( componentProvider).withProperty("children", item -> getDataCommunicator().hasChildren(item)));
    }
    
    public Column<T> setHierarchyColumn(String propertyName) {
        return setHierarchyColumn(propertyName, null);
    }
    
    public Column<T> setHierarchyColumn(String propertyName, ValueProvider<T, ?> valueProvider) {
        List<String> currentPropertyList = getColumns().stream() .map(Column::getKey).filter(Objects::nonNull) .collect(Collectors.toList());
        resetColumns(propertyName, valueProvider, currentPropertyList);
        return getColumnByKey(propertyName);
    }
    
    public Column<T> setColumns(String hierarchyPropertyName, ValueProvider<T, ?> valueProvider, Collection<String> propertyNames) {
        if (getPropertySet() == null) {
            throw new UnsupportedOperationException( "This method can't be used for a Grid that isn't constructed from a bean type. " + "To construct Grid from a bean type, please provide a beanType argument" + "to the constructor: Grid<Person> grid = new Grid<>(Person.class)");
        }
        
        resetColumns(hierarchyPropertyName, valueProvider, propertyNames);
        return getColumnByKey(hierarchyPropertyName);
    }
    
    private void resetColumns(String hierarchyPropertyName, ValueProvider<T, ?> valueProvider, Collection<String> propertyList) {
        getColumns().forEach(this::removeColumn);
        propertyList.stream().distinct().forEach( key -> addColumn(key, hierarchyPropertyName, valueProvider));
    }
    
    private void addColumn(String key, String hierarchyPropertyName, ValueProvider<T, ?> valueProvider) {
        if (key.equals(hierarchyPropertyName)) {
            addHierarchyColumn(hierarchyPropertyName, valueProvider);
        }
         else {
            addColumn(key);
        }
        
    }
    
    private void addHierarchyColumn(String hierarchyPropertyName, ValueProvider<T, ?> valueProvider) {
        if (valueProvider != null) {
            addHierarchyColumn(valueProvider).setKey(hierarchyPropertyName);
        }
         else {
            addHierarchyColumn(hierarchyPropertyName);
        }
        
    }
    
    private Column<T> addHierarchyColumn(String propertyName) {
        if (getPropertySet() == null) {
            throw new UnsupportedOperationException( "This method can't be used for a Grid that isn't constructed from a bean type. " + "To construct Grid from a bean type, please provide a beanType argument" + "to the constructor: Grid<Person> grid = new Grid<>(Person.class)");
        }
        
        Objects.requireNonNull(propertyName, "Hierarchy Property name can't be null");
        PropertyDefinition<T, ?> property;
        try {
            property = getPropertySet().getProperty(propertyName).get();
        }
         catch (NoSuchElementException | IllegalArgumentException exception) {
            throw new IllegalArgumentException( "There is no such hierarchy property name in the beanType used " + "for construction of the grid:" + "Trying to get '" + propertyName + "' from '" + getPropertySet() + "'");
        }
        
        return addHierarchyColumn(property);
    }
    
    private Column<T> addHierarchyColumn(PropertyDefinition<T, ?> property) {
        Column<T> column = addHierarchyColumn( item -> String.valueOf(property.getGetter().apply(item))) .setHeader(property.getCaption());
        try {
            return column.setKey(property.getName());
        }
         catch (IllegalArgumentException exception) {
            throw new IllegalArgumentException( "Multiple columns for the same property: " + property.getName());
        }
        
    }
    
    @ClientCallable(DisabledUpdateMode.ALWAYS)
    private void setParentRequestedRange(int start, int length, String parentKey) {
        T item = getDataCommunicator().getKeyMapper().get(parentKey);
        if (item != null) {
            getDataCommunicator().setParentRequestedRange(start, length, item);
        }
        
    }
    
    @ClientCallable(DisabledUpdateMode.ALWAYS)
    private void setParentRequestedRanges(JsonArray array) {
        for (int index = 0; index < array.length(); index++) {
            JsonObject object = array.getObject(index);
            setParentRequestedRange((int) object.getNumber("firstIndex"), (int) object.getNumber("size"), object.getString("parentKey"));
        }
        
    }
    
    @ClientCallable(DisabledUpdateMode.ONLY_WHEN_ENABLED)
    private void updateExpandedState(String key, boolean expanded) {
        T item = getDataCommunicator().getKeyMapper().get(key);
        if (item != null) {
            if (expanded) {
                expand(Arrays.asList(item), true);
            }
             else {
                collapse(Arrays.asList(item), true);
            }
            
        }
        
    }
    
    @ClientCallable(DisabledUpdateMode.ALWAYS)
    private void confirmParentUpdate(int id, String parentKey) {
        getDataCommunicator().confirmUpdate(id, parentKey);
    }
    
    @SuppressWarnings("unchecked")
    public void expand(T... items) {
        expand(Arrays.asList(items));
    }
    
    public void expand(Collection<T> items) {
        expand(items, false);
    }
    
    protected void expand(Collection<T> items, boolean userOriginated) {
        Collection<T> expandedItems = getDataCommunicator().expand(items);
        fireEvent(new ExpandEvent<T, TreeGrid<T>>(this, userOriginated, expandedItems));
    }
    
    public void expandRecursively(Stream<T> items, int depth) {
        expandRecursively(items.collect(Collectors.toList()), depth);
    }
    
    public void expandRecursively(Collection<T> items, int depth) {
        getDataCommunicator() .expand(getItemsWithChildrenRecursively(items, depth));
    }
    
    @SuppressWarnings("unchecked")
    public void collapse(T... items) {
        collapse(Arrays.asList(items));
    }
    
    public void collapse(Collection<T> items) {
        collapse(items, false);
    }
    
    protected void collapse(Collection<T> items, boolean userOriginated) {
        Collection<T> collapsedItems = getDataCommunicator().collapse(items);
        fireEvent(new CollapseEvent<T, TreeGrid<T>>(this, userOriginated, collapsedItems));
    }
    
    public void collapseRecursively(Stream<T> items, int depth) {
        collapseRecursively(items.collect(Collectors.toList()), depth);
    }
    
    public void collapseRecursively(Collection<T> items, int depth) {
        getDataCommunicator() .collapse(getItemsWithChildrenRecursively(items, depth));
    }
    
    protected Collection<T> getItemsWithChildrenRecursively(Collection<T> items, int depth) {
        List<T> itemsWithChildren = new ArrayList<>();
        if (depth < 0) {
            return itemsWithChildren;
        }
        
        items.stream().filter(getDataCommunicator()::hasChildren) .forEach(item -> {
                    itemsWithChildren.add(item);
                    itemsWithChildren.addAll( getItemsWithChildrenRecursively(getDataProvider() .fetchChildren( new HierarchicalQuery<>(null, item)) .collect(Collectors.toList()), depth - 1));
                }
                
);
        return itemsWithChildren;
    }
    
    public boolean isExpanded(T item) {
        return getDataCommunicator().isExpanded(item);
    }
    
    @Override
    public HierarchicalDataCommunicator<T> getDataCommunicator() {
        return (HierarchicalDataCommunicator<T>) super.getDataCommunicator();
    }
    
    @SuppressWarnings("unchecked")
    @Override
    public HierarchicalDataProvider<T, SerializablePredicate<T>> getDataProvider() {
        if (!(super.getDataProvider() instanceof HierarchicalDataProvider)) {
            return null;
        }
        
        return (HierarchicalDataProvider<T, SerializablePredicate<T>>) super.getDataProvider();
    }
    
    @Override
    public void scrollToIndex(int rowIndex) {
        super.scrollToIndex(rowIndex);
    }
    
}


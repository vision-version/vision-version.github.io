package com.itextpdf.kernel.pdf;
import com.itextpdf.io.logs.IoLogMessageConstant;
import com.itextpdf.io.source.ByteBuffer;
import com.itextpdf.io.source.ByteUtils;
import com.itextpdf.io.source.IRandomAccessSource;
import com.itextpdf.io.source.PdfTokenizer;
import com.itextpdf.io.source.RandomAccessFileOrArray;
import com.itextpdf.io.source.RandomAccessSourceFactory;
import com.itextpdf.io.source.WindowRandomAccessSource;
import com.itextpdf.commons.utils.MessageFormatUtil;
import com.itextpdf.kernel.exceptions.PdfException;
import com.itextpdf.kernel.crypto.securityhandler.UnsupportedSecurityHandlerException;
import com.itextpdf.kernel.exceptions.KernelExceptionMessageConstant;
import com.itextpdf.kernel.exceptions.XrefCycledReferencesException;
import com.itextpdf.kernel.pdf.filters.FilterHandlers;
import com.itextpdf.kernel.pdf.filters.IFilterHandler;
import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Map;
import com.itextpdf.kernel.xmp.XMPException;
import com.itextpdf.kernel.xmp.XMPMetaFactory;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class PdfReader implements Closeable {
    public static final StrictnessLevel DEFAULT_STRICTNESS_LEVEL = StrictnessLevel.LENIENT;
    private static final String endstream1 = "endstream";
    private static final String endstream2 = "\nendstream";
    private static final String endstream3 = "\r\nendstream";
    private static final String endstream4 = "\rendstream";
    private static final byte[] endstream = ByteUtils.getIsoBytes("endstream");
    private static final byte[] endobj = ByteUtils.getIsoBytes("endobj");
    protected static boolean correctStreamLength = true;
    private boolean unethicalReading;
    private boolean memorySavingMode;
    private StrictnessLevel strictnessLevel = DEFAULT_STRICTNESS_LEVEL;
    private PdfIndirectReference currentIndirectReference;
    protected PdfTokenizer tokens;
    protected PdfEncryption decrypt;
    protected PdfVersion headerPdfVersion;
    protected long lastXref;
    protected long eofPos;
    protected PdfDictionary trailer;
    protected PdfDocument pdfDocument;
    protected PdfAConformanceLevel pdfAConformanceLevel;
    protected ReaderProperties properties;
    protected boolean encrypted = false;
    protected boolean rebuiltXref = false;
    protected boolean hybridXref = false;
    protected boolean fixedXref = false;
    protected boolean xrefStm = false;
    public PdfReader(IRandomAccessSource byteSource, ReaderProperties properties) throws IOException {
        this(byteSource, properties, false);
    }
    
    public PdfReader(InputStream is, ReaderProperties properties) throws IOException {
        this(new RandomAccessSourceFactory().createSource(is), properties, true);
    }
    
    public PdfReader(java.io.File file) throws FileNotFoundException, IOException {
        this(file.getAbsolutePath());
    }
    
    public PdfReader(InputStream is) throws IOException {
        this(is, new ReaderProperties());
    }
    
    public PdfReader(String filename, ReaderProperties properties) throws IOException {
        this( new RandomAccessSourceFactory() .setForceRead(false) .createBestSource(filename), properties, true );
    }
    
    public PdfReader(String filename) throws IOException {
        this(filename, new ReaderProperties());
    }
    
    PdfReader(IRandomAccessSource byteSource, ReaderProperties properties, boolean closeStream) throws IOException {
        this.properties = properties;
        this.tokens = getOffsetTokeniser(byteSource, closeStream);
    }
    
    public void close() throws IOException {
        tokens.close();
    }
    
    public PdfReader setUnethicalReading(boolean unethicalReading) {
        this.unethicalReading = unethicalReading;
        return this;
    }
    
    public PdfReader setMemorySavingMode(boolean memorySavingMode) {
        this.memorySavingMode = memorySavingMode;
        return this;
    }
    
    public StrictnessLevel getStrictnessLevel() {
        return strictnessLevel;
    }
    
    public PdfReader setStrictnessLevel(StrictnessLevel strictnessLevel) {
        this.strictnessLevel = strictnessLevel == null ? DEFAULT_STRICTNESS_LEVEL : strictnessLevel;
        return this;
    }
    
    public boolean isCloseStream() {
        return tokens.isCloseStream();
    }
    
    public void setCloseStream(boolean closeStream) {
        tokens.setCloseStream(closeStream);
    }
    
    public boolean hasRebuiltXref() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return rebuiltXref;
    }
    
    public boolean hasHybridXref() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return hybridXref;
    }
    
    public boolean hasXrefStm() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return xrefStm;
    }
    
    public boolean hasFixedXref() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return fixedXref;
    }
    
    public long getLastXref() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return lastXref;
    }
    
    public byte[] readStreamBytes(PdfStream stream, boolean decode) throws IOException {
        byte[] b = readStreamBytesRaw(stream);
        if (decode && b != null) {
            return decodeBytes(b, stream);
        }
         else {
            return b;
        }
        
    }
    
    public byte[] readStreamBytesRaw(PdfStream stream) throws IOException {
        PdfName type = stream.getAsName(PdfName.Type);
        if (!PdfName.XRefStm.equals(type) && !PdfName.ObjStm.equals(type))
            checkPdfStreamLength(stream);
        long offset = stream.getOffset();
        if (offset <= 0)
            return null;
        int length = stream.getLength();
        if (length <= 0)
            return new byte[0];
        RandomAccessFileOrArray file = tokens.getSafeFile();
        byte[] bytes = null;
        try {
            file.seek(stream.getOffset());
            bytes = new byte[length];
            file.readFully(bytes);
            boolean embeddedStream = pdfDocument.doesStreamBelongToEmbeddedFile(stream);
            if (decrypt != null && (!decrypt.isEmbeddedFilesOnly() || embeddedStream)) {
                PdfObject filter = stream.get(PdfName.Filter, true);
                boolean skip = false;
                if (filter != null) {
                    if (PdfName.Crypt.equals(filter)) {
                        skip = true;
                    }
                     else if (filter.getType() == PdfObject.ARRAY) {
                        PdfArray filters = (PdfArray) filter;
                        for (int k = 0; k < filters.size(); k++) {
                            if (!filters.isEmpty() && PdfName.Crypt.equals(filters.get(k, true))) {
                                skip = true;
                                break;
                            }
                            
                        }
                        
                    }
                    
                    filter.release();
                }
                
                if (!skip) {
                    decrypt.setHashKeyForNextObject(stream.getIndirectReference().getObjNumber(), stream.getIndirectReference().getGenNumber());
                    bytes = decrypt.decryptByteArray(bytes);
                }
                
            }
            
        }
         finally {
            try {
                file.close();
            }
             catch (Exception ignored) {
            }
            
        }
        
        return bytes;
    }
    
    public InputStream readStream(PdfStream stream, boolean decode) throws IOException {
        byte[] bytes = readStreamBytes(stream, decode);
        return bytes != null ? new ByteArrayInputStream(bytes) : null;
    }
    
    public static byte[] decodeBytes(byte[] b, PdfDictionary streamDictionary) {
        return decodeBytes(b, streamDictionary, FilterHandlers.getDefaultFilterHandlers());
    }
    
    public static byte[] decodeBytes(byte[] b, PdfDictionary streamDictionary, Map<PdfName, IFilterHandler> filterHandlers) {
        if (b == null) {
            return null;
        }
        
        PdfObject filter = streamDictionary.get(PdfName.Filter);
        PdfArray filters = new PdfArray();
        if (filter != null) {
            if (filter.getType() == PdfObject.NAME) {
                filters.add(filter);
            }
             else if (filter.getType() == PdfObject.ARRAY) {
                filters = ((PdfArray) filter);
            }
            
        }
        
        MemoryLimitsAwareHandler memoryLimitsAwareHandler = null;
        if (null != streamDictionary.getIndirectReference()) {
            memoryLimitsAwareHandler = streamDictionary.getIndirectReference().getDocument().memoryLimitsAwareHandler;
        }
        
        final boolean memoryLimitsAwarenessRequired = null != memoryLimitsAwareHandler && memoryLimitsAwareHandler.isMemoryLimitsAwarenessRequiredOnDecompression(filters);
        if(memoryLimitsAwarenessRequired) {
            memoryLimitsAwareHandler.beginDecompressedPdfStreamProcessing();
        }
        
        PdfArray dp = new PdfArray();
        PdfObject dpo = streamDictionary.get(PdfName.DecodeParms);
        if (dpo == null || (dpo.getType() != PdfObject.DICTIONARY && dpo.getType() != PdfObject.ARRAY)) {
            if (dpo != null) dpo.release();
            dpo = streamDictionary.get(PdfName.DP);
        }
        
        if (dpo != null) {
            if (dpo.getType() == PdfObject.DICTIONARY) {
                dp.add(dpo);
            }
             else if (dpo.getType() == PdfObject.ARRAY) {
                dp = ((PdfArray) dpo);
            }
            
            dpo.release();
        }
        
        for (int j = 0; j < filters.size(); ++j) {
            PdfName filterName = (PdfName) filters.get(j);
            IFilterHandler filterHandler = filterHandlers.get(filterName);
            if (filterHandler == null)
                throw new PdfException(KernelExceptionMessageConstant.THIS_FILTER_IS_NOT_SUPPORTED) .setMessageParams(filterName);
            PdfDictionary decodeParams;
            if (j < dp.size()) {
                PdfObject dpEntry = dp.get(j, true);
                if (dpEntry == null || dpEntry.getType() == PdfObject.NULL) {
                    decodeParams = null;
                }
                 else if (dpEntry.getType() == PdfObject.DICTIONARY) {
                    decodeParams = (PdfDictionary) dpEntry;
                }
                 else {
                    throw new PdfException(KernelExceptionMessageConstant.THIS_DECODE_PARAMETER_TYPE_IS_NOT_SUPPORTED) .setMessageParams(dpEntry.getClass().toString());
                }
                
            }
             else {
                decodeParams = null;
            }
            
            b = filterHandler.decode(b, filterName, decodeParams, streamDictionary);
            if (memoryLimitsAwarenessRequired) {
                memoryLimitsAwareHandler.considerBytesOccupiedByDecompressedPdfStream(b.length);
            }
            
        }
        
        if (memoryLimitsAwarenessRequired) {
            memoryLimitsAwareHandler.endDecompressedPdfStreamProcessing();
        }
        
        return b;
    }
    
    public RandomAccessFileOrArray getSafeFile() {
        return tokens.getSafeFile();
    }
    
    public long getFileLength() {
        return tokens.getSafeFile().length();
    }
    
    public boolean isOpenedWithFullPermission() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return !encrypted || decrypt.isOpenedWithFullPermission() || unethicalReading;
    }
    
    public long getPermissions() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        long perm = 0;
        if (encrypted && decrypt.getPermissions() != null) {
            perm = (long) decrypt.getPermissions();
        }
        
        return perm;
    }
    
    public int getCryptoMode() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        if (decrypt == null)
            return -1;
        else
            return decrypt.getCryptoMode();
    }
    
    public PdfAConformanceLevel getPdfAConformanceLevel() {
        if (pdfAConformanceLevel == null) {
            if (pdfDocument != null && pdfDocument.getXmpMetadata() != null) {
                try {
                    pdfAConformanceLevel = PdfAConformanceLevel.getConformanceLevel( XMPMetaFactory.parseFromBuffer(pdfDocument.getXmpMetadata()));
                }
                 catch (XMPException ignored) {
                }
                
            }
            
        }
        
        return pdfAConformanceLevel;
    }
    
    public byte[] computeUserPassword() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        if (!encrypted || !decrypt.isOpenedWithFullPermission()) {
            return null;
        }
        
        return decrypt.computeUserPassword(properties.password);
    }
    
    public byte[] getOriginalFileId() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        PdfArray id = trailer.getAsArray(PdfName.ID);
        if (id != null && id.size() == 2) {
            return ByteUtils.getIsoBytes(id.getAsString(0).getValue());
        }
         else {
            return new byte[0];
        }
        
    }
    
    public byte[] getModifiedFileId() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        PdfArray id = trailer.getAsArray(PdfName.ID);
        if (id != null && id.size() == 2) {
            return ByteUtils.getIsoBytes(id.getAsString(1).getValue());
        }
         else {
            return new byte[0];
        }
        
    }
    
    public boolean isEncrypted() {
        if (pdfDocument == null || !pdfDocument.getXref().isReadingCompleted()) {
            throw new PdfException(KernelExceptionMessageConstant.DOCUMENT_HAS_NOT_BEEN_READ_YET);
        }
        
        return encrypted;
    }
    
    protected void readPdf() throws IOException {
        String version = tokens.checkPdfHeader();
        try {
            this.headerPdfVersion = PdfVersion.fromString(version);
        }
         catch (IllegalArgumentException exc) {
            throw new PdfException(KernelExceptionMessageConstant.PDF_VERSION_IS_NOT_VALID, version);
        }
        
        try {
            readXref();
        }
         catch (XrefCycledReferencesException ex) {
            throw ex;
        }
         catch (RuntimeException ex) {
            Logger logger = LoggerFactory.getLogger(PdfReader.class);
            logger.error(IoLogMessageConstant.XREF_ERROR_WHILE_READING_TABLE_WILL_BE_REBUILT, ex);
            rebuildXref();
        }
        
        pdfDocument.getXref().markReadingCompleted();
        readDecryptObj();
    }
    
    protected void readObjectStream(PdfStream objectStream) throws IOException {
        int objectStreamNumber = objectStream.getIndirectReference().getObjNumber();
        int first = objectStream.getAsNumber(PdfName.First).intValue();
        int n = objectStream.getAsNumber(PdfName.N).intValue();
        byte[] bytes = readStreamBytes(objectStream, true);
        PdfTokenizer saveTokens = tokens;
        try {
            tokens = new PdfTokenizer(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(bytes)));
            int[] address = new int[n];
            int[] objNumber = new int[n];
            boolean ok = true;
            for (int k = 0; k < n; ++k) {
                ok = tokens.nextToken();
                if (!ok)
                    break;
                if (tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
                    ok = false;
                    break;
                }
                
                objNumber[k] = tokens.getIntValue();
                ok = tokens.nextToken();
                if (!ok)
                    break;
                if (tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
                    ok = false;
                    break;
                }
                
                address[k] = tokens.getIntValue() + first;
            }
            
            if (!ok)
                throw new PdfException(KernelExceptionMessageConstant.ERROR_WHILE_READING_OBJECT_STREAM);
            for (int k = 0; k < n; ++k) {
                tokens.seek(address[k]);
                tokens.nextToken();
                PdfObject obj;
                PdfIndirectReference reference = pdfDocument.getXref().get(objNumber[k]);
                if (reference.refersTo != null || reference.getObjStreamNumber() != objectStreamNumber) {
                    continue;
                }
                
                if (tokens.getTokenType() == PdfTokenizer.TokenType.Number) {
                    obj = new PdfNumber(tokens.getByteContent());
                }
                 else {
                    tokens.seek(address[k]);
                    obj = readObject(false, true);
                }
                
                reference.setRefersTo(obj);
                obj.setIndirectReference(reference);
            }
            
            objectStream.getIndirectReference().setState(PdfObject.ORIGINAL_OBJECT_STREAM);
        }
         finally {
            tokens = saveTokens;
        }
        
    }
    
    protected PdfObject readObject(PdfIndirectReference reference) {
        return readObject(reference, true);
    }
    
    protected PdfObject readObject(boolean readAsDirect) throws IOException {
        return readObject(readAsDirect, false);
    }
    
    protected PdfObject readReference(boolean readAsDirect) {
        int num = tokens.getObjNr();
        if (num < 0) {
            return createPdfNullInstance(readAsDirect);
        }
        
        PdfXrefTable table = pdfDocument.getXref();
        PdfIndirectReference reference = table.get(num);
        if (reference != null) {
            if (reference.isFree()) {
                Logger logger = LoggerFactory.getLogger(PdfReader.class);
                logger.warn(MessageFormatUtil.format(IoLogMessageConstant.INVALID_INDIRECT_REFERENCE, tokens.getObjNr(), tokens.getGenNr()));
                return createPdfNullInstance(readAsDirect);
            }
            
            if (reference.getGenNumber() != tokens.getGenNr()) {
                if (fixedXref) {
                    Logger logger = LoggerFactory.getLogger(PdfReader.class);
                    logger.warn( MessageFormatUtil.format(IoLogMessageConstant.INVALID_INDIRECT_REFERENCE, tokens.getObjNr(), tokens.getGenNr()));
                    return createPdfNullInstance(readAsDirect);
                }
                 else {
                    throw new PdfException(KernelExceptionMessageConstant.INVALID_INDIRECT_REFERENCE, MessageFormatUtil.format("{0} {1} R", reference.getObjNumber(), reference.getGenNumber()));
                }
                
            }
            
        }
         else {
            if (table.isReadingCompleted()) {
                Logger logger = LoggerFactory.getLogger(PdfReader.class);
                logger.warn(MessageFormatUtil.format(IoLogMessageConstant.INVALID_INDIRECT_REFERENCE, tokens.getObjNr(), tokens.getGenNr()));
                return createPdfNullInstance(readAsDirect);
            }
             else {
                reference = table.add((PdfIndirectReference) new PdfIndirectReference(pdfDocument, num, tokens.getGenNr(), 0).setState(PdfObject.READING));
            }
            
        }
        
        return reference;
    }
    
    protected PdfObject readObject(boolean readAsDirect, boolean objStm) throws IOException {
        tokens.nextValidToken();
        PdfTokenizer.TokenType type = tokens.getTokenType();
        switch (type) {
            case StartDic: {
                PdfDictionary dict = readDictionary(objStm);
                long pos = tokens.getPosition();
                boolean hasNext;
                do {
                    hasNext = tokens.nextToken();
                }
                 while (hasNext && tokens.getTokenType() == PdfTokenizer.TokenType.Comment);
                if (hasNext && tokens.tokenValueEqualsTo(PdfTokenizer.Stream)) {
                    int ch;
                    do {
                        ch = tokens.read();
                    }
                     while (ch == 32 || ch == 9 || ch == 0 || ch == 12);
                    if (ch != '\n')
                        ch = tokens.read();
                    if (ch != '\n')
                        tokens.backOnePosition(ch);
                    return new PdfStream(tokens.getPosition(), dict);
                }
                 else {
                    tokens.seek(pos);
                    return dict;
                }
                
            }
            
            case StartArray:
                return readArray(objStm);
            case Number:
                return new PdfNumber(tokens.getByteContent());
            case String: {
                PdfString pdfString = new PdfString(tokens.getByteContent(), tokens.isHexString());
                if (encrypted && !decrypt.isEmbeddedFilesOnly() && !objStm) {
                    pdfString.setDecryption(currentIndirectReference.getObjNumber(), currentIndirectReference.getGenNumber(), decrypt);
                }
                
                return pdfString;
            }
            
            case Name:
                return readPdfName(readAsDirect);
            case Ref:
                return readReference(readAsDirect);
            case EndOfFile:
                throw new PdfException(KernelExceptionMessageConstant.UNEXPECTED_END_OF_FILE);
            default: if (tokens.tokenValueEqualsTo(PdfTokenizer.Null)) {
                    return createPdfNullInstance(readAsDirect);
                }
                 else if (tokens.tokenValueEqualsTo(PdfTokenizer.True)) {
                    if (readAsDirect) {
                        return PdfBoolean.TRUE;
                    }
                     else {
                        return new PdfBoolean(true);
                    }
                    
                }
                 else if (tokens.tokenValueEqualsTo(PdfTokenizer.False)) {
                    if (readAsDirect) {
                        return PdfBoolean.FALSE;
                    }
                     else {
                        return new PdfBoolean(false);
                    }
                    
                }
                
                return null;
        }
        
    }
    
    protected PdfName readPdfName(boolean readAsDirect) {
        if (readAsDirect) {
            PdfName cachedName = PdfName.staticNames.get(tokens.getStringValue());
            if (cachedName != null)
                return cachedName;
        }
        
        return new PdfName(tokens.getByteContent());
    }
    
    protected PdfDictionary readDictionary(boolean objStm) throws IOException {
        PdfDictionary dic = new PdfDictionary();
        while (true) {
            tokens.nextValidToken();
            if (tokens.getTokenType() == PdfTokenizer.TokenType.EndDic)
                break;
            if (tokens.getTokenType() != PdfTokenizer.TokenType.Name)
                tokens.throwError( KernelExceptionMessageConstant.THIS_DICTIONARY_KEY_IS_NOT_A_NAME, tokens.getStringValue());
            PdfName name = readPdfName(true);
            PdfObject obj = readObject(true, objStm);
            if (obj == null) {
                if (tokens.getTokenType() == PdfTokenizer.TokenType.EndDic)
                    tokens.throwError(KernelExceptionMessageConstant.UNEXPECTED_GT_GT);
                if (tokens.getTokenType() == PdfTokenizer.TokenType.EndArray)
                    tokens.throwError(KernelExceptionMessageConstant.UNEXPECTED_CLOSE_BRACKET);
            }
            
            dic.put(name, obj);
        }
        
        return dic;
    }
    
    protected PdfArray readArray(boolean objStm) throws IOException {
        PdfArray array = new PdfArray();
        while (true) {
            PdfObject obj = readObject(true, objStm);
            if (obj == null) {
                if (tokens.getTokenType() == PdfTokenizer.TokenType.EndArray)
                    break;
                if (tokens.getTokenType() == PdfTokenizer.TokenType.EndDic)
                    tokens.throwError(KernelExceptionMessageConstant.UNEXPECTED_GT_GT);
            }
            
            array.add(obj);
        }
        
        return array;
    }
    
    protected void readXref() throws IOException {
        tokens.seek(tokens.getStartxref());
        tokens.nextToken();
        if (!tokens.tokenValueEqualsTo(PdfTokenizer.Startxref)) {
            throw new PdfException(KernelExceptionMessageConstant.PDF_STARTXREF_NOT_FOUND, tokens);
        }
        
        tokens.nextToken();
        if (tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
            throw new PdfException(KernelExceptionMessageConstant.PDF_STARTXREF_IS_NOT_FOLLOWED_BY_A_NUMBER, tokens);
        }
        
        long startxref = tokens.getLongValue();
        lastXref = startxref;
        eofPos = tokens.getPosition();
        try {
            if (readXrefStream(startxref)) {
                xrefStm = true;
                return;
            }
            
        }
         catch (XrefCycledReferencesException cycledReferencesException) {
            throw cycledReferencesException;
        }
         catch (Exception ignored) {
        }
        
        pdfDocument.getXref().clear();
        tokens.seek(startxref);
        trailer = readXrefSection();
        PdfDictionary trailer2 = trailer;
        final Set<Long> alreadyVisitedXrefTables = new HashSet<>();
        while (true) {
            alreadyVisitedXrefTables.add(startxref);
            PdfNumber prev = (PdfNumber) trailer2.get(PdfName.Prev);
            if (prev == null) {
                break;
            }
            
            long prevXrefOffset = prev.longValue();
            if (alreadyVisitedXrefTables.contains(prevXrefOffset)) {
                if (StrictnessLevel.CONSERVATIVE.isStricter(this.getStrictnessLevel())) {
                    throw new PdfException(KernelExceptionMessageConstant. TRAILER_PREV_ENTRY_POINTS_TO_ITS_OWN_CROSS_REFERENCE_SECTION);
                }
                 else {
                    throw new XrefCycledReferencesException( KernelExceptionMessageConstant.XREF_TABLE_HAS_CYCLED_REFERENCES);
                }
                
            }
            
            startxref = prevXrefOffset;
            tokens.seek(startxref);
            trailer2 = readXrefSection();
        }
        
        Integer xrefSize = trailer.getAsInt(PdfName.Size);
        if (xrefSize == null) {
            throw new PdfException(KernelExceptionMessageConstant.INVALID_XREF_TABLE);
        }
        
    }
    
    protected PdfDictionary readXrefSection() throws IOException {
        tokens.nextValidToken();
        if (!tokens.tokenValueEqualsTo(PdfTokenizer.Xref))
            tokens.throwError(KernelExceptionMessageConstant.XREF_SUBSECTION_NOT_FOUND);
        PdfXrefTable xref = pdfDocument.getXref();
        while (true) {
            tokens.nextValidToken();
            if (tokens.tokenValueEqualsTo(PdfTokenizer.Trailer)) {
                break;
            }
            
            if (tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
                tokens.throwError( KernelExceptionMessageConstant.OBJECT_NUMBER_OF_THE_FIRST_OBJECT_IN_THIS_XREF_SUBSECTION_NOT_FOUND);
            }
            
            int start = tokens.getIntValue();
            tokens.nextValidToken();
            if (tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
                tokens.throwError(KernelExceptionMessageConstant.NUMBER_OF_ENTRIES_IN_THIS_XREF_SUBSECTION_NOT_FOUND);
            }
            
            int end = tokens.getIntValue() + start;
            for (int num = start; num < end; num++) {
                tokens.nextValidToken();
                long pos = tokens.getLongValue();
                tokens.nextValidToken();
                int gen = tokens.getIntValue();
                tokens.nextValidToken();
                if (pos == 0L && gen == 65535 && num == 1 && start != 0) {
                    num = 0;
                    end--;
                    continue;
                }
                
                PdfIndirectReference reference = xref.get(num);
                boolean refReadingState = reference != null && reference.checkState(PdfObject.READING) && reference.getGenNumber() == gen;
                boolean refFirstEncountered = reference == null || !refReadingState && reference.getDocument() == null;
                if (refFirstEncountered) {
                    reference = new PdfIndirectReference(pdfDocument, num, gen, pos);
                }
                 else if (refReadingState) {
                    reference.setOffset(pos);
                    reference.clearState(PdfObject.READING);
                }
                 else {
                    continue;
                }
                
                if (tokens.tokenValueEqualsTo(PdfTokenizer.N)) {
                    if (pos == 0) {
                        tokens.throwError( KernelExceptionMessageConstant.FILE_POSITION_0_CROSS_REFERENCE_ENTRY_IN_THIS_XREF_SUBSECTION);
                    }
                    
                }
                 else if (tokens.tokenValueEqualsTo(PdfTokenizer.F)) {
                    if (refFirstEncountered) {
                        reference.setState(PdfObject.FREE);
                    }
                    
                }
                 else {
                    tokens.throwError( KernelExceptionMessageConstant.INVALID_CROSS_REFERENCE_ENTRY_IN_THIS_XREF_SUBSECTION);
                }
                
                if (refFirstEncountered) {
                    xref.add(reference);
                }
                
            }
            
        }
        
        PdfDictionary trailer = (PdfDictionary) readObject(false);
        PdfObject xrs = trailer.get(PdfName.XRefStm);
        if (xrs != null && xrs.getType() == PdfObject.NUMBER) {
            int loc = ((PdfNumber) xrs).intValue();
            try {
                readXrefStream(loc);
                xrefStm = true;
                hybridXref = true;
            }
             catch (IOException e) {
                xref.clear();
                throw e;
            }
            
        }
        
        return trailer;
    }
    
    protected boolean readXrefStream(long ptr) throws IOException {
        final Set<Long> alreadyVisitedXrefStreams = new HashSet<>();
        while (ptr != -1) {
            tokens.seek(ptr);
            if (!tokens.nextToken()) {
                return false;
            }
            
            if (tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
                return false;
            }
            
            if (!tokens.nextToken() || tokens.getTokenType() != PdfTokenizer.TokenType.Number) {
                return false;
            }
            
            if (!tokens.nextToken() || !tokens.tokenValueEqualsTo(PdfTokenizer.Obj)) {
                return false;
            }
            
            alreadyVisitedXrefStreams.add(ptr);
            PdfXrefTable xref = pdfDocument.getXref();
            PdfObject object = readObject(false);
            PdfStream xrefStream;
            if (object.getType() == PdfObject.STREAM) {
                xrefStream = (PdfStream) object;
                if (!PdfName.XRef.equals(xrefStream.get(PdfName.Type))) {
                    return false;
                }
                
            }
             else {
                return false;
            }
            
            if (trailer == null) {
                trailer = new PdfDictionary();
                trailer.putAll(xrefStream);
                trailer.remove(PdfName.DecodeParms);
                trailer.remove(PdfName.Filter);
                trailer.remove(PdfName.Prev);
                trailer.remove(PdfName.Length);
            }
            
            int size = ((PdfNumber) xrefStream.get(PdfName.Size)).intValue();
            PdfArray index;
            PdfObject obj = xrefStream.get(PdfName.Index);
            if (obj == null) {
                index = new PdfArray();
                index.add(new PdfNumber(0));
                index.add(new PdfNumber(size));
            }
             else {
                index = (PdfArray) obj;
            }
            
            PdfArray w = xrefStream.getAsArray(PdfName.W);
            long prev = -1;
            obj = xrefStream.get(PdfName.Prev);
            if (obj != null)
                prev = ((PdfNumber) obj).longValue();
            xref.setCapacity(size);
            byte[] b = readStreamBytes(xrefStream, true);
            int bptr = 0;
            int[] wc = new int[3];
            for (int k = 0; k < 3; ++k) {
                wc[k] = w.getAsNumber(k).intValue();
            }
            
            for (int idx = 0; idx < index.size(); idx += 2) {
                int start = index.getAsNumber(idx).intValue();
                int length = index.getAsNumber(idx + 1).intValue();
                xref.setCapacity(start + length);
                while (length-- > 0) {
                    int type = 1;
                    if (wc[0] > 0) {
                        type = 0;
                        for (int k = 0; k < wc[0]; ++k) {
                            type = (type << 8) + (b[bptr++] & 0xff);
                        }
                        
                    }
                    
                    long field2 = 0;
                    for (int k = 0; k < wc[1]; ++k) {
                        field2 = (field2 << 8) + (b[bptr++] & 0xff);
                    }
                    
                    int field3 = 0;
                    for (int k = 0; k < wc[2]; ++k) {
                        field3 = (field3 << 8) + (b[bptr++] & 0xff);
                    }
                    
                    int base = start;
                    PdfIndirectReference newReference;
                    switch (type) {
                        case 0:
                            newReference = (PdfIndirectReference) new PdfIndirectReference(pdfDocument, base, field3, field2).setState(PdfObject.FREE);
                            break;
                        case 1:
                            newReference = new PdfIndirectReference(pdfDocument, base, field3, field2);
                            break;
                        case 2:
                            newReference = new PdfIndirectReference(pdfDocument, base, 0, field3);
                            newReference.setObjStreamNumber((int) field2);
                            break;
                        default: throw new PdfException(KernelExceptionMessageConstant.INVALID_XREF_STREAM);
                    }
                    
                    PdfIndirectReference reference = xref.get(base);
                    boolean refReadingState = reference != null && reference.checkState(PdfObject.READING) && reference.getGenNumber() == newReference.getGenNumber();
                    boolean refFirstEncountered = reference == null || !refReadingState && reference.getDocument() == null;
                    if (refFirstEncountered) {
                        xref.add(newReference);
                    }
                     else if (refReadingState) {
                        reference.setOffset(newReference.getOffset());
                        reference.setObjStreamNumber(newReference.getObjStreamNumber());
                        reference.clearState(PdfObject.READING);
                    }
                     ++start;
                }
                
            }
            
            ptr = prev;
            if (alreadyVisitedXrefStreams.contains(ptr)) {
                throw new XrefCycledReferencesException( KernelExceptionMessageConstant.XREF_STREAM_HAS_CYCLED_REFERENCES);
            }
            
        }
        
        return true;
    }
    
    protected void fixXref() throws IOException {
        fixedXref = true;
        PdfXrefTable xref = pdfDocument.getXref();
        tokens.seek(0);
        ByteBuffer buffer = new ByteBuffer(24);
        PdfTokenizer lineTokeniser = new PdfTokenizer(new RandomAccessFileOrArray(new ReusableRandomAccessSource(buffer)));
        for (; ; ) {
            long pos = tokens.getPosition();
            buffer.reset();
            if (!tokens.readLineSegment(buffer, true))
                break;
            if (buffer.get(0) >= '0' && buffer.get(0) <= '9') {
                int[] obj = PdfTokenizer.checkObjectStart(lineTokeniser);
                if (obj == null)
                    continue;
                int num = obj[0];
                int gen = obj[1];
                PdfIndirectReference reference = xref.get(num);
                if (reference != null && reference.getGenNumber() == gen) {
                    reference.fixOffset(pos);
                }
                
            }
            
        }
        
    }
    
    protected void rebuildXref() throws IOException {
        xrefStm = false;
        hybridXref = false;
        rebuiltXref = true;
        PdfXrefTable xref = pdfDocument.getXref();
        xref.clear();
        tokens.seek(0);
        trailer = null;
        ByteBuffer buffer = new ByteBuffer(24);
        PdfTokenizer lineTokeniser = new PdfTokenizer(new RandomAccessFileOrArray(new ReusableRandomAccessSource(buffer)));
        for (; ; ) {
            long pos = tokens.getPosition();
            buffer.reset();
            if (!tokens.readLineSegment(buffer, true))
                break;
            if (buffer.get(0) == 't') {
                if (!PdfTokenizer.checkTrailer(buffer))
                    continue;
                tokens.seek(pos);
                tokens.nextToken();
                pos = tokens.getPosition();
                try {
                    PdfDictionary dic = (PdfDictionary) readObject(false);
                    if (dic.get(PdfName.Root, false) != null)
                        trailer = dic;
                    else
                        tokens.seek(pos);
                }
                 catch (Exception e) {
                    tokens.seek(pos);
                }
                
            }
             else if (buffer.get(0) >= '0' && buffer.get(0) <= '9') {
                int[] obj = PdfTokenizer.checkObjectStart(lineTokeniser);
                if (obj == null)
                    continue;
                int num = obj[0];
                int gen = obj[1];
                if (xref.get(num) == null || xref.get(num).getGenNumber() <= gen) {
                    xref.add(new PdfIndirectReference(pdfDocument, num, gen, pos));
                }
                
            }
            
        }
        
        if (trailer == null)
            throw new PdfException(KernelExceptionMessageConstant.TRAILER_NOT_FOUND);
    }
    
    boolean isMemorySavingMode() {
        return memorySavingMode;
    }
    
    private void readDecryptObj() {
        if (encrypted)
            return;
        PdfDictionary enc = trailer.getAsDictionary(PdfName.Encrypt);
        if (enc == null)
            return;
        encrypted = true;
        PdfName filter = enc.getAsName(PdfName.Filter);
        if (PdfName.Adobe_PubSec.equals(filter)) {
            if (properties.certificate == null) {
                throw new PdfException( KernelExceptionMessageConstant.CERTIFICATE_IS_NOT_PROVIDED_DOCUMENT_IS_ENCRYPTED_WITH_PUBLIC_KEY_CERTIFICATE);
            }
            
            decrypt = new PdfEncryption(enc, properties.certificateKey, properties.certificate, properties.certificateKeyProvider, properties.externalDecryptionProcess);
        }
         else if (PdfName.Standard.equals(filter)) {
            decrypt = new PdfEncryption(enc, properties.password, getOriginalFileId());
        }
         else {
            throw new UnsupportedSecurityHandlerException(MessageFormatUtil.format(UnsupportedSecurityHandlerException.UnsupportedSecurityHandler, filter));
        }
        
    }
    
    private static PdfTokenizer getOffsetTokeniser(IRandomAccessSource byteSource, boolean closeStream) throws IOException {
        PdfTokenizer tok = new PdfTokenizer(new RandomAccessFileOrArray(byteSource));
        int offset;
        try {
            offset = tok.getHeaderOffset();
        }
         catch (com.itextpdf.io.exceptions.IOException ex) {
            if (closeStream) {
                tok.close();
            }
            
            throw ex;
        }
        
        if (offset != 0) {
            IRandomAccessSource offsetSource = new WindowRandomAccessSource(byteSource, offset);
            tok = new PdfTokenizer(new RandomAccessFileOrArray(offsetSource));
        }
        
        return tok;
    }
    
    private PdfObject readObject(PdfIndirectReference reference, boolean fixXref) {
        if (reference == null)
            return null;
        if (reference.refersTo != null)
            return reference.refersTo;
        try {
            currentIndirectReference = reference;
            if (reference.getObjStreamNumber() > 0) {
                PdfStream objectStream = (PdfStream) pdfDocument.getXref(). get(reference.getObjStreamNumber()).getRefersTo(false);
                readObjectStream(objectStream);
                return reference.refersTo;
            }
             else if (reference.getOffset() > 0) {
                PdfObject object;
                try {
                    tokens.seek(reference.getOffset());
                    tokens.nextValidToken();
                    if (tokens.getTokenType() != PdfTokenizer.TokenType.Obj || tokens.getObjNr() != reference.getObjNumber() || tokens.getGenNr() != reference.getGenNumber()) {
                        tokens.throwError( KernelExceptionMessageConstant.INVALID_OFFSET_FOR_THIS_OBJECT, reference.toString());
                    }
                    
                    object = readObject(false);
                }
                 catch (RuntimeException ex) {
                    if (fixXref && reference.getObjStreamNumber() == 0) {
                        fixXref();
                        object = readObject(reference, false);
                    }
                     else {
                        throw ex;
                    }
                    
                }
                
                return object != null ? object.setIndirectReference(reference) : null;
            }
             else {
                return null;
            }
            
        }
         catch (IOException e) {
            throw new PdfException(KernelExceptionMessageConstant.CANNOT_READ_PDF_OBJECT, e);
        }
        
    }
    
    private void checkPdfStreamLength(PdfStream pdfStream) throws IOException {
        if (!correctStreamLength)
            return;
        long fileLength = tokens.length();
        long start = pdfStream.getOffset();
        boolean calc = false;
        int streamLength = 0;
        PdfNumber pdfNumber = pdfStream.getAsNumber(PdfName.Length);
        if (pdfNumber != null) {
            streamLength = pdfNumber.intValue();
            if (streamLength + start > fileLength - 20) {
                calc = true;
            }
             else {
                tokens.seek(start + streamLength);
                String line = tokens.readString(20);
                if (!line.startsWith(endstream2) && !line.startsWith(endstream3) && !line.startsWith(endstream4) && !line.startsWith(endstream1)) {
                    calc = true;
                }
                
            }
            
        }
         else {
            pdfNumber = new PdfNumber(0);
            pdfStream.put(PdfName.Length, pdfNumber);
            calc = true;
        }
        
        if (calc) {
            ByteBuffer line = new ByteBuffer(16);
            tokens.seek(start);
            long pos;
            while (true) {
                pos = tokens.getPosition();
                line.reset();
                if (!tokens.readLineSegment(line, false))
                    break;
                if (line.startsWith(endstream)) {
                    streamLength = (int) (pos - start);
                    break;
                }
                 else if (line.startsWith(endobj)) {
                    tokens.seek(pos - 16);
                    String s = tokens.readString(16);
                    int index = s.indexOf(endstream1);
                    if (index >= 0)
                        pos = pos - 16 + index;
                    streamLength = (int) (pos - start);
                    break;
                }
                
            }
            
            tokens.seek(pos - 2);
            if (tokens.read() == 13) {
                streamLength--;
            }
            
            tokens.seek(pos - 1);
            if (tokens.read() == 10) {
                streamLength--;
            }
            
            pdfNumber.setValue(streamLength);
            pdfStream.updateLength(streamLength);
        }
        
    }
    
    private PdfObject createPdfNullInstance(boolean readAsDirect) {
        if (readAsDirect) {
            return PdfNull.PDF_NULL;
        }
         else {
            return new PdfNull();
        }
        
    }
    
    protected static class ReusableRandomAccessSource implements IRandomAccessSource {
        private ByteBuffer buffer;
        public ReusableRandomAccessSource(ByteBuffer buffer) {
            if (buffer == null) throw new IllegalArgumentException("Passed byte buffer can not be null.");
            this.buffer = buffer;
        }
        
        @Override
        public int get(long offset) {
            if (offset >= buffer.size()) return -1;
            return 0xff & buffer.getInternalBuffer()[(int) offset];
        }
        
        @Override
        public int get(long offset, byte[] bytes, int off, int len) {
            if (buffer == null) throw new IllegalStateException("Already closed");
            if (offset >= buffer.size())
                return -1;
            if (offset + len > buffer.size())
                len = (int) (buffer.size() - offset);
            System.arraycopy(buffer.getInternalBuffer(), (int) offset, bytes, off, len);
            return len;
        }
        
        @Override
        public long length() {
            return buffer.size();
        }
        
        @Override
        public void close() {
            buffer = null;
        }
        
    }
    
    public enum StrictnessLevel {
        CONSERVATIVE(5000), LENIENT(3000);
        private final int levelValue;
        StrictnessLevel(int levelValue) {
            this.levelValue = levelValue;
        }
        
        public boolean isStricter(StrictnessLevel compareWith) {
            return compareWith == null || this.levelValue > compareWith.levelValue;
        }
        
    }
    
}


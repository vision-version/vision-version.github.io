diff --git a/./github_diff/CVE-2017-8046/oldfiles/PatchOperation.java b/./github_diff/CVE-2017-8046/newfiles/PatchOperation.java
index 49950a3..d39c20f 100644
--- a/./github_diff/CVE-2017-8046/oldfiles/PatchOperation.java
+++ b/./github_diff/CVE-2017-8046/newfiles/PatchOperation.java
@@ -1,13 +1,18 @@
 package org.springframework.data.rest.webmvc.json.patch;
 import static org.springframework.data.rest.webmvc.json.patch.PathToSpEL.*;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import org.springframework.core.CollectionFactory;
 import org.springframework.core.convert.TypeDescriptor;
+import org.springframework.data.mapping.PropertyPath;
+import org.springframework.data.mapping.PropertyReferenceException;
 import org.springframework.expression.Expression;
 import org.springframework.expression.ExpressionException;
 import org.springframework.expression.spel.SpelEvaluationException;
+import org.springframework.util.StringUtils;
 public abstract class PatchOperation {
+	private static final String INVALID_PATH_REFERENCE = "Invalid path reference %s on type %s (from source %s)!";
 	protected final String op;
 	protected final String path;
 	protected final Object value;
@@ -100,7 +105,12 @@ public abstract class PatchOperation {
 	}
 	
 	 protected <T> Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {
-		return value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(spelExpression.getValueType(targetObject)) : value;
+		verifyPath(entityType);
+		return evaluate(spelExpression.getValueType(targetObject));
+	}
+	
+	protected final <T> Object evaluate(Class<T> targetType) {
+		return value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(targetType) : value;
 	}
 	
 	 abstract <T> void perform(Object target, Class<T> type);
@@ -120,5 +130,28 @@ public abstract class PatchOperation {
 		
 	}
 	
+	 protected PropertyPath verifyPath(Class<?> type) {
+		List<String> segments = new ArrayList<String>();
+		for (String segment : path.split("/")) {
+			if (!(segment.matches("\\d+") || segment.equals("-") || segment.isEmpty())) {
+				segments.add(segment);
+			}
+			
+		}
+		
+		if (segments.isEmpty()) {
+			return null;
+		}
+		
+		String pathSource = StringUtils.collectionToDelimitedString(segments, ".");
+		try {
+			return PropertyPath.from(pathSource, type);
+		}
+		 catch (PropertyReferenceException o_O) {
+			throw new PatchException(String.format(INVALID_PATH_REFERENCE, pathSource, type, path), o_O);
+		}
+		
+	}
+	
 }
 

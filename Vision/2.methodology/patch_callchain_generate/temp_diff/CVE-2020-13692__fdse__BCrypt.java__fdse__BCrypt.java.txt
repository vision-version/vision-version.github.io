diff --git a/./github_diff/CVE-2020-13692/oldfiles/BCrypt.java b/./github_diff/CVE-2020-13692/newfiles/BCrypt.java
index 8de0281..d784e31 100644
--- a/./github_diff/CVE-2020-13692/oldfiles/BCrypt.java
+++ b/./github_diff/CVE-2020-13692/newfiles/BCrypt.java
@@ -237,36 +237,50 @@ public class BCrypt {
 		return 1L << log_rounds;
 	}
 	
-	 private byte[] crypt_raw(byte password[], byte salt[], int log_rounds, boolean sign_ext_bug, int safety) {
-		int rounds, i, j;
+	 private byte[] crypt_raw(byte password[], byte salt[], int log_rounds, boolean sign_ext_bug, int safety, boolean for_check) {
 		int cdata[] = bf_crypt_ciphertext.clone();
 		int clen = cdata.length;
-		byte ret[];
+		long rounds;
 		if (log_rounds < 4 || log_rounds > 31) {
+			if (!for_check) {
+				throw new IllegalArgumentException("Bad number of rounds");
+			}
+			
+			if (log_rounds != 0) {
+				throw new IllegalArgumentException("Bad number of rounds");
+			}
+			
+			rounds = 0;
+		}
+		
+		else {
+			rounds = roundsForLogRounds(log_rounds);
+			if (rounds < 16 || rounds > Integer.MAX_VALUE) {
 				throw new IllegalArgumentException("Bad number of rounds");
 			}
 			
-		rounds = 1 << log_rounds;
+		}
+		
 		if (salt.length != BCRYPT_SALT_LEN) {
 			throw new IllegalArgumentException("Bad salt length");
 		}
 		
 		init_key();
 		ekskey(salt, password, sign_ext_bug, safety);
-		for (i = 0; i < rounds; i++) {
+		for (int i = 0; i < rounds; i++) {
 			key(password, sign_ext_bug, safety);
 			key(salt, false, safety);
 		}
 		
-		for (i = 0; i < 64; i++) {
-			for (j = 0; j < (clen >> 1); j++) {
+		for (int i = 0; i < 64; i++) {
+			for (int j = 0; j < (clen >> 1); j++) {
 				encipher(cdata, j << 1);
 			}
 			
 		}
 		
-		ret = new byte[clen * 4];
-		for (i = 0, j = 0; i < clen; i++) {
+		byte[] ret = new byte[clen * 4];
+		for (int i = 0, j = 0; i < clen; i++) {
 			ret[j++] = (byte) ((cdata[i] >> 24) & 0xff);
 			ret[j++] = (byte) ((cdata[i] >> 16) & 0xff);
 			ret[j++] = (byte) ((cdata[i] >> 8) & 0xff);
@@ -276,6 +290,10 @@ public class BCrypt {
 		return ret;
 	}
 	
+	private static String hashpwforcheck(byte[] passwordb, String salt) {
+		return hashpw(passwordb, salt, true);
+	}
+	
 	 public static String hashpw(String password, String salt) {
 		byte passwordb[];
 		passwordb = password.getBytes(StandardCharsets.UTF_8);
@@ -283,6 +301,10 @@ public class BCrypt {
 	}
 	
 	 public static String hashpw(byte passwordb[], String salt) {
+		return hashpw(passwordb, salt, false);
+	}
+	
+	private static String hashpw(byte passwordb[], String salt, boolean for_check) {
 		BCrypt B;
 		String real_salt;
 		byte saltb[], hashed[];
@@ -331,7 +353,7 @@ public class BCrypt {
 		}
 		
 		B = new BCrypt();
-		hashed = B.crypt_raw(passwordb, saltb, rounds, minor == 'x', minor == 'a' ? 0x10000 : 0);
+		hashed = B.crypt_raw(passwordb, saltb, rounds, minor == 'x', minor == 'a' ? 0x10000 : 0, for_check);
 		rs.append("$2");
 		if (minor >= 'a') {
 			rs.append(minor);
@@ -395,11 +417,12 @@ public class BCrypt {
 	}
 	
 	 public static boolean checkpw(String plaintext, String hashed) {
-		return equalsNoEarlyReturn(hashed, hashpw(plaintext, hashed));
+		byte[] passwordb = plaintext.getBytes(StandardCharsets.UTF_8);
+		return equalsNoEarlyReturn(hashed, hashpwforcheck(passwordb, hashed));
 	}
 	
 	 public static boolean checkpw(byte[] passwordb, String hashed) {
-		return equalsNoEarlyReturn(hashed, hashpw(passwordb, hashed));
+		return equalsNoEarlyReturn(hashed, hashpwforcheck(passwordb, hashed));
 	}
 	
 	static boolean equalsNoEarlyReturn(String a, String b) {

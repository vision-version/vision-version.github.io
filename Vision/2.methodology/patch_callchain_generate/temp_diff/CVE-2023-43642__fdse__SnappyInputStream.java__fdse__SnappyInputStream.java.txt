diff --git a/./github_diff/CVE-2023-43642/oldfiles/SnappyInputStream.java b/./github_diff/CVE-2023-43642/newfiles/SnappyInputStream.java
index 40ec424..fe926af 100644
--- a/./github_diff/CVE-2023-43642/oldfiles/SnappyInputStream.java
+++ b/./github_diff/CVE-2023-43642/newfiles/SnappyInputStream.java
@@ -3,14 +3,21 @@ import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 public class SnappyInputStream extends InputStream {
+    public static final int MAX_CHUNK_SIZE = 512 * 1024 * 1024; 
     private boolean finishedReading = false;
     protected final InputStream in;
+    private final int maxChunkSize;
     private byte[] compressed;
     private byte[] uncompressed;
     private int uncompressedCursor = 0;
     private int uncompressedLimit = 0;
     private byte[] header = new byte[SnappyCodec.headerSize()];
     public SnappyInputStream(InputStream input) throws IOException {
+        this(input, MAX_CHUNK_SIZE);
+    }
+    
+    public SnappyInputStream(InputStream input, int maxChunkSize) throws IOException {
+        this.maxChunkSize = maxChunkSize;
         this.in = input;
         readHeader();
     }
@@ -226,6 +233,10 @@ public class SnappyInputStream extends InputStream {
             throw new SnappyError(SnappyErrorCode.INVALID_CHUNK_SIZE, "chunkSize is too big or negative : " + chunkSize);
         }
         
+        if (chunkSize > maxChunkSize) {
+            throw new SnappyError(SnappyErrorCode.FAILED_TO_UNCOMPRESS, String.format("Received chunkSize %,d is greater than max configured chunk size %,d", chunkSize, maxChunkSize));
+        }
+        
         if (compressed == null || chunkSize > compressed.length) {
             try {
                 compressed = new byte[chunkSize];

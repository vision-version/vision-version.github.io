diff --git a/./github_diff/CVE-2019-20445/oldfiles/HttpObjectDecoder.java b/./github_diff/CVE-2019-20445/newfiles/HttpObjectDecoder.java
index 263bc8b..0aaedfd 100644
--- a/./github_diff/CVE-2019-20445/oldfiles/HttpObjectDecoder.java
+++ b/./github_diff/CVE-2019-20445/newfiles/HttpObjectDecoder.java
@@ -439,22 +439,34 @@ public abstract class HttpObjectDecoder extends ByteToMessageDecoder {
         
         name = null;
         value = null;
-        State nextState;
+        List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);
+        int contentLengthValuesCount = values.size();
+        if (contentLengthValuesCount > 0) {
+            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {
+                throw new IllegalArgumentException("Multiple Content-Length headers found");
+            }
+            
+            contentLength = Long.parseLong(values.get(0));
+        }
+        
         if (isContentAlwaysEmpty(message)) {
             HttpUtil.setTransferEncodingChunked(message, false);
-            nextState = State.SKIP_CONTROL_CHARS;
+            return State.SKIP_CONTROL_CHARS;
         }
          else if (HttpUtil.isTransferEncodingChunked(message)) {
-            nextState = State.READ_CHUNK_SIZE;
+            if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {
+                throw new IllegalArgumentException( "Both 'Content-Length: " + contentLength + "' and 'Transfer-Encoding: chunked' found");
+            }
+            
+            return State.READ_CHUNK_SIZE;
         }
          else if (contentLength() >= 0) {
-            nextState = State.READ_FIXED_LENGTH_CONTENT;
+            return State.READ_FIXED_LENGTH_CONTENT;
         }
          else {
-            nextState = State.READ_VARIABLE_LENGTH_CONTENT;
+            return State.READ_VARIABLE_LENGTH_CONTENT;
         }
         
-        return nextState;
     }
     
     private long contentLength() {

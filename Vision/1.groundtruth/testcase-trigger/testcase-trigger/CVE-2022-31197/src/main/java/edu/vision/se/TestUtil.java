package edu.vision.se;

import org.checkerframework.checker.nullness.qual.Nullable;
import org.junit.Assert;
import org.junit.Assume;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Utility class for JDBC tests.
 */
public class TestUtil {
    /*
     * The case is as follows:
     * 1. Typically the database and hostname are taken from System.properties or build.properties or build.local.properties
     *    That enables to override test DB via system property
     * 2. There are tests where different DBs should be used (e.g. SSL tests), so we can't just use DB name from system property
     *    That is why _test_ properties exist: they overpower System.properties and build.properties
     */
    public static final String SERVER_HOST_PORT_PROP = "_test_hostport";
    public static final String DATABASE_PROP = "_test_database";

    /*
     * Returns the Test database JDBC URL
     */
    public static String getURL() {
        return getURL(getServer(), +getPort());
    }

    public static String getURL(String server, int port) {
        return getURL(server + ":" + port, getDatabase());
    }

    public static String getURL(String hostport, String database) {
        String logLevel = "";
        if (getLogLevel() != null && !getLogLevel().equals("")) {
            logLevel = "&loggerLevel=" + getLogLevel();
        }

        String logFile = "";
        if (getLogFile() != null && !getLogFile().equals("")) {
            logFile = "&loggerFile=" + getLogFile();
        }

        String protocolVersion = "";
        if (getProtocolVersion() != 0) {
            protocolVersion = "&protocolVersion=" + getProtocolVersion();
        }

        String options = "";
        if (getOptions() != null) {
            options = "&options=" + getOptions();
        }

        String binaryTransfer = "";
        if (getBinaryTransfer() != null && !getBinaryTransfer().equals("")) {
            binaryTransfer = "&binaryTransfer=" + getBinaryTransfer();
        }

        String receiveBufferSize = "";
        if (getReceiveBufferSize() != -1) {
            receiveBufferSize = "&receiveBufferSize=" + getReceiveBufferSize();
        }

        String sendBufferSize = "";
        if (getSendBufferSize() != -1) {
            sendBufferSize = "&sendBufferSize=" + getSendBufferSize();
        }

        String ssl = "";
        if (getSSL() != null) {
            ssl = "&ssl=" + getSSL();
        }

        return "jdbc:postgresql://"
                + hostport + "/"
                + database
                + "?ApplicationName=Driver Tests"
                + logLevel
                + logFile
                + protocolVersion
                + options
                + binaryTransfer
                + receiveBufferSize
                + sendBufferSize
                + ssl;
    }

    /*
     * Returns the Test server
     */
    public static String getServer() {
        return System.getProperty("server", "localhost");
    }

    /*
     * Returns the Test port
     */
    public static int getPort() {
        return Integer.parseInt(System.getProperty("port", System.getProperty("def_pgport")));
    }

    /*
     * Returns the server side prepared statement threshold.
     */
    public static int getPrepareThreshold() {
        return Integer.parseInt(System.getProperty("preparethreshold", "5"));
    }

    public static int getProtocolVersion() {
        return Integer.parseInt(System.getProperty("protocolVersion", "0"));
    }

    public static String getOptions() {
        return System.getProperty("options");
    }

    /*
     * Returns the Test database
     */
    public static String getDatabase() {
        return System.getProperty("database");
    }

    /*
     * Returns the Postgresql username
     */
    public static String getUser() {
        return System.getProperty("username");
    }

    /*
     * Returns the user's password
     */
    public static String getPassword() {
        return System.getProperty("password");
    }

    /*
     * Returns the user for SSPI authentication tests
     */
    public static String getSSPIUser() {
        return System.getProperty("sspiusername");
    }

    /*
     * postgres like user
     */
    public static String getPrivilegedUser() {
        return System.getProperty("privilegedUser");
    }

    public static String getPrivilegedPassword() {
        return System.getProperty("privilegedPassword");
    }

    /*
     * Returns the log level to use
     */
    public static String getLogLevel() {
        return System.getProperty("loggerLevel");
    }

    /*
     * Returns the log file to use
     */
    public static String getLogFile() {
        return System.getProperty("loggerFile");
    }

    /*
     * Returns the binary transfer mode to use
     */
    public static String getBinaryTransfer() {
        return System.getProperty("binaryTransfer");
    }

    public static int getSendBufferSize() {
        return Integer.parseInt(System.getProperty("sendBufferSize", "-1"));
    }

    public static int getReceiveBufferSize() {
        return Integer.parseInt(System.getProperty("receiveBufferSize", "-1"));
    }

    public static String getSSL() {
        return System.getProperty("ssl");
    }

    static {
        try {
            initDriver();
        } catch (RuntimeException e) {
            throw e;
        } catch (Exception e) {
            throw new RuntimeException("Unable to initialize driver", e);
        }
    }

    private static boolean initialized = false;

    public static Properties loadPropertyFiles(String... names) {
        Properties p = new Properties();
        for (String name : names) {
            for (int i = 0; i < 2; i++) {
                // load x.properties, then x.local.properties
                if (i == 1 && name.endsWith(".properties") && !name.endsWith(".local.properties")) {
                    name = name.replaceAll("\\.properties$", ".local.properties");
                }
                File f = getFile(name);
                if (!f.exists()) {
                    System.out.println("Configuration file " + f.getAbsolutePath()
                            + " does not exist. Consider adding it to specify test db host and login");
                    continue;
                }
                try {
                    p.load(new FileInputStream(f));
                } catch (IOException ex) {
                    // ignore
                }
            }
        }
        return p;
    }

    private static Properties sslTestProperties = null;

    private static synchronized void initSslTestProperties() {
        if (sslTestProperties == null) {
            sslTestProperties = TestUtil.loadPropertyFiles("ssltest.properties");
        }
    }

    private static String getSslTestProperty(String name) {
        initSslTestProperties();
        return sslTestProperties.getProperty(name);
    }

    public static void assumeSslTestsEnabled() {
        Assume.assumeTrue(Boolean.parseBoolean(getSslTestProperty("enable_ssl_tests")));
    }

    public static String getSslTestCertPath(String name) {
        File certdir = TestUtil.getFile(getSslTestProperty("certdir"));
        return new File(certdir, name).getAbsolutePath();
    }

    public static void initDriver() {
        synchronized (TestUtil.class) {
            if (initialized) {
                return;
            }

            Properties p = loadPropertyFiles("build.properties");
            p.putAll(System.getProperties());
            System.getProperties().putAll(p);

            initialized = true;
        }
    }

    /**
     * Resolves file path with account of {@code build.properties.relative.path}. This is a bit tricky
     * since during maven release, maven does a temporary checkout to {@code core/target/checkout}
     * folder, so that script should somehow get {@code build.local.properties}
     *
     * @param name original name of the file, as if it was in the root pgjdbc folder
     * @return actual location of the file
     */
    public static File getFile(String name) {
        if (name == null) {
            throw new IllegalArgumentException("null file name is not expected");
        }
        if (name.startsWith("/")) {
            return new File(name);
        }
        return new File(System.getProperty("build.properties.relative.path", "./"), name);
    }

    /*
     * Helper - opens a connection with the allowance for passing additional parameters, like
     * "compatible".
     */
    public static Connection openDB(Properties props) throws SQLException {
        initDriver();

        // Allow properties to override the user name.
        String user = props.getProperty("username");
        if (user == null) {
            user = getUser();
        }
        if (user == null) {
            throw new IllegalArgumentException(
                    "user name is not specified. Please specify 'username' property via -D or build.properties");
        }
        props.setProperty("user", user);

        // Allow properties to override the password.
        String password = props.getProperty("password");
        if (password == null) {
            password = getPassword() != null ? getPassword() : "";
        }
        props.setProperty("password", password);

        // if (!props.containsKey(PGProperty.PREPARE_THRESHOLD.getName())) {
        //     PGProperty.PREPARE_THRESHOLD.set(props, getPrepareThreshold());
        // }

        // Enable Base4 tests to override host,port,database
        String hostport = props.getProperty(SERVER_HOST_PORT_PROP, getServer() + ":" + getPort());
        String database = props.getProperty(DATABASE_PROP, getDatabase());

        return DriverManager.getConnection(getURL(hostport, database), props);
    }

    /*
     * Helper - closes an open connection.
     */
    public static void closeDB(@Nullable Connection con) throws SQLException {
        if (con != null) {
            con.close();
        }
    }

    /*
     * Helper - creates a test schema for use by a test
     */
    public static void createSchema(Connection con, String schema) throws SQLException {
        Statement st = con.createStatement();
        try {
            // Drop the schema
            dropSchema(con, schema);

            // Now create the schema
            String sql = "CREATE SCHEMA " + schema;

            st.executeUpdate(sql);
        } finally {
            closeQuietly(st);
        }
    }

    /*
     * Helper - drops a schema
     */
    public static void dropSchema(Connection con, String schema) throws SQLException {
        dropObject(con, "SCHEMA", schema);
    }

    /*
     * Helper - creates a test table for use by a test
     */
    public static void createTable(Connection con, String table, String columns) throws SQLException {
        Statement st = con.createStatement();
        try {
            // Drop the table
            dropTable(con, table);

            // Now create the table
            String sql = "CREATE TABLE " + table + " (" + columns + ")";

            st.executeUpdate(sql);
        } finally {
            closeQuietly(st);
        }
    }

    /**
     * Helper creates an composite type.
     *
     * @param con    Connection
     * @param name   String
     * @param values String
     */
    public static void createCompositeType(Connection con, String name, String values, boolean shouldDrop)
            throws SQLException {
        Statement st = con.createStatement();
        try {
            if (shouldDrop) {
                dropType(con, name);
            }
            // Now create the type
            st.executeUpdate("CREATE TYPE " + name + " AS (" + values + ")");
        } finally {
            closeQuietly(st);
        }
    }

    /**
     * Drops a domain.
     *
     * @param con    Connection
     * @param domain String
     */
    public static void dropDomain(Connection con, String domain)
            throws SQLException {
        dropObject(con, "DOMAIN", domain);
    }

    /**
     * Helper creates a domain.
     *
     * @param con    Connection
     * @param name   String
     * @param values String
     */
    public static void createDomain(Connection con, String name, String values)
            throws SQLException {
        Statement st = con.createStatement();
        try {
            dropDomain(con, name);
            // Now create the table
            st.executeUpdate("create domain " + name + " as " + values);
        } finally {
            closeQuietly(st);
        }
    }


    /*
     * Helper - drops a table
     */
    public static void dropTable(Connection con, String table) throws SQLException {
        dropObject(con, "TABLE", table);
    }

    /*
     * Helper - drops a view
     */
    public static void dropView(Connection con, String view) throws SQLException {
        dropObject(con, "VIEW", view);
    }

    /*
     * Helper - drops a materialized view
     */
    public static void dropMaterializedView(Connection con, String matView) throws SQLException {
        dropObject(con, "MATERIALIZED VIEW", matView);
    }

    /*
     * Helper - drops a type
     */
    public static void dropType(Connection con, String type) throws SQLException {
        dropObject(con, "TYPE", type);
    }

    private static void dropObject(Connection con, String type, String name) throws SQLException {
        Statement stmt = con.createStatement();
        try {
            if (con.getAutoCommit()) {
                // Not in a transaction so ignore error for missing object
                stmt.executeUpdate("DROP " + type + " IF EXISTS " + name + " CASCADE");
            } else {
                // In a transaction so do not ignore errors for missing object
                stmt.executeUpdate("DROP " + type + " " + name + " CASCADE");
            }
        } finally {
            closeQuietly(stmt);
        }
    }

    /**
     * Close a Statement and ignore any errors during closing.
     */
    public static void closeQuietly(@Nullable Statement stmt) {
        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException ignore) {
            }
        }
    }

    /**
     * Close a ResultSet and ignore any errors during closing.
     */
    public static void closeQuietly(@Nullable ResultSet rs) {
        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException ignore) {
            }
        }
    }



    public static boolean isReplicationSlotActive(Connection connection, String slotName)
            throws SQLException {
        PreparedStatement stm = null;
        ResultSet rs = null;

        try {
            stm =
                    connection.prepareStatement("select active from pg_replication_slots where slot_name = ?");
            stm.setString(1, slotName);
            rs = stm.executeQuery();
            return rs.next() && rs.getBoolean(1);
        } finally {
            closeQuietly(rs);
            closeQuietly(stm);
        }
    }

    private static void waitStopReplicationSlot(Connection connection, String slotName)
            throws InterruptedException, TimeoutException, SQLException {
        long startWaitTime = System.currentTimeMillis();
        boolean stillActive;
        long timeInWait = 0;

        do {
            stillActive = isReplicationSlotActive(connection, slotName);
            if (stillActive) {
                TimeUnit.MILLISECONDS.sleep(100L);
                timeInWait = System.currentTimeMillis() - startWaitTime;
            }
        } while (stillActive && timeInWait <= 30000);

        if (stillActive) {
            throw new TimeoutException("Wait stop replication slot " + timeInWait + " timeout occurs");
        }
    }

    public static void execute(Connection connection, String sql) throws SQLException {
        try (Statement stmt = connection.createStatement()) {
            stmt.execute(sql);
        }
    }
}
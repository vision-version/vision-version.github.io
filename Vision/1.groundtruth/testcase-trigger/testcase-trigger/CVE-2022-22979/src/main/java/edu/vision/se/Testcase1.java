package edu.vision.se;

import static org.junit.Assert.assertEquals;

import java.lang.reflect.Field;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.function.Consumer;
import java.util.function.Function;

import org.junit.Before;
import org.junit.Test;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.cloud.function.context.FunctionCatalog;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.Message;
import org.springframework.util.ReflectionUtils;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.function.Tuple2;
import reactor.util.function.Tuple3;
import reactor.util.function.Tuples;

public class Testcase1 {
    private ApplicationContext context;

    @Before
    public void before() {
        System.clearProperty("spring.cloud.function.definition");
    }

    private FunctionCatalog configureCatalog() {
        return this.configureCatalog(SampleFunctionConfiguration.class);
    }

    private FunctionCatalog configureCatalog(Class<?>... configClass) {
        this.context = new SpringApplicationBuilder(configClass)
                .run("--logging.level.org.springframework.cloud.function=DEBUG",
                        "--spring.main.lazy-initialization=true");
        FunctionCatalog catalog = context.getBean(FunctionCatalog.class);
        return catalog;
    }

    @SuppressWarnings({ "rawtypes" })
    @Test
    public void concurrencyLookupTest() throws Exception {
        FunctionCatalog catalog = this.configureCatalog();
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i < 100; i++) {
            executor.execute(() -> {
                catalog.lookup("uppercase", "application/json");
            });
            executor.execute(() -> {
                catalog.lookup("numberword", "application/json");
            });
        }
        Thread.sleep(1000);
        Field frField = ReflectionUtils.findField(catalog.getClass(), "functionRegistrations");
        frField.setAccessible(true);
        Collection c = (Collection) frField.get(catalog);
        assertEquals(c.size(), 2);
    }

    @EnableAutoConfiguration
    @Configuration
    protected static class SampleFunctionConfiguration {

        AtomicReference<Object> consumerInputRef = new AtomicReference<>();

        @Bean
        public Function<Flux<Message<Event<String, Person>>>, Flux<String>> echoGenericObjectFlux() {
            return x -> x.map(eventMessage -> eventMessage.getPayload().getData().getName());
        }

        @Bean
        public Function<Person, Person> uppercasePerson() {
            return person -> {
                return new Person(person.getName().toUpperCase(), person.getId());
            };
        }

        @Bean
        public Supplier<String> numberword() {
            return () -> "one";
        }

        @Bean
        public Function<Map<String, Object>, Person> maptopojo() {
            return map -> {
                Person person = (Person) map.get("person");
                return person;
            };
        }

        @Bean
        public Function<String, String> uppercase() {
            return v -> v.toUpperCase();
        }

        @Bean
        public Function<String, Void> consumerFunction() {
            return v -> {
                System.out.println("Value: " + v);
                return null;
            };
        }

        @Bean
        public Function<Flux<String>, Flux<String>> uppercaseFlux() {
            return flux -> flux.map(v -> v.toUpperCase());
        }

        @Bean
        public Function<Void, String> voidInputFunction() {
            return v -> "voidInputFunction";
        }

        @Bean
        public Function<Flux<Void>, Flux<String>> voidInputFunctionReactive() {
            return flux -> Flux.just("voidInputFunctionReactive");
        }

        @Bean
        public Function<Mono<Void>, Flux<String>> voidInputFunctionReactive2() {
            return mono -> Flux.just("voidInputFunctionReactive2");
        }

        @Bean
        public Function<String, String> reverse() {
            return value -> new StringBuilder(value).reverse().toString();
        }

        @Bean
        public Function<Flux<String>, Flux<String>> reverseFlux() {
            return flux -> flux.map(value -> {
                return new StringBuilder(value).reverse().toString();
            });
        }

        @Bean
        public Function<Mono<Void>, Mono<Void>> monoVoidToMonoVoid() {
            return mono -> mono.doOnSuccess(v -> System.out.println("HELLO"));
        }

        // ============= MESSAGE-IN and MESSAGE-OUT functions ============

        // ============= MULTI-INPUT and MULTI-OUTPUT functions ============

        @Bean
        public Function<Tuple2<Flux<String>, Flux<Integer>>, Flux<String>> multiInputSingleOutputViaReactiveTuple() {
            return tuple -> {
                Flux<String> stringStream = tuple.getT1();
                Flux<Integer> intStream = tuple.getT2();
                return Flux.zip(stringStream, intStream, (string, integer) -> string + "-" + integer);
            };
        }
        // ========

        // MULTI-OUTPUT
        @Bean
        public Function<Flux<Person>, Tuple3<Flux<Person>, Flux<String>, Flux<Integer>>> multiOutputAsTuple() {
            return flux -> {
                Flux<Person> pubSubFlux = flux.publish().autoConnect(3);
                Flux<String> nameFlux = pubSubFlux.map(person -> person.getName());
                Flux<Integer> idFlux = pubSubFlux.map(person -> person.getId());
                return Tuples.of(pubSubFlux, nameFlux, idFlux);
            };
        }

        public Function<Flux<Person>, Flux<Tuple3<Person, String, Integer>>> multiOutputAsTuple2() {
            return null;
        }
        // ========

        @Bean
        public Function<Mono<String>, Mono<Void>> monoToMonoVoid() {
            return null;
        }

        @Bean
        public Function<Mono<String>, Mono<String>> monoToMono() {
            return mono -> mono;
        }

        @Bean
        public Function<Flux<Void>, Flux<Void>> fluxVoidToFluxVoid() {
            return null;
        }

        @Bean
        public Function<Mono<String>, Flux<Void>> monoToFluxVoid() {
            return null;
        }

        @Bean
        public Function<Flux<String>, Mono<Void>> fluxToMonoVoid() {
            return null;
        }

        @Bean
        public Function<Mono<String>, Flux<String>> monoToFlux() {
            return null;
        }

        @Bean
        public Function<Flux<String>, Mono<String>> fluxToMono() {
            return null;
        }

        @Bean
        public Supplier<String> imperativeSupplier() {
            return null;
        }

        @Bean
        public Supplier<Flux<String>> reactiveSupplier() {
            return null;
        }

        @Bean
        public Consumer<String> imperativeConsumer() {
            return System.out::println;
        }

        @Bean
        // Perhaps it should not be allowed. Recommend Function<Flux, Mono<Void>>
        public Consumer<Flux<String>> reactiveConsumer() {
            return null;
        }

        @Bean
        // Perhaps it should not be allowed. Recommend Function<Flux, Mono<Void>>
        public Consumer<Flux<Person>> reactivePojoConsumer() {
            return flux -> flux.subscribe(v -> consumerInputRef.set(v));
        }
    }

    public static class Person {
        private String name;
        private int id;

        public Person() {

        }

        public Person(String name, int id) {
            this.name = name;
            this.id = id;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getId() {
            return id;
        }

        public void setId(int id) {
            this.id = id;
        }

        @Override
        public String toString() {
            return "Person: " + name + "/" + id;
        }
    }

    private static class Product {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }

    private static class Event<K, V> {

        private K key;

        public K getKey() {
            return key;
        }

        public void setKey(K key) {
            this.key = key;
        }

        private V data;

        public V getData() {
            return data;
        }

        public void setData(V data) {
            this.data = data;
        }
    }
}
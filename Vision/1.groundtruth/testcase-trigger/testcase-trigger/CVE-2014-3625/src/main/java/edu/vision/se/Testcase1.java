package edu.vision.se;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockServletContext;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.resource.ResourceHttpRequestHandler;

public class Testcase1 {
    private ResourceHttpRequestHandler handler;

    @Before
    public void setUp() {
        List<Resource> resourcePaths = new ArrayList<Resource>();
        resourcePaths.add(new ClassPathResource("test/", getClass()));
        resourcePaths.add(new ClassPathResource("testalternatepath/", getClass()));
        handler = new ResourceHttpRequestHandler();
        handler.setLocations(resourcePaths);
        handler.setCacheSeconds(3600);
        handler.setServletContext(new TestServletContext());
    }

    @Test
    public void invalidPath() throws Exception {
        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setMethod("GET");

        MockHttpServletResponse response = new MockHttpServletResponse();

        Resource location = new ClassPathResource("test/", getClass());
        this.handler.setLocations(Arrays.asList(location));

        testInvalidPath(location, "../testsecret/secret.txt", request, response);
        testInvalidPath(location, "test/../../testsecret/secret.txt", request, response);
        testInvalidPath(location, ":/../../testsecret/secret.txt", request, response);

        location = new UrlResource(getClass().getResource("./test/"));
        this.handler.setLocations(Arrays.asList(location));
        Resource secretResource = new UrlResource(getClass().getResource("testsecret/secret.txt"));
        String secretPath = secretResource.getURL().getPath();

        testInvalidPath(location, "file:" + secretPath, request, response);
        testInvalidPath(location, "/file:" + secretPath, request, response);
        testInvalidPath(location, "url:" + secretPath, request, response);
        testInvalidPath(location, "/url:" + secretPath, request, response);
        testInvalidPath(location, "/" + secretPath, request, response);
        testInvalidPath(location, "////../.." + secretPath, request, response);
        testInvalidPath(location, "/%2E%2E/testsecret/secret.txt", request, response);
        testInvalidPath(location, "/%2e%2e/testsecret/secret.txt", request, response);
        testInvalidPath(location, " " + secretPath, request, response);
        testInvalidPath(location, "/  " + secretPath, request, response);
        testInvalidPath(location, "url:" + secretPath, request, response);
    }

    private void testInvalidPath(Resource location, String requestPath,
            MockHttpServletRequest request, MockHttpServletResponse response) throws Exception {

        request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, requestPath);
        response = new MockHttpServletResponse();
        this.handler.handleRequest(request, response);
        assertTrue(location.createRelative(requestPath).exists());
        assertEquals(404, response.getStatus());
    }

    private static class TestServletContext extends MockServletContext {
        @Override
        public String getMimeType(String filePath) {
            if (filePath.endsWith(".css")) {
                return "text/css";
            } else if (filePath.endsWith(".js")) {
                return "text/javascript";
            } else {
                return super.getMimeType(filePath);
            }
        }
    }
}